[
  {
    "objectID": "01-fundamentos_r.html#rstudio",
    "href": "01-fundamentos_r.html#rstudio",
    "title": "1  Fundamentos de R",
    "section": "1.1 RStudio",
    "text": "1.1 RStudio\nPara instalação, faça o download do R em http://www.r-project.org. Em seguida, instale a IDE (Integrated Development Environment) R Studio.\nAo abrir o RStudio, clique no menu File/ New File/ R Script (ou Ctrl+Shift+N). Você deve ver uma estrutura como a mostrada na figura abaixo.\n\n\n\nInterface do Rstudio\n\n\nNote que são quatro paineis:\n\nPainel de Scripts (superior esquerdo): este painel é onde você pode escrever, editar e executar scripts R. Ele fornece recursos como destaque de sintaxe, autocompletar e verificação de código para ajudar na escrita de código.\nPainel de Console (inferior esquerdo):o console é onde o código R é executado e os resultados são exibidos. Você pode inserir comandos diretamente aqui e ver imediatamente os resultados. Ele também mantém um histórico de comandos executados, o que pode ser útil para referência futura.\nAmbiente/Workspace (superior direito): este painel exibe informações sobre os objetos (como variáveis, funções, etc.) atualmente carregados na memória do R. Ele mostra detalhes como o nome do objeto, tipo de objeto e seu valor atual. Isso é útil para monitorar e gerenciar objetos durante uma sessão de trabalho.\nArquivos/Plots/Pacotes/Ajuda (inferior direito): um painel com diversas funcionalidades.\n\nArquivos: Esta guia permite navegar e gerenciar os arquivos do seu projeto. Você pode criar, renomear, excluir e organizar arquivos e pastas diretamente dentro do RStudio.\nGráficos (Plots): Aqui são exibidos os gráficos gerados pelo R. Quando você cria um gráfico usando funções de visualização em R, o resultado é exibido nesta guia. Isso facilita a análise visual dos seus dados e a inspeção dos gráficos durante o processo de criação.\nPacotes: Nesta guia, você pode visualizar e gerenciar os pacotes instalados no seu ambiente R. Ela exibe uma lista de todos os pacotes instalados, juntamente com sua versão e status (carregado ou não). Além disso, você pode instalar novos pacotes, atualizar pacotes existentes e carregar ou descarregar pacotes conforme necessário para o seu trabalho.\nAjuda (Help): Esta guia fornece acesso rápido à documentação e às informações de ajuda sobre funções, pacotes e outros recursos do R. Você pode pesquisar por tópicos específicos e acessar a documentação oficial diretamente no RStudio. Isso é útil para obter informações sobre a sintaxe de uma função, exemplos de uso e detalhes sobre os parâmetros disponíveis."
  },
  {
    "objectID": "01-fundamentos_r.html#sec-tipodedados",
    "href": "01-fundamentos_r.html#sec-tipodedados",
    "title": "1  Fundamentos de R",
    "section": "1.2 Tipos de dados",
    "text": "1.2 Tipos de dados\nSempre que estiver aprendendo uma nova linguagem, procure primeiro saber quais são os tipos de dados básicos que podem ser representandos nessa linguagem.\nEm R, são quatro os tipos básicos de dados disponíveis: numéricos, lógicos, caracteres e fatores.\n\n1.2.1 O tipo de dado numérico\nOs dados numéricos (numeric) são usados para expressar valores quantitativos, como preços, taxas e quantidades, sendo representados por números inteiros ou decimais.\n\n# Número inteiro representando quantidade de acoes em uma carteira\nqtd_acoes &lt;- 100\n\n# Número de ponto flutuante representando a taxa de inflação\ntaxa_inflacao &lt;- 3.5\n\n# Verificando a classe de taxa_inflacao\nclass(taxa_inflacao)\n\n[1] \"numeric\"\n\n\nA função class() é usada para determinar a classe de uma variável. Em outras palavras, ela fornece informações sobre o tipo de dado que uma variável representa. Nesse caso acima, a variável taxa_inflacao é da classe numeric.\n\n\n1.2.2 O tipo de dado lógico\nOs dados lógicos (logical) são empregados para representar estados ou condições, como verdadeiro ou falso, sendo úteis em operações de lógica e comparação.\n\n# Verificando se a taxa de juros está aumentando\ntaxa_juros_aumentando &lt;- TRUE\n\n# Verificando se o preço das ações está caindo\nqueda_preco_acoes &lt;- FALSE\n\n# Verificando a classe de queda_preco_acoes\nclass(queda_preco_acoes)\n\n[1] \"logical\"\n\n\n\n\n1.2.3 O tipo de dado caractere\nJá os dados do tipo caractere (character) são utilizados para representar texto, como nomes de países, empresas ou categorias, sendo essenciais em análises descritivas e comunicação de resultados.\n\n# Nome de um país\npais &lt;- \"Brasil\"\n\n# Nome de uma empresa multinacional\nempresa &lt;- \"Petróleo Brasileiro S.A.\"\n\n# Verificando a classe de pais\nclass(pais)\n\n[1] \"character\"\n\n\n\n\n1.2.4 O tipo de dado fator\nOs fatores (factor) são empregados para representar variáveis categóricas, como classificações, categorias ou grupos, uma forma eficiente de lidar com dados discretos e qualitativos.\n\n# Classificação do risco de crédito de uma empresa\nrisco_credito &lt;- factor(c(\"Baixo\", \"Médio\", \"Alto\", \"Baixo\", \"Alto\"))\n\n# Verificando a classe de risco_credito\nclass(risco_credito)\n\n[1] \"factor\"\n\n\nA função levels() retorna os níveis (ou categorias) de um fator. Isso é útil para entender quais são as categorias representadas pelo fator e para realizar operações de manipulação de dados com base nessas categorias.\n\n# Exibindo os níveis de risco de crédito\nlevels(risco_credito)\n\n[1] \"Alto\"  \"Baixo\" \"Médio\""
  },
  {
    "objectID": "01-fundamentos_r.html#fundamentos-da-linguagem",
    "href": "01-fundamentos_r.html#fundamentos-da-linguagem",
    "title": "1  Fundamentos de R",
    "section": "1.3 Fundamentos da linguagem",
    "text": "1.3 Fundamentos da linguagem\nO ambiente R refere-se ao espaço de trabalho onde todas as variáveis, funções e objetos criados durante uma sessão R são armazenados e manipulados. O ambiente inclui tanto os objetos que você criou quanto os que são carregados automaticamente por meio de pacotes ou outros mecanismos de importação de dados (mais sobre pacotes na Section 2.4).\nPor exemplo, ao usar a função ls() (que lista os nomes dos objetos no ambiente atual), podemos ver todos os objetos atualmente presentes no ambiente R.\n\n\nls()\n\nSe você executou corretamente todos os comandos da Seção Section 1.2, deve obter como resultado no console o seguinte:\n[1] \"empresa\"               \"pais\"                  \"qtd_acoes\"\n[4] \"queda_preco_acoes\"     \"taxa_inflacao\"         \"taxa_juros_aumentando\"\nusando R como calculadora numeros especiais"
  },
  {
    "objectID": "01-fundamentos_r.html#variáveis",
    "href": "01-fundamentos_r.html#variáveis",
    "title": "1  Fundamentos de R",
    "section": "1.4 Variáveis",
    "text": "1.4 Variáveis\nNa Section 1.2 algumas variáveis foram criadas. Por exemplo a variável empresa que armazena uma cadeia de caracteres. Você viu, anteriormente a maneira de listar todas as variáveis definidas no seu ambiente. Mas, afinal, o que são variáveis?\nNo R, variáveis são elementos fundamentais usados para armazenar e manipular dados. Elas são como recipientes que guardam valores, objetos ou expressões. Quando você atribui um valor a uma variável, está basicamente dando um nome a esse valor para poder acessá-lo e manipulá-lo posteriormente.\nPor exemplo, ao escrever preco_acao &lt;- 10, você está criando uma variável chamada preco_acao e atribuindo a ela o valor 10. Agora, sempre que você usar preco_acao em seu código, estará se referindo a esse valor.\nUma prática comum escolher nomes descritivos para variáveis que ajudem a entender seu propósito ou conteúdo. Por exemplo, em um contexto econômico, você pode usar preco_acao para representar o preço de uma ação ou taxa_inflacao para representar a taxa de inflação.\nPara atribuir um valor a uma variável, use o operador &lt;-. O operador = também pode ser usado para atribuir valores a variáveis. Ambos os operadores têm o mesmo efeito prático na atribuição de valores a variáveis em R. A escolha entre eles geralmente se resume à preferência pessoal e ao estilo de codificação, embora alguns guias de estilo de código sugiram o uso do &lt;-."
  },
  {
    "objectID": "01-fundamentos_r.html#verificando-o-tipo-de-uma-variável",
    "href": "01-fundamentos_r.html#verificando-o-tipo-de-uma-variável",
    "title": "1  Fundamentos de R",
    "section": "1.5 Verificando o tipo de uma variável",
    "text": "1.5 Verificando o tipo de uma variável\nVamos usar as funções da família is.* para vericar os tipos de algumas das variáveis que estão no nosso ambiente de trabalho.\n\nPara a variável empresa:\n\n\nis.character(empresa)\n\nIsso retornará TRUE se a variável empresa for do tipo caractere (character).\n\nPara a variável pais:\n\n\nis.character(pais)\n\nAssim como para a variável empresa, isso retornará TRUE se a variável pais for do tipo caractere.\n\nPara a variável qtd_acoes:\n\n\nis.numeric(qtd_acoes)\n\nIsso retornará TRUE se a variável qtd_acoes for do tipo numérico (numeric).\n\nPara a variável queda_preco_acoes:\n\n\nis.logical(queda_preco_acoes)\n\nIsso retornará TRUE se a variável queda_preco_acoes for do tipo lógico (logical).\n\nPara a variável taxa_inflacao:\n\n\nis.numeric(taxa_inflacao)\n\nAssim como para a variável qtd_acoes, isso retornará TRUE se a variável taxa_inflacao for do tipo numérico.\n\nPara a variável taxa_juros_aumentando:\n\n\nis.logical(taxa_juros_aumentando)\n\nIsso retornará TRUE se a variável taxa_juros_aumentando for do tipo lógico.\nEsses exemplos ilustram como você pode usar as funções is.* para verificar o tipo de variáveis, ajudando a garantir que você esteja manipulando os dados corretamente em suas análises.\nOutra família de funções importantes é a das funções as.*. Elas são usadas para converter um objeto de um tipo para outro. Elas permitem que você altere o tipo de dado de uma variável, o que pode ser útil em várias situações, como quando você precisa realizar operações específicas que exigem um determinado tipo de dado ou quando deseja garantir a consistência dos tipos de dados em seu código.\nAlgumas das funções as.* mais comuns incluem:\n\nas.character(): Converte um objeto para o tipo caractere (character).\n\n\nnumero &lt;- 123\nnumero_caractere &lt;- as.character(numero)\n\n\nas.numeric(): Converte um objeto para o tipo numérico (numeric).\n\n\ntexto &lt;- \"3.14\"\nnumero &lt;- as.numeric(texto)\n\n\nas.logical():\n\n\nnumero &lt;- 0\nlogico &lt;- as.logical(numero)\n\nEssas funções são úteis para garantir que os tipos de dados estejam corretos em seu código e para garantir que você possa realizar as operações desejadas em seus objetos. No entanto, é importante observar que nem todas as conversões podem ser bem-sucedidas, especialmente quando há perda de informações (por exemplo, ao converter de caractere para numérico). Portanto, é sempre uma boa prática verificar se a conversão foi feita corretamente e se os dados resultantes são os esperados.\nVeja um exemplo de conversão de caractere para numérico com texto não numérico:\n\ntexto &lt;- \"abc\"\nnumero &lt;- as.numeric(texto)\n\nWarning: NAs introduzidos por coerção\n\n\nNeste exemplo, a tentativa de converter o texto “abc” para um número resultará em um valor NA (Not Available), indicando que a conversão falhou. Veja que a saída do console indica uma mensagem de warning."
  },
  {
    "objectID": "01-fundamentos_r.html#estruturas-de-dados",
    "href": "01-fundamentos_r.html#estruturas-de-dados",
    "title": "1  Fundamentos de R",
    "section": "1.6 Estruturas de dados",
    "text": "1.6 Estruturas de dados\nEm toda análises de dados, é comum lidar com conjuntos de dados que possuem diferentes estruturas e formatos. Vamos explorar quatro estruturas de dados fundamentais em R: vetor, matriz, lista e DataFrame.\n\n1.6.1 Vetores\nUm vetor em R é uma estrutura de dados unidimensional que armazena uma sequência ordenada de elementos do mesmo tipo. A função c nos ajuda a criar vetores.\n\n# Vetor de preços de ações\nprecos_acoes &lt;- c(100, 110, 105, 120, 115)\n\nEm alguns casos, é de interesse definir sequências de números usando os operadores : e a função seq().\n\n# Vetor de números de 1 a 10\nsequencia &lt;- 1:10\nsequencia\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\n# Vetor de números de 1 a 10 com incremento de 2\nsequencia_incremento &lt;- seq(from = 1, to = 10, by = 2)\nsequencia_incremento\n\n[1] 1 3 5 7 9\n\n\nPara verificar o tamanho de um vetor, você pode usar a função length().\n\n# Verificando o tamanho do vetor de preços de ações\nlength(precos_acoes)\n\n[1] 5\n\nlength(1:10)\n\n[1] 10\n\n\nPara acessar elementos em um vetor em R, você pode usar índices numéricos ou lógicos dentro dos colchetes [ ].\nVocê pode acessar elementos usando índices numéricos dentro dos colchetes [ ]. Por exemplo, vetor[i] acessa o elemento na posição i do vetor.\n\n# Vetor de preços de ações\nprecos_acoes &lt;- c(100, 110, 105, 120, 115)\n\n# Acessando o segundo elemento do vetor\nsegundo_elemento &lt;- precos_acoes[2]\n\n# Acessando uma série de elementos do vetor\nvarios_elementos &lt;- precos_acoes[3:5]\n\nVocê também pode acessar elementos usando índices lógicos dentro dos colchetes [ ]. Por exemplo, vetor[indices_logicos] retorna os elementos do vetor onde os índices lógicos são TRUE.\n\n# Acessando preços de ações maiores que 110\nprecos_maior_que_110 &lt;- precos_acoes[precos_acoes &gt; 110]\n\n\n\n1.6.2 Matrizes\nUma matriz em R é uma estrutura de dados bidimensional que consiste em linhas e colunas de elementos do mesmo tipo. É útil para representar conjuntos de dados tabulares, como dados de séries temporais ou matrizes de covariância.\n\n# Matriz de retornos de ativos\nretornos_ativos &lt;- matrix(c(0.05, 0.03, 0.02, 0.04, 0.06, 0.03), \n                          nrow = 2, byrow = TRUE)\nrownames(retornos_ativos) &lt;- c(\"Ação 1\", \"Ação 2\")\ncolnames(retornos_ativos) &lt;- c(\"Ano 1\", \"Ano 2\", \"Ano 3\")\n\nO código acima cria uma matriz chamada retornos_ativos que armazena os retornos de dois ativos ao longo de três anos.\nA função matrix() é usada para criar a matriz. O vetor c(0.05, 0.03, 0.02, 0.04, 0.06, 0.03) contém os valores dos retornos dos ativos, fornecidos em ordem de preenchimento de coluna (de cima para baixo). Os parâmetros nrow = 2 e byrow = TRUE indicam que a matriz deve ter 2 linhas (para representar os dois ativos) e que os valores devem ser preenchidos por linha (ou seja, primeiro os retornos para o ano 1, depois para o ano 2 e assim por diante). As funções rownames() e colnames() são usadas para atribuir nomes às linhas e colunas da matriz, respectivamente. No caso das linhas, são atribuídos os nomes “Ação 1” e “Ação 2”, representando os dois ativos. Para as colunas, são atribuídos os nomes “Ano 1”, “Ano 2” e “Ano 3”, representando os anos em que os retornos foram registrados.\nA função class() retorna a classe do objeto, que neste caso será “matrix”, indicando que retornos_ativos é uma matriz em R.\nA função dim() retorna as dimensões da matriz, ou seja, o número de linhas e colunas.\n\n# Verificando as dimensões da matriz\ndim(retornos_ativos)\n\n[1] 2 3\n\n\nNeste caso, o resultado será [2, 3], indicando que a matriz possui 2 linhas e 3 colunas.\nAs funções nrow() e ncol() retornam o número de linhas e colunas da matriz, respectivamente.\n\nc(nrow(retornos_ativos), ncol(retornos_ativos))\n\n[1] 2 3\n\n\nA função length() retorna o número total de elementos em um objeto. Para uma matriz, isso retornará o número total de elementos, ou seja, o produto do número de linhas pelo número de colunas.\n\nlength(retornos_ativos)\n\n[1] 6\n\n\nPara acessar linhas, colunas e elementos em uma matriz em R, você pode usar índices numéricos ou nomes (se definidos). Aqui está como fazer:\n\nAcessando Linhas e Colunas: Você pode acessar linhas e colunas usando índices numéricos dentro dos colchetes [ ]. Por exemplo, matriz[i, ] acessa a linha i e matriz[, j] acessa a coluna j. Para acessar uma célula específica, você usa matriz[i, j], onde i é o número da linha e j é o número da coluna.\n\n\n# Acessando a primeira linha da matriz\nprimeira_linha &lt;- retornos_ativos[1, ]\n\n# Acessando a segunda coluna da matriz\nsegunda_coluna &lt;- retornos_ativos[, 2]\n\n# Acessando o elemento na segunda linha e terceira coluna da matriz\nelemento &lt;- retornos_ativos[2, 3]\n\n# Acessando as três primeiras linhas da matriz\nprimeiras_linhas &lt;- retornos_ativos[1:2, ]\n\n# Acessando mais de uma coluna da matriz\nalgumas_colunas &lt;- retornos_ativos[, c(1,3)]\n\n\nAcessando Linhas e Colunas por Nomes: Se você definiu nomes para as linhas e/ou colunas da matriz, você pode acessá-las usando esses nomes.\n\n\n# Acessando a linha chamada \"Ação 1\"\nacao1 &lt;- retornos_ativos[\"Ação 1\", ]\n\n# Acessando a coluna chamada \"Ano 2\"\nano2 &lt;- retornos_ativos[, \"Ano 2\"]\n\n# Acessando o elemento na linha \"Ação 2\" e coluna \"Ano 3\"\nelemento2 &lt;- retornos_ativos[\"Ação 2\", \"Ano 3\"]\n\nEm R, diferente de outras linguagens de programação, os índices de linhas e colunas em matrizes (e também em vetores, listas, etc.) começam em 1 e não em 0. Isso significa que o primeiro elemento de uma matriz está no índice 1, o segundo no índice 2, e assim por diante\n\n\n1.6.3 Listas\nEm R, uma lista é uma estrutura de dados flexível que pode conter elementos de diferentes tipos, como vetores, matrizes, outras listas e até mesmo funções. As listas são úteis quando você precisa armazenar e manipular conjuntos de dados heterogêneos ou estruturas complexas.\nPodemos criar uma lista que armazena informações sobre um país, como seu nome, PIB, taxa de inflação e uma série temporal de valores de câmbio.\n\n# Criando uma lista com informações sobre um país\npais_info &lt;- list(\n  nome = \"Brasil\",\n  pib = 1609,\n  inflacao = 0.05,\n  cambio = c(4.86, 5.13, 5.20, 5.07, 4.97)\n)\n\nNeste exemplo, pais_info é uma lista que contém quatro elementos:\n\nnome: o nome do país (tipo caractere).\npib: o Produto Interno Bruto do país (tipo numérico).\ninflacao: a taxa de inflação do país (tipo numérico).\ncambio: uma série temporal de valores de câmbio do país (tipo vetor numérico).\n\nEsta lista exemplifica como podemos armazenar diferentes tipos de dados em uma lista em R. Ela pode ser usada para representar informações econômicas de um país de forma organizada e acessível.\nPara acessar elementos individuais em uma lista pelo nome, usamos o operador de dólar $.\n\n# Acessando o nome do país\npais_info$nome\n\n[1] \"Brasil\"\n\n# Acessando o PIB do país\npais_info$pib\n\n[1] 1609\n\n\nTambém podemos acessar elementos individuais em uma lista por índice usando colchetes [ ].\n\n# Acessando o primeiro elemento da lista (nome do país)\nprimeiro_elemento &lt;- pais_info[[1]]\n\n# Acessando o terceiro elemento da lista (taxa de inflação)\nterceiro_elemento &lt;- pais_info[[3]]\n\nVocê deve ter notado o uso de colchetes duplos para acessar os elementos da lista. Em R, os colchetes simples ([]) e duplos ([[]]) têm diferentes propósitos quando usados para acessar elementos em uma lista.\nImagine que uma lista em R seja como um trem, e cada elemento dessa lista é um vagão do trem. Agora, dentro de cada vagão, você pode armazenar diferentes tipos de carga, como caixas, sacos ou até mesmo outros vagões.\nPor exemplo, em um vagão você pode ter um vetor, em outro uma matriz e em outro apenas um número. Cada elemento da lista pode ser diferente do outro em tipo e conteúdo, assim como cada vagão de um trem pode conter coisas diferentes.\nQuando você quer acessar um vagão específico do trem, você usa colchetes simples [ ], e quando quer acessar os elementos dentro desse vagão, usa colchetes duplos [[ ]]. É como abrir a porta de um vagão para ver o que tem dentro e, em seguida, olhar dentro das caixas que estão dentro desse vagão para ver o que tem lá.\nVamos usar a analogia dos trens e vagões com a lista pais_info, que contém informações sobre o Brasil:\nAcessando um vagão específico\nPara acessar informações específicas sobre o Brasil, como o nome do país ou o valor do PIB, podemos usar os colchetes simples [ ]. Por exemplo: - pais_info[\"nome\"]: obtemos o vagão que contém o nome do país, e encontramos “Brasil”. - pais_info[2] : obtemos o segundo vagão, neste caso é o que contem o PIB do país, e encontramos o valor 1609.\nAcessando elementos dentro de um vagão\nAgora, se quisermos acessar elementos específicos dentro de um vagão, usamos colchetes duplos [[ ]]. Por exemplo:\n\npais_info[[\"cambio\"]]: abrimos o vagão que contém informações sobre o câmbio do país e acessamos o seu conteúdo, que é um vetor com diferentes valores de câmbio ao longo do tempo.\n\nAgora, se quisermos acessar um valor específico desse vetor, podemos usar os colchetes simples [ ] novamente:\n\npais_info[[\"cambio\"]][3]: isso abre o vagão que contém o vetor de câmbio e encontra o terceiro valor, que é 5.20.\n\nAo usar a função class() podemos notar a diferença entre os objetos obtidos ao usar colchetes simples e duplos.\n\nclass(pais_info[\"nome\"])\n\n[1] \"list\"\n\nclass(pais_info[[\"nome\"]])\n\n[1] \"character\"\n\n\n\n\n\n\n\n\nResumindo\n\n\n\nEm resumo, os colchetes simples são usados para acessar subconjuntos de elementos em uma lista, preservando sua estrutura, enquanto os colchetes duplos são usados para acessar valores individuais de uma lista, sem preservar a estrutura original.\n\n\n\n\n1.6.4 DataFrames\nOs dataframes são estruturas de dados tabulares em R que representam conjuntos de dados retangulares onde as colunas podem ser de tipos diferentes, como numérico, caractere, lógico ou fator.\nPara criar um dataframe, usamos a função data.frame(), fornecendo vetores de dados para cada coluna.\n\n# Criando um dataframe com dados econômicos\ndados_economicos &lt;- data.frame(\n  país = c(\"Brasil\", \"EUA\", \"China\", \"Índia\", \"Japão\"),\n  continente = factor(c(\"América\", \"América\", \"Ásia\", \"Ásia\", \"Ásia\")),\n  população = c(213, 328, 1441, 1380, 126),\n  pib_per_capita = c(10294, 65741, 10380, 2353, 41581),\n  inflação = c(0.02, 0.01, 0.04, 0.06, 0.005)\n)\n\nPodemos acessar elementos individuais, linhas ou colunas de um dataframe usando índices numéricos ou nomes de colunas.\n\n# Acessando a primeira linha do dataframe\n(primeira_linha &lt;- dados_economicos[1, ])\n\n    país continente população pib_per_capita inflação\n1 Brasil    América       213          10294     0.02\n\n# Acessando a coluna \"país\" do dataframe\n(paises &lt;- dados_economicos$país)\n\n[1] \"Brasil\" \"EUA\"    \"China\"  \"Índia\"  \"Japão\" \n\n# Acessando o elemento na segunda linha e terceira coluna do dataframe\n(elemento &lt;- dados_economicos[2, 3])\n\n[1] 328\n\n\nPodemos combinar dataframes com base em colunas comuns usando a função merge().\n\n# Criando outro dataframe para junção\ndados_demograficos &lt;- data.frame(\n  país = c(\"China\", \"Índia\", \"Japão\", \"Brasil\", \"EUA\"),\n  expectativa_vida = c(76, 69, 84, 75, 79)\n)\n\n# Realizando uma junção (merge) com base na coluna \"país\"\n(dados_com_demografia &lt;- merge(dados_economicos, dados_demograficos, by = \"país\"))\n\n    país continente população pib_per_capita inflação expectativa_vida\n1 Brasil    América       213          10294    0.020               75\n2  China       Ásia      1441          10380    0.040               76\n3    EUA    América       328          65741    0.010               79\n4  Índia       Ásia      1380           2353    0.060               69\n5  Japão       Ásia       126          41581    0.005               84\n\n\nPodemos combinar novas linhas de dados ao dataframe existente.\n\n# Criando outro dataframe para combinação de linhas\nmais_dados &lt;- data.frame(\n  país = c(\"África do Sul\", \"Alemanha\"),\n  continente = c(\"África\", \"Europa\"),\n  população = c(60, 83),\n  pib_per_capita = c(6151, 52947),\n  inflação = c(0.025, NA),\n  expectativa_vida = c(58, 81)\n)\n\n# Combinando os dataframes por linhas\n(todos_dados &lt;- rbind(dados_com_demografia, mais_dados))\n\n           país continente população pib_per_capita inflação expectativa_vida\n1        Brasil    América       213          10294    0.020               75\n2         China       Ásia      1441          10380    0.040               76\n3           EUA    América       328          65741    0.010               79\n4         Índia       Ásia      1380           2353    0.060               69\n5         Japão       Ásia       126          41581    0.005               84\n6 África do Sul     África        60           6151    0.025               58\n7      Alemanha     Europa        83          52947       NA               81\n\n\n\n\n\n\n\n\nDados faltantes\n\n\n\nVocê deve ter observado no dataframe mais_dados que o valor da inflação para a Alemanha está como NA. Um dado NA, abreviação de “Not Available” (não disponível), é uma marcação que indica a ausência de um valor em um conjunto de dados. No exemplo acima, a presença do dado NAna coluna de inflação para a Alemanha significa que não há um valor disponível para a inflação desse país na tabela fornecida.\nUm dado pode ser marcado como NA em diversas situações, incluindo\n\nDados ausentes: Quando não há informação disponível para um determinado campo em um conjunto de dados. Por exemplo, falta de dados sobre o índice de desemprego em determinadas regiões devido à falta de disponibilidade ou relatórios incompletos.\nErros de medição ou coleta: Em algumas situações, erros podem ocorrer durante o processo de medição ou coleta de dados, levando a valores inexatos ou ausentes. Por exemplo, ao registrar o PIB de um país, um erro humano pode levar a valores inexatos ou até mesmo ausentes em determinados trimestres devido a falhas no processo de coleta de dados.\nValores inaplicáveis: Algumas variáveis podem não ser aplicáveis a todos os casos. Por exemplo, ao analisar os gastos do governo em educação, pode não haver dados disponíveis para alguns países devido a diferenças nas políticas de relatório ou à falta de investimento em educação em determinados períodos.\nValores não registrados: Em algumas bases de dados, certos valores podem não ser registrados de propósito, seja por questões de privacidade ou por não serem relevantes para o contexto da análise. Por exemplo, ao coletar dados sobre o patrimônio líquido dos indivíduos em uma pesquisa de renda, alguns participantes podem optar por não divulgar suas informações financeiras por motivos de privacidade. Nesses casos, os valores correspondentes seriam marcados como NA."
  },
  {
    "objectID": "01-fundamentos_r.html#exercícios",
    "href": "01-fundamentos_r.html#exercícios",
    "title": "1  Fundamentos de R",
    "section": "1.7 Exercícios",
    "text": "1.7 Exercícios\n\nConsidere os seguinte setores econômico. “Financeiro”, “Tecnologia da Informação”, “Bens Industriais” e “Saúde”. Gere aleatoriamente uma amostra de tamanho 1.000, com estes setores, com igual probabilidade de cada um ser escolhido. Mostre os primeiros valores da variável resultante e conte quantas empresas pertencem a cada setor econômico."
  },
  {
    "objectID": "02-fluxos.html#estruturas-condicionais",
    "href": "02-fluxos.html#estruturas-condicionais",
    "title": "2  Fluxos de execução",
    "section": "2.1 Estruturas condicionais",
    "text": "2.1 Estruturas condicionais\nO fluxo de código em R pode ser controlado por meio de estruturas condicionais, como o if, else if e else. Essas estruturas permitem que você execute diferentes blocos de código com base em condições específicas.\n\n2.1.1 if e else\nO if é uma estrutura de controle de fluxo que executa um bloco de código se uma condição especificada for verdadeira. Se a condição for falsa, o bloco de código dentro do if não será executado. Por outro lado, o else é usado para executar um bloco de código quando a condição do if for falsa.\nA sintaxe básica do if e else em R é a seguinte:\n\nif (condição) {\n  # Bloco de código a ser executado se a condição for verdadeira\n} else {\n  # Bloco de código a ser executado se a condição for falsa\n}\n\nAqui está um exemplo prático de como usar o if e else para verificar se um número inteiro escolhido aleatóriamente entre -10 e 10 é positivo ou negativo:\n\n# Definindo a semente para garantir reprodutibilidade\nset.seed(42)\n\n# Gerando um número aleatório entre -10 e 10\nnumero &lt;- sample(-10:10, 1)\n\nif (numero &gt; 0) {\n  print(\"O número é positivo.\")\n} else {\n  print(\"O número é negativo ou zero.\")\n}\n\n[1] \"O número é positivo.\"\n\n\nNeste exemplo, sample(-10:10, 1) gera um número aleatório entre -10 e 10, e o valor é atribuído à variável numero. Além disso, set.seed(123) define a semente como 123. Isso garante que, ao gerar o número aleatório com sample(), o mesmo número seja escolhido sempre que o código for executado. Em seguida, verificamos se o número é positivo ou não e imprimimos a mensagem correspondente.\n\n\n2.1.2 else if\nAlém do if e else, também podemos usar o else if para adicionar mais condições à estrutura condicional. O else if permite verificar múltiplas condições em sequência. Se a condição do if for falsa, ele verifica a próxima condição do else if. Se todas as condições do if e else if forem falsas, o bloco de código dentro do else é executado.\nAqui está a sintaxe do else if:\n\nif (condição1) {\n  # Bloco de código a ser executado se a condição1 for verdadeira\n} else if (condição2) {\n  # Bloco de código a ser executado se a condição2 for verdadeira\n} else {\n  # Bloco de código a ser executado se nenhuma das condições anteriores for verdadeira\n}\n\nVeja um exemplo prático de como usar o if, else if e else para avaliar o desempenho de uma empresa com base em sua receita anual:\n\n# Determina a classificação da empresa com base na receita anual\nreceita_anual &lt;- 1500000\n\nif (receita_anual &gt;= 2000000) {\n  print(\"Empresa de Grande Porte\")\n} else if (receita_anual &gt;= 1000000) {\n  print(\"Empresa de Médio Porte\")\n} else if (receita_anual &gt;= 500000) {\n  print(\"Empresa de Pequeno Porte\")\n} else {\n  print(\"Microempresa\")\n}\n\n[1] \"Empresa de Médio Porte\"\n\n\nNeste exemplo, a empresa é classificada com base em sua receita anual. Se a receita for igual ou superior a 2.000.000, a empresa será classificada como “Empresa de Grande Porte”. Se estiver entre 1.000.000 e 1.999.999, será classificada como “Empresa de Médio Porte”. Se estiver entre 500.000 e 999.999, será classificada como “Empresa de Pequeno Porte”. Caso contrário, será considerada uma “Microempresa”."
  },
  {
    "objectID": "02-fluxos.html#estruturas-de-repetição",
    "href": "02-fluxos.html#estruturas-de-repetição",
    "title": "2  Fluxos de execução",
    "section": "2.2 Estruturas de repetição",
    "text": "2.2 Estruturas de repetição\nAs estruturas de repetição, também conhecidas como loops, são utilizadas para executar um bloco de código repetidamente enquanto uma condição específica for verdadeira ou para percorrer uma sequência de elementos. Isso é útil quando você precisa executar uma tarefa várias vezes ou quando deseja iterar sobre uma coleção de dados.\n\n2.2.1 for\nUma das estruturas de repetição mais comuns é o loop for. O loop for é usado para iterar sobre uma sequência de valores, como uma sequência numérica de números inteiros ou os elementos de um vetor.\nExistem duas maneiras de se usar o for loop.\n\nUsando for para iterar sobre índices:\n\n\n# Exemplo de loop for para iterar sobre índices\nfor (i in 1:5) {\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\nNeste exemplo, o loop for itera sobre os valores de 1 a 5. Na primeira iteração, i é igual a 1; na segunda iteração, i é igual a 2; e assim por diante, até que i seja igual a 5.\n\nUsando for para iterar sobre elementos:\n\n\n# Exemplo de loop for para iterar sobre elementos de um vetor\nclientes &lt;- c(\"João\", \"Maria\", \"José\", \"Ana\")\nfor (nome in clientes) {\n  print(nome)\n}\n\n[1] \"João\"\n[1] \"Maria\"\n[1] \"José\"\n[1] \"Ana\"\n\n\nNeste exemplo acima, o loop for itera sobre os elementos do vetor clientes. Na primeira iteração, nome é igual a “João”; na segunda iteração, nome é igual a “Maria”; e assim por diante, até que todos os elementos do vetor sejam percorridos.\nEm ambos os exemplos, o bloco de código dentro do loop for é executado repetidamente para cada valor de i (no primeiro exemplo) ou nome (no segundo exemplo) até que a sequência seja completamente percorrida.\nNo exemplo abaixo, vamos simular dados econômicos para 10 países fictícios e calcular o PIB per capita de cada país.\n\nset.seed(42)\npib_paises &lt;- runif(10, min = 25000000, max = 40000000)\npopulacao_paises &lt;- runif(10, min = 1000000, max = 15000000)\n\npib_per_capita &lt;- numeric(length = 10)\n\n# Loop for para calcular o PIB per capita para cada pais\nfor (i in 1:10) {\n  # Calculando o PIB per capita\n  pib_per_capita[i] &lt;- pib_paises[i] / populacao_paises[i]\n}\nprint(round(pib_per_capita, 3))\n\n [1]  5.227  3.529  2.080  8.185  4.634  2.315  2.453 10.216  4.556  4.022\n\n\n\n\n\n\n\n\nClique e veja um exemplo extra\n\n\n\n\n\nImagine que temos uma série temporal representando o preço de fechamento diário de uma ação ao longo de um período de 30 dias. Queremos calcular a média móvel de 5 dias desse preço, ou seja, para cada dia, queremos calcular a média dos preços de fechamento dos cinco dias anteriores, incluindo o dia atual.\nPrimeiro, vamos simular os dados do preço de fechamento diário da ação:\n\nset.seed(42)\npreco_acao &lt;- runif(30, min = 9, max = 15)\n\nAgora, vamos calcular a média móvel de 5 dias usando um loop for:\n\nmedia_movel &lt;- numeric(length = 26)  # Vetor para armazenar a média móvel\n\nfor (i in 5:30) {\n  media_movel[i - 4] &lt;- mean(preco_acao[(i - 4):i])\n}\n\nNeste loop for, começamos a partir do quinto dia, pois precisamos de pelo menos cinco dias para calcular a média móvel de 5 dias. Para cada dia a partir do quinto dia até o trigésimo dia, calculamos a média dos preços de fechamento dos cinco dias anteriores, incluindo o dia atual, e armazenamos esse valor no vetor media_movel.\nAgora, podemos imprimir a média móvel calculada:\n\nprint(media_movel)\n\n [1] 13.33226 12.85740 12.61682 12.43505 12.22691 12.30289 12.22926 12.20829\n [9] 13.16830 12.68642 12.39510 12.97382 13.28476 12.30414 12.56762 12.68527\n[17] 12.64209 11.63467 12.68036 13.24636 12.67289 12.20510 12.50690 12.40711\n[25] 11.80747 12.71175\n\n\nEste exemplo demonstra como usar um loop for em conjunto com vetores para calcular a média móvel de uma série temporal. O gráfico abaixo mostra a média móvel ao longo dos dias.\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nVocê vai aprender a construir gráficos como este no Capítulo 4.\n\n\n\n\n\n\n\n2.2.2 while\nA estrutura while é usada para repetir um bloco de código enquanto uma condição especificada for verdadeira. Aqui está a estrutura geral de um loop while:\n\nwhile (condição) {\n  # Código a ser repetido enquanto a condição for verdadeira\n}\n\nA condição é uma expressão lógica que é avaliada antes de cada execução do bloco de código dentro do loop. Se a condição for verdadeira, o bloco de código é executado; se a condição for falsa, o loop é interrompido e o controle é passado para a próxima linha de código após o loop.\nNo exemplo abaixo, vamos definir um vetor chamado acoes, que contém uma lista de atividades possíveis que uma pessoa pode realizar durante o dia. Dentre as ações possíveis, uma será escolhida aleatoriamente.\n\nacoes &lt;- c( \"Aprender a programar em R\",\n        \"Aprender a programar em Python\",\n        \"Fazer um café\",\n        \"Descansar\")\n\nset.seed(42)\nacao &lt;- sample(acoes, 1)\nprint(acao)\n\n[1] \"Aprender a programar em R\"\n\n\nNo trecho de código a seguir, usamos a estrutura while para continuar selecionando aleatoriamente uma atividade do vetor acoes até que a atividade selecionada seja “Descansar”. O loop começa verificando se a variável acao é diferente de “Descansar”. Se essa condição for verdadeira, uma nova atividade é selecionada aleatoriamente do vetor acoes usando a função sample() com size = 1, o que significa que estamos selecionando apenas um elemento aleatório do vetor. Em seguida, a atividade selecionada é impressa na tela usando a função print(). Esse processo se repete até que a atividade selecionada seja “Descansar”, momento em que o loop é encerrado.\n\nset.seed(420)\nwhile(acao != \"Descansar\") {\n  acao &lt;- sample(acoes, 1)\n  print(acao)\n}\n\n[1] \"Aprender a programar em R\"\n[1] \"Aprender a programar em R\"\n[1] \"Aprender a programar em Python\"\n[1] \"Aprender a programar em Python\"\n[1] \"Descansar\"\n\n\n\n\n\n\n\n\nClique e veja um exemplo extra\n\n\n\n\n\nVamos considerar um exemplo onde queremos simular a evolução de uma população ao longo do tempo, onde não sabemos exatamente quantos períodos serão necessários para que a população atinja um determinado limite. Neste caso, usaremos um loop while para continuar simulando o crescimento populacional até que a população alcance um certo valor limite.\n\nset.seed(42)  # Define uma semente para a replicabilidade dos resultados\n\n# População inicial\npopulacao &lt;- 1000\n\n# Taxa de crescimento anual da população (em decimal)\ntaxa_crescimento &lt;- 0.02\n\n# População limite desejada\nlimite_populacional &lt;- 2000\n\n# Inicializando o contador de anos\nanos &lt;- 0\n\n# Simulando o crescimento populacional até atingir o limite\nwhile (populacao &lt; limite_populacional) {\n  # Calculando o número de novos indivíduos neste ano\n  novos_individuos &lt;- populacao * taxa_crescimento\n  \n  # Incrementando a população com os novos indivíduos\n  populacao &lt;- populacao + novos_individuos\n  \n  # Incrementando o contador de anos\n  anos &lt;- anos + 1\n}\n\n# Imprimindo o número de anos necessários para atingir o limite populacional\nprint(paste(\"Foram necessários\", anos, \"anos para atingir uma população de\", populacao))\n\n[1] \"Foram necessários 36 anos para atingir uma população de 2039.8873437157\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nÉ possível calcular diretamente o número de anos necessários para atingir a população limite desejada. Com um pouco de álgebra você chege na seguinte fórmula para calcular o número de anos: \\[\\text{anos} = \\frac{\\log\\left(\\frac{\\text{limite\\_populacional}}{\\text{populacao\\_inicial}}\\right)}{\\log(1 + \\text{taxa\\_crescimento})}.\\]"
  },
  {
    "objectID": "02-fluxos.html#teste2",
    "href": "02-fluxos.html#teste2",
    "title": "2  Fluxos de execução",
    "section": "2.3 teste2",
    "text": "2.3 teste2"
  },
  {
    "objectID": "02-fluxos.html#while",
    "href": "02-fluxos.html#while",
    "title": "2  Fluxos de execução",
    "section": "2.3 while",
    "text": "2.3 while\nA estrutura while é usada para repetir um bloco de código enquanto uma condição especificada for verdadeira. Aqui está a estrutura geral de um loop while:\n\nwhile (condição) {\n  # Código a ser repetido enquanto a condição for verdadeira\n}\n\nA condição é uma expressão lógica que é avaliada antes de cada execução do bloco de código dentro do loop. Se a condição for verdadeira, o bloco de código é executado; se a condição for falsa, o loop é interrompido e o controle é passado para a próxima linha de código após o loop.\nNo exemplo abaixo, vamos definir um vetor chamado acoes, que contém uma lista de atividades possíveis que uma pessoa pode realizar durante o dia. Dentre as ações possíveis, uma será escolhida aleatoriamente.\n\nacoes &lt;- c( \"Aprender a programar em R\",\n        \"Aprender a programar em R\",\n        \"Fazer um café\",\n        \"Descansar\")\n\nset.seed(42)\nacao &lt;- sample(acoes, 1)\nprint(acao)\n\n[1] \"Aprender a programar em R\"\n\n\nNo trecho de código a seguir, usamos a estrutura while para continuar selecionando aleatoriamente uma atividade do vetor acoes até que a atividade selecionada seja “Descansar”. O loop começa verificando se a variável acao é diferente de “Descansar”. Se essa condição for verdadeira, uma nova atividade é selecionada aleatoriamente do vetor acoes usando a função sample() com size = 1, o que significa que estamos selecionando apenas um elemento aleatório do vetor. Em seguida, a atividade selecionada é impressa na tela usando a função print(). Esse processo se repete até que a atividade selecionada seja “Descansar”, momento em que o loop é encerrado.\n\nwhile(acao != \"Descansar\") {\n  acao &lt;- sample(acoes, 1)\n  print(acao)\n}\n\n[1] \"Aprender a programar em R\"\n[1] \"Aprender a programar em R\"\n[1] \"Aprender a programar em R\"\n[1] \"Aprender a programar em R\"\n[1] \"Descansar\"\n\n\n\n\n\n\n\n\nClique e veja um exemplo extra\n\n\n\n\n\nVamos considerar um exemplo onde queremos simular a evolução de uma população ao longo do tempo, onde não sabemos exatamente quantos períodos serão necessários para que a população atinja um determinado limite. Neste caso, usaremos um loop while para continuar simulando o crescimento populacional até que a população alcance um certo valor limite.\n\nset.seed(42)  # Define uma semente para a replicabilidade dos resultados\n\n# População inicial\npopulacao &lt;- 1000\n\n# Taxa de crescimento anual da população (em decimal)\ntaxa_crescimento &lt;- 0.02\n\n# População limite desejada\nlimite_populacional &lt;- 2000\n\n# Inicializando o contador de anos\nanos &lt;- 0\n\n# Simulando o crescimento populacional até atingir o limite\nwhile (populacao &lt; limite_populacional) {\n  # Calculando o número de novos indivíduos neste ano\n  novos_individuos &lt;- populacao * taxa_crescimento\n  \n  # Incrementando a população com os novos indivíduos\n  populacao &lt;- populacao + novos_individuos\n  \n  # Incrementando o contador de anos\n  anos &lt;- anos + 1\n}\n\n# Imprimindo o número de anos necessários para atingir o limite populacional\nprint(paste(\"Foram necessários\", anos, \"anos para atingir uma população de\", populacao))\n\n[1] \"Foram necessários 36 anos para atingir uma população de 2039.8873437157\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nÉ possível calcular diretamente o número de necessários para atingir a população limite desejada. Com um pouco de álgebra você chege na seguinte fórmula para calcular o número de anos: \\[\\text{anos} = \\frac{\\log\\left(\\frac{\\text{limite\\_populacional}}{\\text{populacao\\_inicial}}\\right)}{\\log(1 + \\text{taxa\\_crescimento})}.\\]"
  },
  {
    "objectID": "02-fluxos.html#exercícios",
    "href": "02-fluxos.html#exercícios",
    "title": "2  Fluxos de execução",
    "section": "2.5 Exercícios",
    "text": "2.5 Exercícios\n1. Neste exercício, vamos simular o lançamento de uma moeda e armazenar os resultados como um fator contendo os níveis “cara” e “coroa”. Para isso, siga os passos abaixo:\na) Utilize o comando abaixo para gerar amostras aleatórias seguindo a distribuição binomial para simular o lançamento de 100 moedas:\n\nset.seed(42)\nlancamentos &lt;- rbinom(100, 1, 0.5)\n\nb) Considere que 0 represente “cara” e 1 represente “coroa”. Crie uma variável para armazenar os lançamentos como um fator contendo os níveis “cara” e “coroa”.\nc) Conte quantas vezes cada um dos resultados ocorreu neste experimento.\nd) Utilize um loop para percorrer o vetor de traz para frente e descubra qual foi o último lançamento que resultado em uma “cara”.\n2. Trabalhando com dados de pacotes.\na) Instale o pacote nycflights13 utilizando o comando abaixo:\n\ninstall.packages(\"nycflights13\")\n\nb) Carregue no seu ambiente o pacote instalado:\n\nlibrary(nycflights13)\n\nc) Utilizando os comandos abaixo, verifique o conteúdo dos dataframes flights e airports:\n\n?flights\n?airports\n\nd) Filtre os voos que aconteceram em 25/01/2013 e armazene-os na variável natal;\ne) Quantos voos partiram de Nova Iorque em 25/12/2013?\nf) Obtenha um sumário da coluna dep_delay. Há dados faltantes? Se sim, remova-os.\ng) Obtenha o nome do aeroporto de destino do voo com maior atraso de partida em 25/12/2013. Dica: mescle os dados de flights e airports."
  },
  {
    "objectID": "03-dados.html#importar-arquivos-externos",
    "href": "03-dados.html#importar-arquivos-externos",
    "title": "3  Manipulação de dados",
    "section": "3.1 Importar arquivos externos",
    "text": "3.1 Importar arquivos externos\nDois dos formatos mais comuns para armazenamento de dados não tão grandes são csv e xlsx.\nAo carregar dados de arquivos csv em R, duas opções comumente utilizadas são as funções read.csv() e read_csv(). Ambas são eficazes para importar dados tabulares, mas apresentam diferenças significativas. A função read.csv() é uma opção padrão no R base, sendo simples de usar e amplamente conhecida. Por outro lado, read_csv() faz parte do pacote readr, oferecendo desempenho otimizado e detecção automática de tipos de dados. Enquanto read.csv() tende a ser mais lenta, especialmente com grandes conjuntos de dados, read_csv() é mais rápida e precisa, sendo capaz de manter os nomes das colunas como símbolos e converter adequadamente os dados, inclusive lidando com strings vazias.\n\n# Usando read.csv()\ndados_read_csv &lt;- read.csv(\"dados.csv\")\n\n# Usando read_csv() do pacote readr\nlibrary(readr)\ndados_readr &lt;- read_csv(\"dados.csv\")\n\nPara importar dados de um arquivo Excel (formato xlsx) em R, podemos usar a biblioteca readxl. Primeiro, é necessário instalá-la usando o comando install.packages(\"readxl\"). Em seguida, podemos usar a função read_excel() para ler os dados. Por exemplo:\n\nlibrary(readxl)\ndados &lt;- read_excel(\"arquivo.xlsx\")\n\n\n\n\n\n\n\nDefinindo o seu diretório de trabalho\n\n\n\nÉ uma boa prática definir um diretório de trabalho em seus scripts R porque isso ajuda a manter a organização e facilita o acesso aos arquivos de dados e resultados. Ao definir um diretório de trabalho, você garante que todos os arquivos referenciados em seus scripts serão encontrados facilmente, sem a necessidade de especificar caminhos absolutos longos.\nPara definir o diretório de trabalho no R, você pode usar a função setwd(). Por exemplo, se você deseja definir o diretório como “C:/MeuDiretorio”, você pode fazer o seguinte:\n\nsetwd(\"C:/MeuDiretorio\")\n\nVocê pode definir o diretório usando a interface do RStudio. Basta selecionar no menu “Session” a opção “Set Working Directory” e em seguida “Choose Directory”. Isso abrirá uma caixa de diálogo onde você pode navegar até o diretório desejado e selecioná-lo. Depois de selecionar o diretório, ele se tornará o diretório de trabalho atual."
  },
  {
    "objectID": "03-dados.html#o-pacote-tidyverse",
    "href": "03-dados.html#o-pacote-tidyverse",
    "title": "3  Manipulação de dados",
    "section": "3.2 O pacote tidyverse",
    "text": "3.2 O pacote tidyverse\nO pacote tidyverse é uma coleção de pacotes do R projetados para trabalhar de forma integrada e intuitiva na análise de dados. Ele inclui uma variedade de pacotes poderosos e populares, como ggplot2, dplyr, tidyr, tibble, readr, purrr, forcats e stringr. Cada pacote no tidyverse foi projetado para lidar com uma etapa específica do fluxo de trabalho de análise de dados, desde a importação e limpeza até a visualização e modelagem. Todos os pacotes no tidyverse compartilham uma filosofia de design subjacente, gramática e estruturas de dados, veja mais na página do pacote.\n\n3.2.1 O operador pipe %&gt;%\nO operador %\\&gt;%, conhecido como pipe, é uma ferramenta poderosa em R que facilita a encadeamento de operações em sequência. Ele permite escrever código de forma mais clara e concisa, especialmente ao trabalhar com pacotes do tidyverse. O pipe recebe o resultado de uma expressão à esquerda e o passa como primeiro argumento para a próxima expressão à direita.\n\n\n\n\n\n\nTip\n\n\n\nVocê não precisa digitar %\\&gt;% toda vez que precisar. Utilize o atalho Ctrl+Shitf+M.\n\n\nVamos supor que temos uma função f, uma função g e uma variável x. Queremos aplicar g a x e, em seguida, aplicar f ao resultado. Aqui está como poderíamos fazer isso de duas maneiras: usando a abordagem encadeada tradicional e usando o pipe %&gt;%.\n\nresultado &lt;- f(g(x))\n\nx %&gt;% \n  g() %&gt;%\n  f()\n\nAmbos os métodos produzirão o mesmo resultado. No entanto, a segunda abordagem usando o pipe %&gt;% é mais legível e fácil de entender, especialmente quando estamos encadeando múltiplas operações. Isso torna o código mais conciso e mais próximo de uma leitura natural da operação que está sendo realizada.\n\n\n\n\n\n\nTip\n\n\n\nUma boa prática ao usar o pipe %&gt;% é quebrar a linha após cada pipe para melhorar a legibilidade do código.\n\n\n\n\n3.2.2 Dados no formato tidy\n\n“Tidy datasets are all alike, but every messy dataset is messy in its own way.” — Hadley Wickham.\n\nUm mesmo conjunto de dados pode ser representado de diversas maneiras. Veja o código abaixo que mostra o mesmo dado em três diferentes formatos.\n\ntable1\n\n# A tibble: 6 × 4\n  country      year  cases population\n  &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n\ntable2\n\n# A tibble: 12 × 4\n   country      year type            count\n   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n 8 Brazil       2000 population  174504898\n 9 China        1999 cases          212258\n10 China        1999 population 1272915272\n11 China        2000 cases          213766\n12 China        2000 population 1280428583\n\ntable4a\n\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n\n\nTodas as representações acima são dos mesmos dados, mas não são igualmente fáceis de utilizar. A table1, por exemplo, será muito mais acessível para trabalhar dentro do tidyverse devido à sua organização no formato tidy. Existem três regras inter-relacionadas que caracterizam um conjunto de dados no formato tidy:\n\nCada variável é uma coluna; cada coluna representa uma variável.\nCada observação é uma linha; cada linha representa uma observação.\nCada valor é uma célula; cada célula contém um único valor.\n\nA figura abaixo representa graficamente este conceito.\n\n\n\nImagem do livro R4DS.\n\n\nA pivotação de dados é o processo de reorganizar um conjunto de dados para torná-lo compatível com o formato tidy. Isso envolve transformar os dados de um formato mais largo para um formato mais longo, ou vice-versa, para garantir que cada variável corresponda a uma coluna e cada observação a uma linha.\nNo exemplo abaixo, estamos transformando os dados de table2 para um formato mais largo, onde cada valor único da variável type se torna uma nova coluna. Note que cada unidade de informação (país, ano, casos e contagem) está quebrado em duas linhas. Então essa operação deixa a tabela de dados mais larga, garantindo que cada unidade de dado esteja representada em uma única linha.\n\ntable2 %&gt;% \n  pivot_wider(names_from=\"type\", values_from=\"count\")\n\n# A tibble: 6 × 4\n  country      year  cases population\n  &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n\n\nNo exemplo abaixo, estamos transformando os dados de table4a em um formato mais longo, onde as colunas representando anos específicos (1999 e 2000) são reunidas em uma única coluna chamada year, e os valores correspondentes são colocados em uma nova coluna chamada cases. Neste caso, a informação sobre os anos estavam armazenadas como nome de colunas, mas, pelo princípio de dados tidy, deveriam estar em colunas. Por isso, utilizamos a função pivot_longer.\n\ntable4a %&gt;% \n  pivot_longer(cols = c(`1999`, `2000`), names_to = \"year\", values_to = \"cases\")\n\n# A tibble: 6 × 3\n  country     year   cases\n  &lt;chr&gt;       &lt;chr&gt;  &lt;dbl&gt;\n1 Afghanistan 1999     745\n2 Afghanistan 2000    2666\n3 Brazil      1999   37737\n4 Brazil      2000   80488\n5 China       1999  212258\n6 China       2000  213766\n\n\nAs duas funções pivot_wider e pivot_longer são suficientes para fazer a transformação de bases de dados no formato tidy.\n\n\n3.2.3 Principais verbos do pacote dplyr\nO pacote dplyr é uma das ferramentas mais poderosas para manipulação de dados no ambiente R. Ele oferece um conjunto coeso de funções que simplificam tarefas comuns de manipulação, como filtragem, seleção, agrupamento, ordenação e resumo de dados. O dplyr utiliza uma sintaxe intuitiva e consistente, facilitando a escrita de código limpo e legível.\nA seguir, vamos estudar o funcionamento dos principais verbos do pacote. Para exemplificar, vamos utilizar a base de dados gapminder. Ela é uma coleção de informações socioeconômicas de diversos países ao longo do tempo, veja Rosling (2012). Ela inclui variáveis como expectativa de vida, PIB per capita, taxa de mortalidade infantil e tamanho da população para diferentes países e anos, cobrindo um período de várias décadas.\nPara carregar a base de dados gapminder, você precisa carregar o pacote gapminder. Com o pacote gapminder carregado, a base de dados gapminder estará disponível para uso em seu ambiente R:\n\nlibrary(gapminder)\n\nWarning: package 'gapminder' was built under R version 4.2.3\n\nhead(gapminder)\n\nA função glimpse() fornece uma visão geral rápida e concisa da estrutura de um conjunto de dados. Quando aplicada a um conjunto de dados, como o gapminder, ela exibe informações essenciais sobre as variáveis presentes, incluindo a quantidade de linhas, colunas e as primeiras linhas do conjunto de dados:\n\nglimpse(gapminder)\n\nRows: 1,704\nColumns: 6\n$ country   &lt;fct&gt; \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", …\n$ continent &lt;fct&gt; Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, …\n$ year      &lt;int&gt; 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, …\n$ lifeExp   &lt;dbl&gt; 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39.854, 40.8…\n$ pop       &lt;int&gt; 8425333, 9240934, 10267083, 11537966, 13079460, 14880372, 12…\n$ gdpPercap &lt;dbl&gt; 779.4453, 820.8530, 853.1007, 836.1971, 739.9811, 786.1134, …\n\n\n\n\n3.2.4 select\nO verbo select() é utilizado para selecionar colunas específicas de um conjunto de dados. Com o select(), é possível escolher as colunas desejadas com base em seus nomes, tipos de dados ou outros critérios.\nPor exemplo, considerando a base de dados gapminder, suponha que desejamos selecionar apenas as colunas referentes ao ano, ao país, à expectativa de vida e ao PIB per capita. Podemos fazer isso da seguinte maneira:\n\n# Selecionando as colunas pelo nome\ngapminder %&gt;%\n  select(year, country, lifeExp, gdpPercap)\n\n# Selecionando apenas as colunas numéricas\ngapminder %&gt;% \n  select(where(is.numeric))\n\n# Selecionando colunas que começam com \"co\"\ngapminder %&gt;% \n  select(starts_with(\"co\"))\n\nNote que nos exemplos acima, nenhuma das seleções foi salva em variável. Para salvar as seleções em uma variável, você pode atribuir o resultado de cada operação select() a uma variável separada. Por exemplo:\n\ngapminder_character &lt;- gapminder %&gt;% \n  select(where(is.character))\n\n\n\n3.2.5 arrange\nO verbo arrange() é usado para reorganizar as linhas de um conjunto de dados com base nos valores de uma ou mais colunas. Quando aplicado a um conjunto de dados, o arrange() classifica as linhas em ordem crescente ou decrescente com base nos valores das colunas especificadas.\nNo primeiro exemplo usando o verbo select(), podemos ordenar os dados por país em ordem alfabética, podemos fazer assim:\n\ngapminder %&gt;%\n  select(year, country, lifeExp, gdpPercap, pop) %&gt;%\n  arrange(country)\n\n# A tibble: 1,704 × 5\n    year country     lifeExp gdpPercap      pop\n   &lt;int&gt; &lt;fct&gt;         &lt;dbl&gt;     &lt;dbl&gt;    &lt;int&gt;\n 1  1952 Afghanistan    28.8      779.  8425333\n 2  1957 Afghanistan    30.3      821.  9240934\n 3  1962 Afghanistan    32.0      853. 10267083\n 4  1967 Afghanistan    34.0      836. 11537966\n 5  1972 Afghanistan    36.1      740. 13079460\n 6  1977 Afghanistan    38.4      786. 14880372\n 7  1982 Afghanistan    39.9      978. 12881816\n 8  1987 Afghanistan    40.8      852. 13867957\n 9  1992 Afghanistan    41.7      649. 16317921\n10  1997 Afghanistan    41.8      635. 22227415\n# ℹ 1,694 more rows\n\n\nNo exemplo abaixo, estamos organizando de acordo com o ano em ordem crescente e a expectativa de vida em ordem decrescente dentro de cada ano.\n\ngapminder %&gt;%\n  select(year, country, lifeExp, gdpPercap, pop) %&gt;%\n  arrange(year, desc(lifeExp))\n\n# A tibble: 1,704 × 5\n    year country        lifeExp gdpPercap      pop\n   &lt;int&gt; &lt;fct&gt;            &lt;dbl&gt;     &lt;dbl&gt;    &lt;int&gt;\n 1  1952 Norway            72.7    10095.  3327728\n 2  1952 Iceland           72.5     7268.   147962\n 3  1952 Netherlands       72.1     8942. 10381988\n 4  1952 Sweden            71.9     8528.  7124673\n 5  1952 Denmark           70.8     9692.  4334000\n 6  1952 Switzerland       69.6    14734.  4815000\n 7  1952 New Zealand       69.4    10557.  1994794\n 8  1952 United Kingdom    69.2     9980. 50430000\n 9  1952 Australia         69.1    10040.  8691212\n10  1952 Canada            68.8    11367. 14785584\n# ℹ 1,694 more rows\n\n\n\n\n\n\n\n\nTip\n\n\n\nAo utilizar o verbo select() com o prefixo -, você pode especificar as colunas que deseja excluir do conjunto de dados. No exemplo abaixo, vamos excluir a coluna continent da seleção no conjunto de dados.\n\ngapminder %&gt;% \n  select(-continent)\n\n# A tibble: 1,704 × 5\n   country      year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan  1952    28.8  8425333      779.\n 2 Afghanistan  1957    30.3  9240934      821.\n 3 Afghanistan  1962    32.0 10267083      853.\n 4 Afghanistan  1967    34.0 11537966      836.\n 5 Afghanistan  1972    36.1 13079460      740.\n 6 Afghanistan  1977    38.4 14880372      786.\n 7 Afghanistan  1982    39.9 12881816      978.\n 8 Afghanistan  1987    40.8 13867957      852.\n 9 Afghanistan  1992    41.7 16317921      649.\n10 Afghanistan  1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\n\n\n\n\n3.2.6 filter\nPara analisar dados específicos de interesse, muitas vezes é necessário filtrar o conjunto de dados para incluir apenas as observações relevantes. O verbo filter() é usado para fazer isso. Basta definir uma ou mais condições lógicas que as linhas da base de dados devem satisfazer para serem mostradas.\nNo exemplo abaixo, estamos filtrando os dados para incluir apenas as observações onde o país é “Brasil” ou “Argentina”.\n\ngapminder %&gt;%\n  select(year, country, lifeExp, gdpPercap, pop) %&gt;%\n  arrange(year, desc(lifeExp)) %&gt;% \n  filter(country == \"Brazil\" | country == \"Argentina\")\n\n# A tibble: 24 × 5\n    year country   lifeExp gdpPercap       pop\n   &lt;int&gt; &lt;fct&gt;       &lt;dbl&gt;     &lt;dbl&gt;     &lt;int&gt;\n 1  1952 Argentina    62.5     5911.  17876956\n 2  1952 Brazil       50.9     2109.  56602560\n 3  1957 Argentina    64.4     6857.  19610538\n 4  1957 Brazil       53.3     2487.  65551171\n 5  1962 Argentina    65.1     7133.  21283783\n 6  1962 Brazil       55.7     3337.  76039390\n 7  1967 Argentina    65.6     8053.  22934225\n 8  1967 Brazil       57.6     3430.  88049823\n 9  1972 Argentina    67.1     9443.  24779799\n10  1972 Brazil       59.5     4986. 100840058\n# ℹ 14 more rows\n\n\n\n\n3.2.7 mutate\nO verbo mutate() é usado para criar ou modificar colunas em um conjunto de dados existente. Ele permite adicionar novas variáveis calculadas com base em variáveis existentes ou modificar as variáveis existentes de acordo com alguma lógica específica.\nPor exemplo, podemos usar o mutate() para calcular uma nova variável que represente o PIB total de cada país multiplicando o PIB per capita pelo tamanho da população. Aqui está um exemplo de como fazer isso com o conjunto de dados gapminder:\n\ngapminder_total_gdp &lt;- gapminder %&gt;%\n  select(country, year, lifeExp, gdpPercap, pop) %&gt;%\n  mutate(total_gdp = gdpPercap * pop)\n\n\n\n3.2.8 summarise\nO verbo summarise() é usado para resumir os dados em uma única linha, geralmente calculando estatísticas resumidas como média, soma, mediana, etc. Ele permite calcular resumos estatísticos em um conjunto de dados, criando uma nova tabela contendo os resultados resumidos.\nAqui está um exemplo de como usar summarise() para calcular a média da expectativa de vida usando os dados do gapminder:\n\ngapminder %&gt;%\n  summarise(mean_lifeExp = mean(lifeExp, na.rm = TRUE))\n\n# A tibble: 1 × 1\n  mean_lifeExp\n         &lt;dbl&gt;\n1         59.5\n\n\n\n\n3.2.9 group by\nO verbo group_by() é usado para dividir os dados em grupos com base nos valores de uma ou mais variáveis. Ele não realiza cálculos por si só, mas altera o comportamento das funções de resumo, como summarise(), para operar em cada grupo separadamente.\nAqui está um exemplo de como usar group_by() com os dados do gapminder para calcular a média da expectativa de vida por continente:\n\ngapminder %&gt;%\n  group_by(continent) %&gt;%\n  summarise(mean_lifeExp = mean(lifeExp, na.rm = TRUE))\n\n# A tibble: 5 × 2\n  continent mean_lifeExp\n  &lt;fct&gt;            &lt;dbl&gt;\n1 Africa            48.9\n2 Americas          64.7\n3 Asia              60.1\n4 Europe            71.9\n5 Oceania           74.3\n\n\nO exemplo abaixo utiliza todos os principais verbos do dplyr para calcular a expectativa de vida média e o PIB (em milhares) médio por continente no ano de 2007.\n\ngapminder %&gt;%\n  select(country, continent, year, lifeExp, gdpPercap) %&gt;% \n  filter(year == 2007) %&gt;% # apenas os dados para o ano de 2007\n  mutate(gdp = gdpPercap / 1000) %&gt;% # representa o PIB per capita em milhares\n  group_by(continent) %&gt;% # agrupar os dados por continente\n  summarise(mean_lifeExp = mean(lifeExp, na.rm = TRUE), # média da expectativa de vida\n            mean_gdp = mean(gdp, na.rm = TRUE)) %&gt;% #média do PIB per capita em bilhões\n  arrange(desc(mean_lifeExp))\n\n# A tibble: 5 × 3\n  continent mean_lifeExp mean_gdp\n  &lt;fct&gt;            &lt;dbl&gt;    &lt;dbl&gt;\n1 Oceania           80.7    29.8 \n2 Europe            77.6    25.1 \n3 Americas          73.6    11.0 \n4 Asia              70.7    12.5 \n5 Africa            54.8     3.09\n\n\nO gráfico abaixo mostra a evolução da expectativa de vida média nos continentes ao longo dos anos.\n\n\n\n\n\n\n\n\n\n\n\nDesafio\n\n\n\nQual mudança foi feita no código do exemplo anterior para construir os dados usados na geração deste gráfico?"
  },
  {
    "objectID": "04-visualizacao.html",
    "href": "04-visualizacao.html",
    "title": "4  Visualização de dados",
    "section": "",
    "text": "5 Exercícios\nVamos utilizar os dados da Billboard que foram apresentados na ?sec-ex-dados.\na) O gráfico abaixo mostra o histórico de cada musica no ranking ao longo das semanas. Qual o código para obter o gráfico abaixo?\nb)\nc) O gráfico abaixo mostra o histórico de duas músicas: “Higher” e “With Arms Wide Open”."
  },
  {
    "objectID": "02-fluxos.html#funções",
    "href": "02-fluxos.html#funções",
    "title": "2  Fluxos de execução",
    "section": "2.3 Funções",
    "text": "2.3 Funções\nUma função em R é um bloco de código que realiza uma tarefa específica e pode ser reutilizado várias vezes. A sintaxe para definir uma função em R segue o padrão:\n\nnome_da_funcao &lt;- function(parametros) {\n  # Corpo da função\n  # Código que realiza a tarefa desejada\n  # Pode incluir operações matemáticas, manipulação de dados, etc.\n  return(resultado)  # Retorna o resultado desejado\n}\n\nOs parâmetros são variáveis que uma função recebe como entrada para executar suas operações. Eles são especificados entre parênteses na definição da função. Dentro do corpo da função, os parâmetros podem ser utilizados para realizar cálculos ou operações.\nO exemplo abaixo define uma função para realizar uma regressão linear simples. A função regressao_linear recebe dois parâmetros: x e y, que representam os dados de entrada para a regressão linear. Dentro da função, um modelo de regressão linear é criado usando a função lm() do R com os dados y em função de x. A documentação da função lm() pode ser acessada ao executar o comando ?lm. O modelo resultante é retornado como resultado da função.\n\n# Função para realizar regressão linear simples\nregressao_linear &lt;- function(x, y) {\n  modelo &lt;- lm(y ~ x)  # Criando o modelo de regressão linear\n  return(modelo)  # Retornando o modelo\n}\n\n# Dados de exemplo: salário (y) em função dos anos de educação (x)\nanos_educacao &lt;- c(10, 12, 14, 16, 18)\nsalario &lt;- c(2500, 3300, 3550, 3700, 4500)\n\n# Chamando a função de regressão linear\nmodelo_regressao &lt;- regressao_linear(anos_educacao, salario)\n\nVeja o sumário com o resultado do modelo treinado.\n\n# Exibindo os resultados da regressão\nsummary(modelo_regressao)\n\n\nCall:\nlm(formula = y ~ x)\n\nResiduals:\n   1    2    3    4    5 \n-130  230   40 -250  110 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)   \n(Intercept)   430.00     498.20   0.863  0.45156   \nx             220.00      34.88   6.307  0.00805 **\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 220.6 on 3 degrees of freedom\nMultiple R-squared:  0.9299,    Adjusted R-squared:  0.9065 \nF-statistic: 39.78 on 1 and 3 DF,  p-value: 0.008054\n\n\nA figura abaixo mostra um gráfico de dispersão que representa a relação entre anos de educação e salário. A reta azul mostra o modelo de regressão linear treinado com os dados.\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nVocê vai aprender a construir gráficos como este no Capítulo 4."
  },
  {
    "objectID": "02-fluxos.html#sec-pacotes",
    "href": "02-fluxos.html#sec-pacotes",
    "title": "2  Fluxos de execução",
    "section": "2.4 Pacotes",
    "text": "2.4 Pacotes\nOs pacotes no R são conjuntos de funções, conjuntos de dados e documentação que ampliam as capacidades básicas da linguagem R. Eles são essenciais para expandir a funcionalidade do R, permitindo que os usuários realizem uma ampla variedade de tarefas.\nOs pacotes do R estão disponíveis no CRAN (Comprehensive R Archive Network), um repositório centralizado que abriga uma vasta coleção de pacotes, manuais, documentações e outros recursos relacionados ao R. O CRAN é essencialmente o principal hub para distribuição de pacotes R e serve como uma fonte confiável e abrangente de ferramentas para análise de dados, estatísticas e muito mais. Para acessar os pacotes do CRAN, você pode usar a função install.packages(). Por exemplo:\n\ninstall.packages(\"nome_do_pacote\")\n\nDepois de instalar um pacote, você precisa carregá-lo em sua sessão R usando a função library():\n\nlibrary(nome_do_pacote)\n\nIsso tornará as funções e conjuntos de dados do pacote disponíveis para uso em sua sessão atual."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introdução à R e Python",
    "section": "",
    "text": "Introdução\nEste livro é composto por notas de aula do minicurso de introdução às linguagens de programação R e Python."
  },
  {
    "objectID": "04-visualizacao.html#gramática-dos-gráficos",
    "href": "04-visualizacao.html#gramática-dos-gráficos",
    "title": "4  Visualização de dados",
    "section": "4.1 Gramática dos Gráficos",
    "text": "4.1 Gramática dos Gráficos\nEle é baseado na gramática dos gráficos (grammar of graphics - GG), veja Wilkinson (2012). A gramática dos gráficos é um conjunto de princípios e conceitos que descrevem a estrutura e as regras para criar gráficos de forma consistente e eficaz. A GG é um framework para visualização de dados que desmembra cada componente de um gráfico em elementos individuais, criando camadas distintas. Usando o sistema GG, podemos construir gráficos passo a passo para obter resultados flexíveis e personalizáveis. Cada aspecto do gráfico, como pontos, linhas, cores e escalas, é tratado como uma peça separada, permitindo um controle detalhado sobre a aparência e o conteúdo do gráfico final.\n\n\n\nFigura de Wilkinson (2012)."
  },
  {
    "objectID": "04-visualizacao.html#o-pacote-ggplot",
    "href": "04-visualizacao.html#o-pacote-ggplot",
    "title": "4  Visualização de dados",
    "section": "4.2 O pacote ggplot",
    "text": "4.2 O pacote ggplot\nO pacote mais conhecido de visualização de dados em R é o ggplot2, que é baseado na gramática dos gráficos. O ggplot2 permite criar uma ampla variedade de gráficos, incluindo gráficos de dispersão, linhas, barras, histogramas, entre outros, de forma simples e flexível. Com o ggplot2, você pode personalizar praticamente todos os aspectos do gráfico, desde a forma e a cor dos pontos até a escala dos eixos e a aparência do plano de fundo.\nPara exemplificar o uso do ggplot, vamos considerar os dados gapminder, Rosling (2012).\n\n4.2.1 Dados\nA função ggplot() inicializa um gráfico ggplot2 e define os dados que serão usados.\n\nlibrary(tidyverse)\nlibrary(gapminder)\n\ngapminder_2007 &lt;- gapminder %&gt;% \n  filter(year == 2007)\n\nggplot(data = gapminder_2007)\n\n\n\n\n\n\n\n\n\n\nO gráfico gerado também não está errado!\n\n\n\nEsse código cria um gráfico utilizando os dados do gapminder apenas para o ano de 2007. Apenas isso. Não há instruções extras sobre o que exibir em cada eixo (estética do gráfico).\n\n\n\n\n4.2.2 Estética\nO mapeamento estético (aes) no ggplot2 é uma função que permite vincular variáveis de um conjunto de dados às propriedades visuais de um gráfico, como cor, forma, tamanho e posição. Por meio do mapeamento estético, podemos controlar como os dados são representados visualmente no gráfico.\nPor exemplo, ao criar um gráfico de dispersão, podemos mapear a variável x (horizontal) e a variável y (vertical) do conjunto de dados às coordenadas do gráfico.\n\nggplot(data = gapminder_2007, \n       mapping = aes(x = gdpPercap, y = lifeExp))\n\n\n\n\n\n\n\n\n\n\nO gráfico gerado também não está errado!\n\n\n\nEsse código define um gráfico de dispersão utilizando os dados do gapminder apenas para o ano de 2007. O eixo x representa o PIB per capita (gdpPercap) e o eixo y representa a expectativa de vida (lifeExp). Apenas isso. Não há instruções extra no techo de código sobre o fomato (geometria) que deve ser usado para exibir os dados.\n\n\n\n\n4.2.3 Geometria\nA geometria refere-se aos elementos visuais que compõem um gráfico, como pontos, linhas, barras e áreas. Cada tipo de gráfico tem sua própria geometria correspondente, e é especificada pela função geom_*, seguida pelo tipo de geometria desejado.\nPor exemplo, para criar um gráfico de dispersão, usamos a geometria geom_point(), enquanto para criar um gráfico de barras, usamos a geometria geom_bar().\n\nggplot(data = gapminder_2007, \n       mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point()\n\n\n\n\nCada geometria tem seus próprios parâmetros específicos que podem ser ajustados para personalizar a aparência do gráfico, como cor, tamanho, preenchimento e transparência.\n\n\n\n\n\n\nAdicionando uma estética de cores no gráfico\n\n\n\nVeja que para colorir cada ponto do gráfico de dispersão de acordo com o continente, basta adicionar no mapeamento estético color = continent.\n\nggplot(data = gapminder_2007, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point()\n\n\n\n\n\n\n\n4.2.3.1 Outras geometrias\nAbaixo, mostramos outras possíveis geometrias. Algumas alterações foram feitas na forma como as funções do ggplot são usadas. Propositalmente não foi adicionado texto descritivoos pois essas alterações devem ser fáceis de interpretar.\ngeom_line():\n\n# Filtrar dados para o Brasil\ndados_pais &lt;- gapminder %&gt;%\n  filter(country == \"Brazil\")\n\n# Criar gráfico de linha\nggplot(data = gapminder %&gt;%\n         filter(country == \"Brazil\"), \n       aes(x = year, y = lifeExp)) +\n  geom_line()\n\n\n\n\ngeom_bar():\n\n# Criar gráfico de barras\nggplot(data = gapminder_2007, aes(x = continent, y = gdpPercap)) +\n  geom_bar(stat = \"summary\", fun = \"mean\")\n\n\n\n\ngeom_boxplot():\n\nggplot(data = gapminder_2007, aes(x = continent, y = lifeExp)) +\n  geom_boxplot()\n\n\n\n\ngeom_text():\n\ngapminder_2007 %&gt;% \n  group_by(continent) %&gt;% \n  summarise(mean_lifeExp = mean(lifeExp),\n            mean_gdpPercap = mean(gdpPercap)) %&gt;% \n  ggplot(aes(x = mean_gdpPercap, y = mean_lifeExp, label = continent)) +\n  geom_point() +\n  geom_text(vjust = -0.5, hjust = 0.5)\n\n\n\n\nNote que estamos combinando duas geometrias em um único gráfico (ponto e texto). Os rótulos de texto são adicionados aos pontos usando a geometria geom_text(), com os parâmetros vjust e hjust definindo a posição vertical e horizontal do texto, respectivamente:\n\no parâmetro vjust ajusta o alinhamento vertical do texto em relação ao ponto. Um valor negativo (-0.5, por exemplo) move o texto acima do ponto, enquanto um valor positivo move o texto abaixo do ponto.\no parâmetro hjust ajusta o alinhamento horizontal do texto em relação ao ponto. Um valor de 0.5 centraliza o texto horizontalmente em relação ao ponto.\n\n\n\n\n4.2.4 Facetas\nAs facetas (facet) referem-se à capacidade de dividir um gráfico em múltiplas visualizações com base em uma ou mais variáveis categóricas. Isso permite comparar as relações entre variáveis em diferentes segmentos dos dados.\nAs facetas são adicionadas usando a função facet_wrap() para criar uma matriz de painéis com base em uma variável categórica ou facet_grid() para criar uma grade de painéis com base em duas variáveis categóricas.\nPor exemplo, podemos usar facetas para criar um gráfico de dispersão separado para dois anos distintos, permitindo comparar as relações entre o PIB per capta e a expectativa de vida nesses dois anos.\n\ngapminder_anos &lt;- gapminder %&gt;% \n  filter(year == 1952 | year == 2007)\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  facet_wrap(~year)\n\n\n\n\n\n\n4.2.5 Coordenadas\nAs coordenadas em ggplot2 determinam como os dados são mapeados em um espaço gráfico. Isso inclui a escala dos eixos x e y, bem como qualquer transformação ou ajuste aplicado aos dados. As coordenadas afetam a aparência geral do gráfico, incluindo sua orientação, proporção e escala.\nPara definir limites nos eixos x e y, podemos usar a função coord_cartesian() para controlar quais intervalos de valores são exibidos no gráfico. Isso é útil quando queremos focar em uma parte específica dos dados ou evitar que outliers influenciem a escala dos eixos.\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  facet_wrap(~year) +\n  coord_cartesian(ylim = c(40, 83))\n\n\n\n\nÉ possível aplicar a escala logarítmica aos eixos também. Isso é útil quando os dados têm uma ampla variação de valores e estamos interessados em destacar diferenças em uma ampla gama de valores, como em dados de renda ou PIB. Para fazer isso, basta utilizar a função scale_*_log10():\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  facet_wrap(~year) +\n  scale_x_log10()\n\n\n\n\n\n\n4.2.6 Temas\nOs temas controlam os aspectos visuais dos gráficos, como títulos, legendas, eixos e cores de fundo. Os temas pré-definidos, como theme_bw(), theme_minimal(), theme_classic() etc., oferecem estilos visuais consistentes que podem ser aplicados aos gráficos para obter uma aparência específica.\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  facet_wrap(~year) +\n  scale_x_log10() +\n  theme_bw()\n\n\n\n\n\n\n\n\n\n\nTente também\n\n\n\nApague a última linha do exemplo acima, digite theme_, aperte a tecla tab e experimente os diferentes temas pré-definidos no ggplot.\n\n\nAlém disso, podemos definir praticamente todos os aspectos do gráfico. Por exemplo, para trocar a posição da legenda para baixo, podemos usar a função theme(legend.position = \"bottom\"). Para alterar o tamanho da fonte, podemos usar a função theme(text = element_text(size = 12)). Essas definições podem ser combinadas em uma única chamada da função theme(), veja abaixo.\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  facet_wrap(~year) +\n  scale_x_log10() +\n  theme_bw() +\n  theme(legend.position = \"bottom\", \n        text = element_text(size = 12))\n\n\n\n\n\n\n4.2.7 Personalização e Estilização de Gráficos\nA função labs() é responsável por personalizar rótulos e títulos em gráficos. No exemplo abaixo, renomeamos os eixos x e y e atribuimos um nome mais descritivo para a legenda de cores, que neste caso representa o continente.\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  facet_wrap(~year) +\n  scale_x_log10() +\n  labs(x = \"PIB per capita (log)\", \n       y = \"Expectativa de vida\", \n       color = \"Continente\", \n       title = \"Relação entre PIB per capita e Expectativa de Vida\") +\n  theme_bw() +\n  theme(legend.position = \"bottom\")\n\n\n\n\nO parâmetro alpha controla a opacidade dos elementos geométricos, variando de 0 a 1. Por exemplo, geom_point(alpha = 0.5) torna os pontos semi-transparentes, o que pode ser útil para visualizar sobreposições de dados em um gráfico de dispersão.\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point(alpha = 0.5) +\n  facet_wrap(~year) +\n  scale_x_log10() +\n  labs(x = \"PIB per capita (log)\", \n       y = \"Expectativa de vida\", \n       color = \"Continente\", \n       title = \"Relação entre PIB per capita e Expectativa de Vida\")\n\n\n\n\nPara escolher cores específicas para os níveis de uma variável categórica, podemos utilizar a função scale_color_manual() para atribuir manualmente cores a cada nível da variável.\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point(alpha = 0.5) +\n  facet_wrap(~year) +\n  scale_x_log10() +\n  scale_color_manual(values = c(\"blue\", \"green\", \"orange\", \"purple\", \"red\"))+\n  labs(x = \"PIB per capita (log)\", \n       y = \"Expectativa de vida\", \n       color = \"Continente\", \n       title = \"Relação entre PIB per capita e Expectativa de Vida\")\n\n\n\n\n\n\n\n\n\n\nOutras paletas de cores\n\n\n\nVocê pode usar paletas de cores do pacote RColorBrewer usando a função scale_color_brewer().\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point(alpha = 0.5) +\n  facet_wrap(~year) +\n  scale_x_log10() +\n  scale_color_brewer(palette = \"Set1\")+\n  labs(x = \"PIB per capita (log)\", \n       y = \"Expectativa de vida\", \n       color = \"Continente\", \n       title = \"Relação entre PIB per capita e Expectativa de Vida\")\n\n\n\n\nA vantagem de usar as paletas de cores do RColorBrewer é que elas foram cuidadosamente projetadas para serem perceptualmente distintas e adequadas para representar diferentes grupos ou categorias em gráficos. Isso significa que as cores em uma paleta são mais facilmente distinguíveis umas das outras, mesmo quando impressas em preto e branco ou quando vistas por pessoas com deficiências visuais. Veja todas paletas disponíves aqui"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Wickham, Hadley, Mine Çetinkaya-Rundel, and Garrett Grolemund. 2023.\nR for Data Science. \" O’Reilly Media, Inc.\"."
  },
  {
    "objectID": "04-visualizacao.html#o-pacote-ggthemes",
    "href": "04-visualizacao.html#o-pacote-ggthemes",
    "title": "4  Visualização de dados",
    "section": "4.3 O pacote ggthemes",
    "text": "4.3 O pacote ggthemes\ndocumentação aqui.\n\n\n\n\nRosling, Hans. 2012. “Data - Gapminder.org.” http://www.gapminder.org/data/.\n\n\nWilkinson, Leland. 2012. The Grammar of Graphics. Springer."
  },
  {
    "objectID": "04-visualizacao.html#extra",
    "href": "04-visualizacao.html#extra",
    "title": "4  Visualização de dados",
    "section": "4.3 Extra",
    "text": "4.3 Extra\n\n4.3.1 O pacote patchwork\nO pacote patchwork é usada para combinar múltiplos gráficos ggplot2 em uma única visualização. Ele permite criar layouts flexíveis e complexos, adicionando, organizando e ajustando gráficos individualmente.\n\n# Instalar o pacote patchwork (apenas se ainda não estiver instalado)\ninstall.packages(\"patchwork\")\n\nDepois de carregar o pacote, você pode usar o operador + para combinar gráficos ggplot2 em uma única visualização.\nAqui está um exemplo simples criando dois gráficos separados e, em seguida, são combinados usando o patchwork:\n\nlibrary(patchwork)\n\nplot1 &lt;- ggplot(data = gapminder_2007, \n       mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) +\n  labs(x = \"PIB per capita (log)\", \n       y = \"Expectativa de vida em 2007\", \n       title = \"Relação entre PIB per capita e Expectativa de Vida\") +\n  theme_classic()\n\nplot2 &lt;- ggplot(data = gapminder_2007, \n       mapping = aes(lifeExp)) +\n  geom_histogram() +\n  labs(title = \"Histograma da expectativa de vida\",\n       x = \"Expectativa de Vida em 2007\", \n       y = \"Frequência\") +\n  theme_classic()\n\nplot1 + plot2\n\n\n\n\n\n\n4.3.2 O pacote ggthemes\nO pacote ggthemes é uma extensão do ggplot2 que fornece uma variedade de temas pré-definidos para personalizar a aparência dos gráficos. Veja a documentação aqui.\n\n# Instalar o pacote ggthemes (apenas se ainda não estiver instalado)\ninstall.packages(\"ggthemes\")\n\nDepois de carregar o pacote, você pode aplicar qualquer um dos temas disponíveis aos seus gráficos ggplot2 usando a função theme_*(). No exemplo abaixo, são criadas três versões do mesmo gráfico com temas diferentes. Os operadores + e / foram usados para definir como os gráficos serão exibidos.\n\n# Carregar o pacote ggthemes\nlibrary(ggthemes)\n\nWarning: package 'ggthemes' was built under R version 4.2.3\n\nplot0 &lt;- ggplot(data = gapminder_2007, \n       mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) +\n  labs(x = \"PIB per capita (log)\", \n       y = \"Expectativa de vida em 2007\")\n\nplot1 &lt;- plot0 + theme_economist()\nplot2 &lt;- plot0 + theme_excel()\nplot3 &lt;- plot0 + theme_stata()\n\nplot1 +  (plot2 / plot3)\n\n\n\n\n\n\n\n\nRosling, Hans. 2012. “Data - Gapminder.org.” http://www.gapminder.org/data/.\n\n\nWilkinson, Leland. 2012. The Grammar of Graphics. Springer."
  },
  {
    "objectID": "04-visualizacao.html#pacotes-extras",
    "href": "04-visualizacao.html#pacotes-extras",
    "title": "4  Visualização de dados",
    "section": "4.3 Pacotes extras",
    "text": "4.3 Pacotes extras\nExistem alguns pacotes extras que funcionam como extensões do ggplot2. Apresentamos alguns nessa seção.\n\n4.3.1 O pacote patchwork\nO pacote patchwork é usada para combinar múltiplos gráficos ggplot2 em uma única visualização. Ele permite criar layouts flexíveis e complexos, adicionando, organizando e ajustando gráficos individualmente.\n\n# Instalar o pacote patchwork (apenas se ainda não estiver instalado)\ninstall.packages(\"patchwork\")\n\nDepois de carregar o pacote, você pode usar o operador + para combinar gráficos ggplot2 em uma única visualização.\nAqui está um exemplo simples criando dois gráficos separados e, em seguida, são combinados usando o patchwork:\n\nlibrary(patchwork)\n\nplot1 &lt;- ggplot(data = gapminder_2007, \n       mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) +\n  labs(x = \"PIB per capita (log)\", \n       y = \"Expectativa de vida em 2007\", \n       title = \"Relação entre PIB per capita e Expectativa de Vida\") +\n  theme_classic()\n\nplot2 &lt;- ggplot(data = gapminder_2007, \n       mapping = aes(lifeExp)) +\n  geom_histogram() +\n  labs(title = \"Histograma da expectativa de vida\",\n       x = \"Expectativa de Vida em 2007\", \n       y = \"Frequência\") +\n  theme_classic()\n\nplot1 + plot2\n\n\n\n\n\n\n4.3.2 O pacote ggthemes\nO pacote ggthemes é uma extensão do ggplot2 que fornece uma variedade de temas pré-definidos para personalizar a aparência dos gráficos. Veja a documentação aqui.\n\n# Instalar o pacote ggthemes (apenas se ainda não estiver instalado)\ninstall.packages(\"ggthemes\")\n\nDepois de carregar o pacote, você pode aplicar qualquer um dos temas disponíveis aos seus gráficos ggplot2 usando a função theme_*(). No exemplo abaixo, são criadas três versões do mesmo gráfico com temas diferentes. Os operadores + e / foram usados para definir como os gráficos serão exibidos.\n\n# Carregar o pacote ggthemes\nlibrary(ggthemes)\n\nWarning: package 'ggthemes' was built under R version 4.2.3\n\nplot0 &lt;- ggplot(data = gapminder_2007, \n       mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) +\n  labs(x = \"PIB per capita (log)\", \n       y = \"Expectativa de vida em 2007\")\n\nplot1 &lt;- plot0 + theme_economist()\nplot2 &lt;- plot0 + theme_excel()\nplot3 &lt;- plot0 + theme_stata()\n\nplot1 +  (plot2 / plot3)\n\n\n\n\n\n\n4.3.3 O pacote plotly\nO pacote plotly oferece recursos para criar gráficos interativos. Para adicionar interação ao gráfico fornecido, podemos usar a função ggplotly() para converter um gráfico criado com ggplot2 em um gráfico interativo. Utilize o comando install.packages(\"plotly\") caso não tenha o pacote instalado.\n\nlibrary(plotly)\n\ngrafico &lt;- ggplot(data = gapminder_anos, \n                  mapping = aes(x = gdpPercap, y = lifeExp, \n                                color = continent, text = country)) +\n  geom_point(alpha = 0.5) +\n  facet_wrap(~year) +\n  scale_x_log10() +\n  labs(x = \"PIB per capita (log)\", \n       y = \"Expectativa de vida\", \n       color = \"Continente\", \n       title = \"Relação entre PIB per capita e Expectativa de Vida\")\n\nggplotly(grafico)"
  },
  {
    "objectID": "03-dados.html#exercícios",
    "href": "03-dados.html#exercícios",
    "title": "3  Manipulação de dados",
    "section": "3.3 Exercícios",
    "text": "3.3 Exercícios\n1. Vamos trabalhar com o conjunto de dados billboard. Neste conjunto de dados, cada observação é uma música. As três primeiras colunas (artista, faixa e data de entrada) são variáveis que descrevem a música. Em seguida, temos 76 colunas (wk1-wk76) que descrevem o ranking da música em cada semana. Aqui, os nomes das colunas são uma variável (a semana) e os valores das células são outra (o ranking).\n\nlibrary(tidyverse)\nbillboard\n\n# A tibble: 317 × 79\n   artist     track date.entered   wk1   wk2   wk3   wk4   wk5   wk6   wk7   wk8\n   &lt;chr&gt;      &lt;chr&gt; &lt;date&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 2 Pac      Baby… 2000-02-26      87    82    72    77    87    94    99    NA\n 2 2Ge+her    The … 2000-09-02      91    87    92    NA    NA    NA    NA    NA\n 3 3 Doors D… Kryp… 2000-04-08      81    70    68    67    66    57    54    53\n 4 3 Doors D… Loser 2000-10-21      76    76    72    69    67    65    55    59\n 5 504 Boyz   Wobb… 2000-04-15      57    34    25    17    17    31    36    49\n 6 98^0       Give… 2000-08-19      51    39    34    26    26    19     2     2\n 7 A*Teens    Danc… 2000-07-08      97    97    96    95   100    NA    NA    NA\n 8 Aaliyah    I Do… 2000-01-29      84    62    51    41    38    35    35    38\n 9 Aaliyah    Try … 2000-03-18      59    53    38    28    21    18    16    14\n10 Adams, Yo… Open… 2000-08-26      76    76    74    69    68    67    61    58\n# ℹ 307 more rows\n# ℹ 68 more variables: wk9 &lt;dbl&gt;, wk10 &lt;dbl&gt;, wk11 &lt;dbl&gt;, wk12 &lt;dbl&gt;,\n#   wk13 &lt;dbl&gt;, wk14 &lt;dbl&gt;, wk15 &lt;dbl&gt;, wk16 &lt;dbl&gt;, wk17 &lt;dbl&gt;, wk18 &lt;dbl&gt;,\n#   wk19 &lt;dbl&gt;, wk20 &lt;dbl&gt;, wk21 &lt;dbl&gt;, wk22 &lt;dbl&gt;, wk23 &lt;dbl&gt;, wk24 &lt;dbl&gt;,\n#   wk25 &lt;dbl&gt;, wk26 &lt;dbl&gt;, wk27 &lt;dbl&gt;, wk28 &lt;dbl&gt;, wk29 &lt;dbl&gt;, wk30 &lt;dbl&gt;,\n#   wk31 &lt;dbl&gt;, wk32 &lt;dbl&gt;, wk33 &lt;dbl&gt;, wk34 &lt;dbl&gt;, wk35 &lt;dbl&gt;, wk36 &lt;dbl&gt;,\n#   wk37 &lt;dbl&gt;, wk38 &lt;dbl&gt;, wk39 &lt;dbl&gt;, wk40 &lt;dbl&gt;, wk41 &lt;dbl&gt;, wk42 &lt;dbl&gt;, …\n\n\na) Aplique uma tranformação na base de dados para deixá-la no formato abaixo.\n\n\n# A tibble: 24,092 × 5\n   artist track                   date.entered week   rank\n   &lt;chr&gt;  &lt;chr&gt;                   &lt;date&gt;       &lt;chr&gt; &lt;dbl&gt;\n 1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk1      87\n 2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk2      82\n 3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk3      72\n 4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk4      77\n 5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk5      87\n 6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk6      94\n 7 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk7      99\n 8 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk8      NA\n 9 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk9      NA\n10 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk10     NA\n# ℹ 24,082 more rows\n\n\nb) Observe o resultado do item a). O que acontece se uma música estiver no top 100 por menos de 76 semanas? Pegue a música “Baby Don’t Cry” de 2 Pac, por exemplo. A saída acima sugere que ela esteve no top 100 por apenas 7 semanas, e todas as semanas restantes são preenchidas com valores ausentes (NA). Esses NAs na verdade não representam observações desconhecidas; eles foram forçados a existir pela estrutura do conjunto de dados. Altere o código usado em a) para remover esses NAs. Responda: Quantas linhas sobraram? (Dica: veja a documentação da função pivot_longer.)\nc) Você deve ter percebido que no resultado do item a), o tipo da coluna week é caractere. Faça a transformação adequada para obter uma coluna com valores numéricos.\nd) Qual música ficou por mais semanas no top 100 da Billboard em 2000? Por quantas semanas essa música apareceu no ranking? E qual música ficou por menos tempo no ranking.\ne) Qual música ficou exatamente 10 semanas no top 100 da Billboard em 2000? Caso exista mais de uma música nessa condição, considere a que primeiro entrou no ranking.\n\n\n\n\nRosling, Hans. 2012. “Data - Gapminder.org.” http://www.gapminder.org/data/."
  },
  {
    "objectID": "03-dados.html#sec-ex-dados",
    "href": "03-dados.html#sec-ex-dados",
    "title": "3  Manipulação de dados",
    "section": "3.3 Exercícios",
    "text": "3.3 Exercícios\nVamos trabalhar com o conjunto de dados billboard. Neste conjunto de dados, cada observação é uma música. As três primeiras colunas (artista, faixa e data de entrada) são variáveis que descrevem a música. Em seguida, temos 76 colunas (wk1-wk76) que descrevem o ranking da música em cada semana. Aqui, os nomes das colunas são uma variável (a semana) e os valores das células são outra (o ranking).\n\nlibrary(tidyverse)\nbillboard\n\n# A tibble: 317 × 79\n   artist     track date.entered   wk1   wk2   wk3   wk4   wk5   wk6   wk7   wk8\n   &lt;chr&gt;      &lt;chr&gt; &lt;date&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 2 Pac      Baby… 2000-02-26      87    82    72    77    87    94    99    NA\n 2 2Ge+her    The … 2000-09-02      91    87    92    NA    NA    NA    NA    NA\n 3 3 Doors D… Kryp… 2000-04-08      81    70    68    67    66    57    54    53\n 4 3 Doors D… Loser 2000-10-21      76    76    72    69    67    65    55    59\n 5 504 Boyz   Wobb… 2000-04-15      57    34    25    17    17    31    36    49\n 6 98^0       Give… 2000-08-19      51    39    34    26    26    19     2     2\n 7 A*Teens    Danc… 2000-07-08      97    97    96    95   100    NA    NA    NA\n 8 Aaliyah    I Do… 2000-01-29      84    62    51    41    38    35    35    38\n 9 Aaliyah    Try … 2000-03-18      59    53    38    28    21    18    16    14\n10 Adams, Yo… Open… 2000-08-26      76    76    74    69    68    67    61    58\n# ℹ 307 more rows\n# ℹ 68 more variables: wk9 &lt;dbl&gt;, wk10 &lt;dbl&gt;, wk11 &lt;dbl&gt;, wk12 &lt;dbl&gt;,\n#   wk13 &lt;dbl&gt;, wk14 &lt;dbl&gt;, wk15 &lt;dbl&gt;, wk16 &lt;dbl&gt;, wk17 &lt;dbl&gt;, wk18 &lt;dbl&gt;,\n#   wk19 &lt;dbl&gt;, wk20 &lt;dbl&gt;, wk21 &lt;dbl&gt;, wk22 &lt;dbl&gt;, wk23 &lt;dbl&gt;, wk24 &lt;dbl&gt;,\n#   wk25 &lt;dbl&gt;, wk26 &lt;dbl&gt;, wk27 &lt;dbl&gt;, wk28 &lt;dbl&gt;, wk29 &lt;dbl&gt;, wk30 &lt;dbl&gt;,\n#   wk31 &lt;dbl&gt;, wk32 &lt;dbl&gt;, wk33 &lt;dbl&gt;, wk34 &lt;dbl&gt;, wk35 &lt;dbl&gt;, wk36 &lt;dbl&gt;,\n#   wk37 &lt;dbl&gt;, wk38 &lt;dbl&gt;, wk39 &lt;dbl&gt;, wk40 &lt;dbl&gt;, wk41 &lt;dbl&gt;, wk42 &lt;dbl&gt;, …\n\n\na) Aplique uma tranformação na base de dados para deixá-la no formato abaixo.\n\n\n# A tibble: 24,092 × 5\n   artist track                   date.entered week   rank\n   &lt;chr&gt;  &lt;chr&gt;                   &lt;date&gt;       &lt;chr&gt; &lt;dbl&gt;\n 1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk1      87\n 2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk2      82\n 3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk3      72\n 4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk4      77\n 5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk5      87\n 6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk6      94\n 7 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk7      99\n 8 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk8      NA\n 9 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk9      NA\n10 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk10     NA\n# ℹ 24,082 more rows\n\n\nb) Observe o resultado do item a). O que acontece se uma música estiver no top 100 por menos de 76 semanas? Pegue a música “Baby Don’t Cry” de 2 Pac, por exemplo. A saída acima sugere que ela esteve no top 100 por apenas 7 semanas, e todas as semanas restantes são preenchidas com valores ausentes (NA). Esses NAs na verdade não representam observações desconhecidas; eles foram forçados a existir pela estrutura do conjunto de dados. Altere o código usado em a) para remover esses NAs. Responda: Quantas linhas sobraram? (Dica: veja a documentação da função pivot_longer.)\nc) Você deve ter percebido que no resultado do item a), o tipo da coluna week é caractere. Faça a transformação adequada para obter uma coluna com valores numéricos.\nd) Qual música ficou por mais semanas no top 100 da Billboard em 2000? Por quantas semanas essa música apareceu no ranking? E qual música ficou por menos tempo no ranking.\ne) Qual música ficou exatamente 10 semanas no top 100 da Billboard em 2000? Caso exista mais de uma música nessa condição, considere a que primeiro entrou no ranking.\n\n\n\n\nRosling, Hans. 2012. “Data - Gapminder.org.” http://www.gapminder.org/data/."
  },
  {
    "objectID": "04-visualizacao.html#dicas-extras",
    "href": "04-visualizacao.html#dicas-extras",
    "title": "4  Visualização de dados",
    "section": "4.4 Dicas extras",
    "text": "4.4 Dicas extras\nQuando você estiver explorando diferentes tipos de gráficos para visualizar seus dados, o site Data to Viz pode ser uma ferramenta valiosa. Ele fornece uma galeria completa de tipos de gráficos e oferece orientações sobre quando e como usar cada um deles. Além disso, o site oferece exemplos específicos de como criar esses gráficos usando diferentes bibliotecas, como ggplot2 em R e matplotlib em Python."
  },
  {
    "objectID": "04-visualizacao.html#exercícios",
    "href": "04-visualizacao.html#exercícios",
    "title": "4  Visualização de dados",
    "section": "4.5 Exercícios",
    "text": "4.5 Exercícios\nVamos utilizar os dados da Billboard que foram apresentados na Section 3.3. Sua tarefa é reproduzir os gráficos abaixo utilizando técnicas de processamento de dados com dplyr e visualização de dados com ggplot.\na) O gráfico abaixo mostra o histórico de cada musica no ranking ao longo das semanas.\n\n\n\n\n\nb) O gráfico abaixo é uma pequena alteração do apresentado no item a), no eixo x é apresentada a data que a música entrou no ranking.\n\n\n\n\n\nc) O gráfico abaixo mostra o histórico de duas músicas no ranking: “Higher” e “With Arms Wide Open”.\n\n\n\n\n\n\n\n\n\nRosling, Hans. 2012. “Data - Gapminder.org.” http://www.gapminder.org/data/.\n\n\nWilkinson, Leland. 2012. The Grammar of Graphics. Springer."
  },
  {
    "objectID": "05-fundamentos_python.html#tipos-de-dados-fundamentais-integer-float-string-boolean",
    "href": "05-fundamentos_python.html#tipos-de-dados-fundamentais-integer-float-string-boolean",
    "title": "5  Fundamentos de Python",
    "section": "5.1 Tipos de dados fundamentais: integer, float, string, boolean",
    "text": "5.1 Tipos de dados fundamentais: integer, float, string, boolean"
  },
  {
    "objectID": "05-fundamentos_python.html#objetos-básicos",
    "href": "05-fundamentos_python.html#objetos-básicos",
    "title": "5  Fundamentos de Python",
    "section": "5.2 Objetos básicos",
    "text": "5.2 Objetos básicos\n\n5.2.1 listas\n\n\n5.2.2 tuplas\n\n\n5.2.3 dicionarios"
  },
  {
    "objectID": "05-fundamentos_python.html#condicionais",
    "href": "05-fundamentos_python.html#condicionais",
    "title": "5  Fundamentos de Python",
    "section": "5.3 Condicionais",
    "text": "5.3 Condicionais"
  },
  {
    "objectID": "05-fundamentos_python.html#estruturas-repetitivas",
    "href": "05-fundamentos_python.html#estruturas-repetitivas",
    "title": "5  Fundamentos de Python",
    "section": "5.4 Estruturas repetitivas",
    "text": "5.4 Estruturas repetitivas"
  },
  {
    "objectID": "05-fundamentos_python.html#comprehensions",
    "href": "05-fundamentos_python.html#comprehensions",
    "title": "5  Fundamentos de Python",
    "section": "5.5 Comprehensions",
    "text": "5.5 Comprehensions"
  },
  {
    "objectID": "05-fundamentos_python.html#funções",
    "href": "05-fundamentos_python.html#funções",
    "title": "5  Fundamentos de Python",
    "section": "5.6 Funções",
    "text": "5.6 Funções"
  },
  {
    "objectID": "05-fundamentos_python.html#classes-e-objetos",
    "href": "05-fundamentos_python.html#classes-e-objetos",
    "title": "5  Fundamentos de Python",
    "section": "5.7 Classes e objetos",
    "text": "5.7 Classes e objetos"
  },
  {
    "objectID": "05-fundamentos_python.html#numpy",
    "href": "05-fundamentos_python.html#numpy",
    "title": "5  Fundamentos de Python",
    "section": "5.8 Numpy",
    "text": "5.8 Numpy"
  },
  {
    "objectID": "05-fundamentos_python.html#pandas",
    "href": "05-fundamentos_python.html#pandas",
    "title": "5  Fundamentos de Python",
    "section": "5.9 Pandas",
    "text": "5.9 Pandas"
  },
  {
    "objectID": "06-visualizacao_python.html",
    "href": "06-visualizacao_python.html",
    "title": "6  Visualização de dados",
    "section": "",
    "text": "Important\n\n\n\nPágina ainda em construção!"
  }
]