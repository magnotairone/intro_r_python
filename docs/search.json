[
  {
    "objectID": "01-fundamentos_r.html#rstudio",
    "href": "01-fundamentos_r.html#rstudio",
    "title": "1  Fundamentos de R",
    "section": "1.1 RStudio",
    "text": "1.1 RStudio\nPara instalação, faça o download do R em http://www.r-project.org. Em seguida, instale a IDE (Integrated Development Environment) R Studio.\nAo abrir o RStudio, clique no menu File/ New File/ R Script (ou Ctrl+Shift+N). Você deve ver uma estrutura como a mostrada na figura abaixo.\n\n\n\nInterface do Rstudio\n\n\nNote que são quatro paineis:\n\nPainel de Scripts (superior esquerdo): este painel é onde você pode escrever, editar e executar scripts R. Ele fornece recursos como destaque de sintaxe, autocompletar e verificação de código para ajudar na escrita de código.\nPainel de Console (inferior esquerdo):o console é onde o código R é executado e os resultados são exibidos. Você pode inserir comandos diretamente aqui e ver imediatamente os resultados. Ele também mantém um histórico de comandos executados, o que pode ser útil para referência futura.\nAmbiente/Workspace (superior direito): este painel exibe informações sobre os objetos (como variáveis, funções, etc.) atualmente carregados na memória do R. Ele mostra detalhes como o nome do objeto, tipo de objeto e seu valor atual. Isso é útil para monitorar e gerenciar objetos durante uma sessão de trabalho.\nArquivos/Plots/Pacotes/Ajuda (inferior direito): um painel com diversas funcionalidades.\n\nArquivos: Esta guia permite navegar e gerenciar os arquivos do seu projeto. Você pode criar, renomear, excluir e organizar arquivos e pastas diretamente dentro do RStudio.\nGráficos (Plots): Aqui são exibidos os gráficos gerados pelo R. Quando você cria um gráfico usando funções de visualização em R, o resultado é exibido nesta guia. Isso facilita a análise visual dos seus dados e a inspeção dos gráficos durante o processo de criação.\nPacotes: Nesta guia, você pode visualizar e gerenciar os pacotes instalados no seu ambiente R. Ela exibe uma lista de todos os pacotes instalados, juntamente com sua versão e status (carregado ou não). Além disso, você pode instalar novos pacotes, atualizar pacotes existentes e carregar ou descarregar pacotes conforme necessário para o seu trabalho.\nAjuda (Help): Esta guia fornece acesso rápido à documentação e às informações de ajuda sobre funções, pacotes e outros recursos do R. Você pode pesquisar por tópicos específicos e acessar a documentação oficial diretamente no RStudio. Isso é útil para obter informações sobre a sintaxe de uma função, exemplos de uso e detalhes sobre os parâmetros disponíveis."
  },
  {
    "objectID": "01-fundamentos_r.html#sec-tipodedados",
    "href": "01-fundamentos_r.html#sec-tipodedados",
    "title": "1  Fundamentos de R",
    "section": "1.2 Tipos de dados",
    "text": "1.2 Tipos de dados\nSempre que estiver aprendendo uma nova linguagem, procure primeiro saber quais são os tipos de dados básicos que podem ser representandos nessa linguagem.\nEm R, são quatro os tipos básicos de dados disponíveis: numéricos, lógicos, caracteres e fatores.\n\n1.2.1 O tipo de dado numérico\nOs dados numéricos (numeric) são usados para expressar valores quantitativos, como preços, taxas e quantidades, sendo representados por números inteiros ou decimais.\n\n# Número inteiro representando quantidade de acoes em uma carteira\nqtd_acoes &lt;- 100\n\n# Número de ponto flutuante representando a taxa de inflação\ntaxa_inflacao &lt;- 3.5\n\n# Verificando a classe de taxa_inflacao\nclass(taxa_inflacao)\n\n[1] \"numeric\"\n\n\nA função class() é usada para determinar a classe de uma variável. Em outras palavras, ela fornece informações sobre o tipo de dado que uma variável representa. Nesse caso acima, a variável taxa_inflacao é da classe numeric.\n\n\n1.2.2 O tipo de dado lógico\nOs dados lógicos (logical) são empregados para representar estados ou condições, como verdadeiro ou falso, sendo úteis em operações de lógica e comparação.\n\n# Verificando se a taxa de juros está aumentando\ntaxa_juros_aumentando &lt;- TRUE\n\n# Verificando se o preço das ações está caindo\nqueda_preco_acoes &lt;- FALSE\n\n# Verificando a classe de queda_preco_acoes\nclass(queda_preco_acoes)\n\n[1] \"logical\"\n\n\n\n\n1.2.3 O tipo de dado caractere\nJá os dados do tipo caractere (character) são utilizados para representar texto, como nomes de países, empresas ou categorias, sendo essenciais em análises descritivas e comunicação de resultados.\n\n# Nome de um país\npais &lt;- \"Brasil\"\n\n# Nome de uma empresa multinacional\nempresa &lt;- \"Petróleo Brasileiro S.A.\"\n\n# Verificando a classe de pais\nclass(pais)\n\n[1] \"character\"\n\n\n\n\n1.2.4 O tipo de dado fator\nOs fatores (factor) são empregados para representar variáveis categóricas, como classificações, categorias ou grupos, uma forma eficiente de lidar com dados discretos e qualitativos.\n\n# Classificação do risco de crédito de uma empresa\nrisco_credito &lt;- factor(c(\"Baixo\", \"Médio\", \"Alto\", \"Baixo\", \"Alto\"))\n\n# Verificando a classe de risco_credito\nclass(risco_credito)\n\n[1] \"factor\"\n\n\nA função levels() retorna os níveis (ou categorias) de um fator. Isso é útil para entender quais são as categorias representadas pelo fator e para realizar operações de manipulação de dados com base nessas categorias.\n\n# Exibindo os níveis de risco de crédito\nlevels(risco_credito)\n\n[1] \"Alto\"  \"Baixo\" \"Médio\""
  },
  {
    "objectID": "01-fundamentos_r.html#fundamentos-da-linguagem",
    "href": "01-fundamentos_r.html#fundamentos-da-linguagem",
    "title": "1  Fundamentos de R",
    "section": "1.3 Fundamentos da linguagem",
    "text": "1.3 Fundamentos da linguagem\nO ambiente R refere-se ao espaço de trabalho onde todas as variáveis, funções e objetos criados durante uma sessão R são armazenados e manipulados. O ambiente inclui tanto os objetos que você criou quanto os que são carregados automaticamente por meio de pacotes ou outros mecanismos de importação de dados (mais sobre pacotes a seguir).\nPor exemplo, ao usar a função ls() (que lista os nomes dos objetos no ambiente atual), podemos ver todos os objetos atualmente presentes no ambiente R.\n\n\nls()\n\nSe você executou corretamente todos os comandos da Seção Section 1.2, deve obter como resultado no console o seguinte:\n[1] \"empresa\"               \"pais\"                  \"qtd_acoes\"\n[4] \"queda_preco_acoes\"     \"taxa_inflacao\"         \"taxa_juros_aumentando\"\nusando R como calculadora numeros especiais"
  },
  {
    "objectID": "01-fundamentos_r.html#variáveis",
    "href": "01-fundamentos_r.html#variáveis",
    "title": "1  Fundamentos de R",
    "section": "1.4 Variáveis",
    "text": "1.4 Variáveis\nNa Section 1.2 algumas variáveis foram criadas. Por exemplo a variável empresa que armazena uma cadeia de caracteres. Você viu, anteriormente a maneira de listar todas as variáveis definidas no seu ambiente. Mas, afinal, o que são variáveis?\nNo R, variáveis são elementos fundamentais usados para armazenar e manipular dados. Elas são como recipientes que guardam valores, objetos ou expressões. Quando você atribui um valor a uma variável, está basicamente dando um nome a esse valor para poder acessá-lo e manipulá-lo posteriormente.\nPor exemplo, ao escrever preco_acao &lt;- 10, você está criando uma variável chamada preco_acao e atribuindo a ela o valor 10. Agora, sempre que você usar preco_acao em seu código, estará se referindo a esse valor.\nUma prática comum escolher nomes descritivos para variáveis que ajudem a entender seu propósito ou conteúdo. Por exemplo, em um contexto econômico, você pode usar preco_acao para representar o preço de uma ação ou taxa_inflacao para representar a taxa de inflação.\nPara atribuir um valor a uma variável, use o operador &lt;-. O operador = também pode ser usado para atribuir valores a variáveis. Ambos os operadores têm o mesmo efeito prático na atribuição de valores a variáveis em R. A escolha entre eles geralmente se resume à preferência pessoal e ao estilo de codificação, embora alguns guias de estilo de código sugiram o uso do &lt;-."
  },
  {
    "objectID": "01-fundamentos_r.html#verificando-o-tipo-de-uma-variável",
    "href": "01-fundamentos_r.html#verificando-o-tipo-de-uma-variável",
    "title": "1  Fundamentos de R",
    "section": "1.5 Verificando o tipo de uma variável",
    "text": "1.5 Verificando o tipo de uma variável\nVamos usar as funções da família is.* para vericar os tipos de algumas das variáveis que estão no nosso ambiente de trabalho.\n\nPara a variável empresa:\n\n\nis.character(empresa)\n\nIsso retornará TRUE se a variável empresa for do tipo caractere (character).\n\nPara a variável pais:\n\n\nis.character(pais)\n\nAssim como para a variável empresa, isso retornará TRUE se a variável pais for do tipo caractere.\n\nPara a variável qtd_acoes:\n\n\nis.numeric(qtd_acoes)\n\nIsso retornará TRUE se a variável qtd_acoes for do tipo numérico (numeric).\n\nPara a variável queda_preco_acoes:\n\n\nis.logical(queda_preco_acoes)\n\nIsso retornará TRUE se a variável queda_preco_acoes for do tipo lógico (logical).\n\nPara a variável taxa_inflacao:\n\n\nis.numeric(taxa_inflacao)\n\nAssim como para a variável qtd_acoes, isso retornará TRUE se a variável taxa_inflacao for do tipo numérico.\n\nPara a variável taxa_juros_aumentando:\n\n\nis.logical(taxa_juros_aumentando)\n\nIsso retornará TRUE se a variável taxa_juros_aumentando for do tipo lógico.\nEsses exemplos ilustram como você pode usar as funções is.* para verificar o tipo de variáveis, ajudando a garantir que você esteja manipulando os dados corretamente em suas análises.\nOutra família de funções importantes é a das funções as.*. Elas são usadas para converter um objeto de um tipo para outro. Elas permitem que você altere o tipo de dado de uma variável, o que pode ser útil em várias situações, como quando você precisa realizar operações específicas que exigem um determinado tipo de dado ou quando deseja garantir a consistência dos tipos de dados em seu código.\nAlgumas das funções as.* mais comuns incluem:\n\nas.character(): Converte um objeto para o tipo caractere (character).\n\n\nnumero &lt;- 123\nnumero_caractere &lt;- as.character(numero)\n\n\nas.numeric(): Converte um objeto para o tipo numérico (numeric).\n\n\ntexto &lt;- \"3.14\"\nnumero &lt;- as.numeric(texto)\n\n\nas.logical():\n\n\nnumero &lt;- 0\nlogico &lt;- as.logical(numero)\n\nEssas funções são úteis para garantir que os tipos de dados estejam corretos em seu código e para garantir que você possa realizar as operações desejadas em seus objetos. No entanto, é importante observar que nem todas as conversões podem ser bem-sucedidas, especialmente quando há perda de informações (por exemplo, ao converter de caractere para numérico). Portanto, é sempre uma boa prática verificar se a conversão foi feita corretamente e se os dados resultantes são os esperados.\nVeja um exemplo de conversão de caractere para numérico com texto não numérico:\n\ntexto &lt;- \"abc\"\nnumero &lt;- as.numeric(texto)\n\nWarning: NAs introduzidos por coerção\n\n\nNeste exemplo, a tentativa de converter o texto “abc” para um número resultará em um valor NA (Not Available), indicando que a conversão falhou. Veja que a saída do console indica uma mensagem de warning."
  },
  {
    "objectID": "01-fundamentos_r.html#estruturas-de-dados",
    "href": "01-fundamentos_r.html#estruturas-de-dados",
    "title": "1  Fundamentos de R",
    "section": "1.6 Estruturas de dados",
    "text": "1.6 Estruturas de dados\nEm toda análises de dados, é comum lidar com conjuntos de dados que possuem diferentes estruturas e formatos. Vamos explorar quatro estruturas de dados fundamentais em R: vetor, matriz, lista e DataFrame.\n\n1.6.1 Vetores\nUm vetor em R é uma estrutura de dados unidimensional que armazena uma sequência ordenada de elementos do mesmo tipo. A função c nos ajuda a criar vetores.\n\n# Vetor de preços de ações\nprecos_acoes &lt;- c(100, 110, 105, 120, 115)\n\nEm alguns casos, é de interesse definir sequências de números usando os operadores : e a função seq().\n\n# Vetor de números de 1 a 10\nsequencia &lt;- 1:10\nsequencia\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\n# Vetor de números de 1 a 10 com incremento de 2\nsequencia_incremento &lt;- seq(from = 1, to = 10, by = 2)\nsequencia_incremento\n\n[1] 1 3 5 7 9\n\n\nPara verificar o tamanho de um vetor, você pode usar a função length().\n\n# Verificando o tamanho do vetor de preços de ações\nlength(precos_acoes)\n\n[1] 5\n\nlength(1:10)\n\n[1] 10\n\n\nPara acessar elementos em um vetor em R, você pode usar índices numéricos ou lógicos dentro dos colchetes [ ].\nVocê pode acessar elementos usando índices numéricos dentro dos colchetes [ ]. Por exemplo, vetor[i] acessa o elemento na posição i do vetor.\n\n# Vetor de preços de ações\nprecos_acoes &lt;- c(100, 110, 105, 120, 115)\n\n# Acessando o segundo elemento do vetor\nsegundo_elemento &lt;- precos_acoes[2]\n\n# Acessando uma série de elementos do vetor\nvarios_elementos &lt;- precos_acoes[3:5]\n\nVocê também pode acessar elementos usando índices lógicos dentro dos colchetes [ ]. Por exemplo, vetor[indices_logicos] retorna os elementos do vetor onde os índices lógicos são TRUE.\n\n# Acessando preços de ações maiores que 110\nprecos_maior_que_110 &lt;- precos_acoes[precos_acoes &gt; 110]\n\n\n\n1.6.2 Matrizes\nUma matriz em R é uma estrutura de dados bidimensional que consiste em linhas e colunas de elementos do mesmo tipo. É útil para representar conjuntos de dados tabulares, como dados de séries temporais ou matrizes de covariância.\n\n# Matriz de retornos de ativos\nretornos_ativos &lt;- matrix(c(0.05, 0.03, 0.02, 0.04, 0.06, 0.03), \n                          nrow = 2, byrow = TRUE)\nrownames(retornos_ativos) &lt;- c(\"Ação 1\", \"Ação 2\")\ncolnames(retornos_ativos) &lt;- c(\"Ano 1\", \"Ano 2\", \"Ano 3\")\n\nO código acima cria uma matriz chamada retornos_ativos que armazena os retornos de dois ativos ao longo de três anos.\nA função matrix() é usada para criar a matriz. O vetor c(0.05, 0.03, 0.02, 0.04, 0.06, 0.03) contém os valores dos retornos dos ativos, fornecidos em ordem de preenchimento de coluna (de cima para baixo). Os parâmetros nrow = 2 e byrow = TRUE indicam que a matriz deve ter 2 linhas (para representar os dois ativos) e que os valores devem ser preenchidos por linha (ou seja, primeiro os retornos para o ano 1, depois para o ano 2 e assim por diante). As funções rownames() e colnames() são usadas para atribuir nomes às linhas e colunas da matriz, respectivamente. No caso das linhas, são atribuídos os nomes “Ação 1” e “Ação 2”, representando os dois ativos. Para as colunas, são atribuídos os nomes “Ano 1”, “Ano 2” e “Ano 3”, representando os anos em que os retornos foram registrados.\nA função class() retorna a classe do objeto, que neste caso será “matrix”, indicando que retornos_ativos é uma matriz em R.\nA função dim() retorna as dimensões da matriz, ou seja, o número de linhas e colunas.\n\n# Verificando as dimensões da matriz\ndim(retornos_ativos)\n\n[1] 2 3\n\n\nNeste caso, o resultado será [2, 3], indicando que a matriz possui 2 linhas e 3 colunas.\nAs funções nrow() e ncol() retornam o número de linhas e colunas da matriz, respectivamente.\n\nc(nrow(retornos_ativos), ncol(retornos_ativos))\n\n[1] 2 3\n\n\nA função length() retorna o número total de elementos em um objeto. Para uma matriz, isso retornará o número total de elementos, ou seja, o produto do número de linhas pelo número de colunas.\n\nlength(retornos_ativos)\n\n[1] 6\n\n\nPara acessar linhas, colunas e elementos em uma matriz em R, você pode usar índices numéricos ou nomes (se definidos). Aqui está como fazer:\n\nAcessando Linhas e Colunas: Você pode acessar linhas e colunas usando índices numéricos dentro dos colchetes [ ]. Por exemplo, matriz[i, ] acessa a linha i e matriz[, j] acessa a coluna j. Para acessar uma célula específica, você usa matriz[i, j], onde i é o número da linha e j é o número da coluna.\n\n\n# Acessando a primeira linha da matriz\nprimeira_linha &lt;- retornos_ativos[1, ]\n\n# Acessando a segunda coluna da matriz\nsegunda_coluna &lt;- retornos_ativos[, 2]\n\n# Acessando o elemento na segunda linha e terceira coluna da matriz\nelemento &lt;- retornos_ativos[2, 3]\n\n\nAcessando Linhas e Colunas por Nomes: Se você definiu nomes para as linhas e/ou colunas da matriz, você pode acessá-las usando esses nomes.\n\n\n# Acessando a linha chamada \"Ação 1\"\nacao1 &lt;- retornos_ativos[\"Ação 1\", ]\n\n# Acessando a coluna chamada \"Ano 2\"\nano2 &lt;- retornos_ativos[, \"Ano 2\"]\n\n# Acessando o elemento na linha \"Ação 2\" e coluna \"Ano 3\"\nelemento2 &lt;- retornos_ativos[\"Ação 2\", \"Ano 3\"]\n\nEm R, diferente de outras linguagens de programação, os índices de linhas e colunas em matrizes (e também em vetores, listas, etc.) começam em 1 e não em 0. Isso significa que o primeiro elemento de uma matriz está no índice 1, o segundo no índice 2, e assim por diante\n\n\n1.6.3 Listas\nEm R, uma lista é uma estrutura de dados flexível que pode conter elementos de diferentes tipos, como vetores, matrizes, outras listas e até mesmo funções. As listas são úteis quando você precisa armazenar e manipular conjuntos de dados heterogêneos ou estruturas complexas.\nPodemos criar uma lista que armazena informações sobre um país, como seu nome, PIB, taxa de inflação e uma série temporal de valores de câmbio.\n\n# Criando uma lista com informações sobre um país\npais_info &lt;- list(\n  nome = \"Brasil\",\n  pib = 1609,\n  inflacao = 0.05,\n  cambio = c(4.86, 5.13, 5.20, 5.07, 4.97)\n)\n\nNeste exemplo, pais_info é uma lista que contém quatro elementos:\n\nnome: o nome do país (tipo caractere).\npib: o Produto Interno Bruto do país (tipo numérico).\ninflacao: a taxa de inflação do país (tipo numérico).\ncambio: uma série temporal de valores de câmbio do país (tipo vetor numérico).\n\nEsta lista exemplifica como podemos armazenar diferentes tipos de dados em uma lista em R. Ela pode ser usada para representar informações econômicas de um país de forma organizada e acessível.\nPara acessar elementos individuais em uma lista pelo nome, usamos o operador de dólar $.\n\n# Acessando o nome do país\npais_info$nome\n\n[1] \"Brasil\"\n\n# Acessando o PIB do país\npais_info$pib\n\n[1] 1609\n\n\nTambém podemos acessar elementos individuais em uma lista por índice usando colchetes [ ].\n\n# Acessando o primeiro elemento da lista (nome do país)\nprimeiro_elemento &lt;- pais_info[[1]]\n\n# Acessando o terceiro elemento da lista (taxa de inflação)\nterceiro_elemento &lt;- pais_info[[3]]\n\nVocê deve ter notado o uso de colchetes duplos para acessar os elementos da lista. Em R, os colchetes simples ([]) e duplos ([[]]) têm diferentes propósitos quando usados para acessar elementos em uma lista.\nEm resumo, os colchetes simples são usados para acessar subconjuntos de elementos em uma lista, preservando sua estrutura, enquanto os colchetes duplos são usados para acessar valores individuais de uma lista, sem preservar a estrutura original.\n\n\n1.6.4 DataFrames\nOs dataframes são estruturas de dados tabulares em R que representam conjuntos de dados retangulares onde as colunas podem ser de tipos diferentes, como numérico, caractere, lógico ou fator.\nPara criar um dataframe, usamos a função data.frame(), fornecendo vetores de dados para cada coluna.\n\n# Criando um dataframe com dados econômicos\ndados_economicos &lt;- data.frame(\n  país = c(\"Brasil\", \"EUA\", \"China\", \"Índia\", \"Japão\"),\n  continente = factor(c(\"América\", \"América\", \"Ásia\", \"Ásia\", \"Ásia\")),\n  população = c(213, 328, 1441, 1380, 126),\n  pib_per_capita = c(10294, 65741, 10380, 2353, 41581),\n  inflação = c(0.02, 0.01, 0.04, 0.06, 0.005)\n)\n\nPodemos acessar elementos individuais, linhas ou colunas de um dataframe usando índices numéricos ou nomes de colunas.\n\n# Acessando a primeira linha do dataframe\n(primeira_linha &lt;- dados_economicos[1, ])\n\n    país continente população pib_per_capita inflação\n1 Brasil    América       213          10294     0.02\n\n# Acessando a coluna \"país\" do dataframe\n(paises &lt;- dados_economicos$país)\n\n[1] \"Brasil\" \"EUA\"    \"China\"  \"Índia\"  \"Japão\" \n\n# Acessando o elemento na segunda linha e terceira coluna do dataframe\n(elemento &lt;- dados_economicos[2, 3])\n\n[1] 328\n\n\nPodemos combinar dataframes com base em colunas comuns usando a função merge().\n\n# Criando outro dataframe para junção\ndados_demograficos &lt;- data.frame(\n  país = c(\"China\", \"Índia\", \"Japão\", \"Brasil\", \"EUA\"),\n  expectativa_vida = c(76, 69, 84, 75, 79)\n)\n\n# Realizando uma junção (merge) com base na coluna \"país\"\n(dados_com_demografia &lt;- merge(dados_economicos, dados_demograficos, by = \"país\"))\n\n    país continente população pib_per_capita inflação expectativa_vida\n1 Brasil    América       213          10294    0.020               75\n2  China       Ásia      1441          10380    0.040               76\n3    EUA    América       328          65741    0.010               79\n4  Índia       Ásia      1380           2353    0.060               69\n5  Japão       Ásia       126          41581    0.005               84\n\n\nPodemos combinar novas linhas de dados ao dataframe existente.\n\n# Criando outro dataframe para combinação de linhas\nmais_dados &lt;- data.frame(\n  país = c(\"África do Sul\", \"Alemanha\"),\n  continente = c(\"África\", \"Europa\"),\n  população = c(60, 83),\n  pib_per_capita = c(6151, 52947),\n  inflação = c(0.025, 0.015),\n  expectativa_vida = c(58, 81)\n)\n\n# Combinando os dataframes por linhas\n(todos_dados &lt;- rbind(dados_com_demografia, mais_dados))\n\n           país continente população pib_per_capita inflação expectativa_vida\n1        Brasil    América       213          10294    0.020               75\n2         China       Ásia      1441          10380    0.040               76\n3           EUA    América       328          65741    0.010               79\n4         Índia       Ásia      1380           2353    0.060               69\n5         Japão       Ásia       126          41581    0.005               84\n6 África do Sul     África        60           6151    0.025               58\n7      Alemanha     Europa        83          52947    0.015               81"
  },
  {
    "objectID": "01-fundamentos_r.html#exercícios",
    "href": "01-fundamentos_r.html#exercícios",
    "title": "1  Fundamentos de R",
    "section": "1.7 Exercícios",
    "text": "1.7 Exercícios\nutilize a funcao class e avalie a diferenca entre pais_info[1] e pais_info[[2]]"
  },
  {
    "objectID": "02-fluxos.html#estruturas-condicionais",
    "href": "02-fluxos.html#estruturas-condicionais",
    "title": "2  Fluxos de execução",
    "section": "2.1 Estruturas condicionais",
    "text": "2.1 Estruturas condicionais\nO fluxo de código em R pode ser controlado por meio de estruturas condicionais, como o if, else if e else. Essas estruturas permitem que você execute diferentes blocos de código com base em condições específicas.\n\n2.1.1 if e else\nO if é uma estrutura de controle de fluxo que executa um bloco de código se uma condição especificada for verdadeira. Se a condição for falsa, o bloco de código dentro do if não será executado. Por outro lado, o else é usado para executar um bloco de código quando a condição do if for falsa.\nA sintaxe básica do if e else em R é a seguinte:\n\nif (condição) {\n  # Bloco de código a ser executado se a condição for verdadeira\n} else {\n  # Bloco de código a ser executado se a condição for falsa\n}\n\nAqui está um exemplo prático de como usar o if e else para verificar se um número inteiro escolhido aleatóriamente entre -10 e 10 é positivo ou negativo:\n\n# Definindo a semente para garantir reprodutibilidade\nset.seed(42)\n\n# Gerando um número aleatório entre -10 e 10\nnumero &lt;- sample(-10:10, 1)\n\nif (numero &gt; 0) {\n  print(\"O número é positivo.\")\n} else {\n  print(\"O número é negativo ou zero.\")\n}\n\n[1] \"O número é positivo.\"\n\n\nNeste exemplo, sample(-10:10, 1) gera um número aleatório entre -10 e 10, e o valor é atribuído à variável numero. Além disso, set.seed(123) define a semente como 123. Isso garante que, ao gerar o número aleatório com sample(), o mesmo número seja escolhido sempre que o código for executado. Em seguida, verificamos se o número é positivo ou não e imprimimos a mensagem correspondente.\n\n\n2.1.2 else if\nAlém do if e else, também podemos usar o else if para adicionar mais condições à estrutura condicional. O else if permite verificar múltiplas condições em sequência. Se a condição do if for falsa, ele verifica a próxima condição do else if. Se todas as condições do if e else if forem falsas, o bloco de código dentro do else é executado.\nAqui está a sintaxe do else if:\n\nif (condição1) {\n  # Bloco de código a ser executado se a condição1 for verdadeira\n} else if (condição2) {\n  # Bloco de código a ser executado se a condição2 for verdadeira\n} else {\n  # Bloco de código a ser executado se nenhuma das condições anteriores for verdadeira\n}\n\nVeja um exemplo prático de como usar o if, else if e else para avaliar o desempenho de uma empresa com base em sua receita anual:\n\n# Determina a classificação da empresa com base na receita anual\nreceita_anual &lt;- 1500000\n\nif (receita_anual &gt;= 2000000) {\n  print(\"Empresa de Grande Porte\")\n} else if (receita_anual &gt;= 1000000) {\n  print(\"Empresa de Médio Porte\")\n} else if (receita_anual &gt;= 500000) {\n  print(\"Empresa de Pequeno Porte\")\n} else {\n  print(\"Microempresa\")\n}\n\n[1] \"Empresa de Médio Porte\"\n\n\nNeste exemplo, a empresa é classificada com base em sua receita anual. Se a receita for igual ou superior a 2.000.000, a empresa será classificada como “Empresa de Grande Porte”. Se estiver entre 1.000.000 e 1.999.999, será classificada como “Empresa de Médio Porte”. Se estiver entre 500.000 e 999.999, será classificada como “Empresa de Pequeno Porte”. Caso contrário, será considerada uma “Microempresa”."
  },
  {
    "objectID": "02-fluxos.html#estruturas-de-repetição",
    "href": "02-fluxos.html#estruturas-de-repetição",
    "title": "2  Fluxos de execução",
    "section": "2.2 Estruturas de repetição",
    "text": "2.2 Estruturas de repetição\nAs estruturas de repetição, também conhecidas como loops, são utilizadas para executar um bloco de código repetidamente enquanto uma condição específica for verdadeira ou para percorrer uma sequência de elementos. Isso é útil quando você precisa executar uma tarefa várias vezes ou quando deseja iterar sobre uma coleção de dados.\n\n2.2.1 foor\nUma das estruturas de repetição mais comuns é o loop for. O loop for é usado para iterar sobre uma sequência de valores, como uma sequência numérica de números inteiros ou os elementos de um vetor.\nExistem duas maneiras de se usar o for loop. - Usando for para iterar sobre índices:\n\n# Exemplo de loop for para iterar sobre índices\nfor (i in 1:5) {\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\nNeste exemplo, o loop for itera sobre os valores de 1 a 5. Na primeira iteração, i é igual a 1; na segunda iteração, i é igual a 2; e assim por diante, até que i seja igual a 5.\n\nUsando for para iterar sobre elementos:\n\n\n# Exemplo de loop for para iterar sobre elementos de um vetor\nclientes &lt;- c(\"João\", \"Maria\", \"José\", \"Ana\")\nfor (nome in clientes) {\n  print(nome)\n}\n\n[1] \"João\"\n[1] \"Maria\"\n[1] \"José\"\n[1] \"Ana\"\n\n\nNeste exemplo, o loop for itera sobre os elementos do vetor clientes. Na primeira iteração, nome é igual a “João”; na segunda iteração, nome é igual a “Maria”; e assim por diante, até que todos os elementos do vetor sejam percorridos.\nEm ambos os exemplos, o bloco de código dentro do loop for é executado repetidamente para cada valor de i (no primeiro exemplo) ou nome (no segundo exemplo) até que a sequência seja completamente percorrida.\nNo exemplo abaixo, vamos simular dados econômicos para 10 países fictícios e calcular o PIB per capita de cada país.\n\nset.seed(42)\npib_paises &lt;- runif(10, min = 25000000, max = 40000000)\npopulacao_paises &lt;- runif(10, min = 1000000, max = 15000000)\n\npib_per_capita &lt;- numeric(length = 10)\n\n# Loop for para calcular o PIB per capita para cada pais\nfor (i in 1:10) {\n  # Calculando o PIB per capita\n  pib_per_capita[i] &lt;- pib_paises[i] / populacao_paises[i]\n}\nprint(round(pib_per_capita, 3))\n\n [1]  5.227  3.529  2.080  8.185  4.634  2.315  2.453 10.216  4.556  4.022\n\n\n\n\n\n\n\n\nClique e veja um exemplo extra\n\n\n\n\n\nImagine que temos uma série temporal representando o preço de fechamento diário de uma ação ao longo de um período de 30 dias. Queremos calcular a média móvel de 5 dias desse preço, ou seja, para cada dia, queremos calcular a média dos preços de fechamento dos cinco dias anteriores, incluindo o dia atual.\nPrimeiro, vamos simular os dados do preço de fechamento diário da ação:\n\nset.seed(42)\npreco_acao &lt;- runif(30, min = 9, max = 15)\n\nAgora, vamos calcular a média móvel de 5 dias usando um loop for:\n\nmedia_movel &lt;- numeric(length = 26)  # Vetor para armazenar a média móvel\n\nfor (i in 5:30) {\n  media_movel[i - 4] &lt;- mean(preco_acao[(i - 4):i])\n}\n\nNeste loop for, começamos a partir do quinto dia, pois precisamos de pelo menos cinco dias para calcular a média móvel de 5 dias. Para cada dia a partir do quinto dia até o trigésimo dia, calculamos a média dos preços de fechamento dos cinco dias anteriores, incluindo o dia atual, e armazenamos esse valor no vetor media_movel.\nAgora, podemos imprimir a média móvel calculada:\n\nprint(media_movel)\n\n [1] 13.33226 12.85740 12.61682 12.43505 12.22691 12.30289 12.22926 12.20829\n [9] 13.16830 12.68642 12.39510 12.97382 13.28476 12.30414 12.56762 12.68527\n[17] 12.64209 11.63467 12.68036 13.24636 12.67289 12.20510 12.50690 12.40711\n[25] 11.80747 12.71175\n\n\nEste exemplo demonstra como usar um loop for em conjunto com vetores para calcular a média móvel de uma série temporal. O gráfico abaixo mostra a média móvel ao longo dos dias. Você aprenderá como construir gráficos assim na (ch-dataviz?).\n\n\n\n\n\n\n\n\n\n\n2.2.2 while\nA estrutura while é usada para repetir um bloco de código enquanto uma condição especificada for verdadeira. Aqui está a estrutura geral de um loop while:\n\nwhile (condição) {\n  # Código a ser repetido enquanto a condição for verdadeira\n}\n\nA condição é uma expressão lógica que é avaliada antes de cada execução do bloco de código dentro do loop. Se a condição for verdadeira, o bloco de código é executado; se a condição for falsa, o loop é interrompido e o controle é passado para a próxima linha de código após o loop.\nNo exemplo abaixo, vamos definir um vetor chamado acoes, que contém uma lista de atividades possíveis que uma pessoa pode realizar durante o dia. Dentre as ações possíveis, uma será escolhida aleatoriamente.\n\nacoes &lt;- c( \"Aprender a programar em R\",\n        \"Aprender a programar em R\",\n        \"Fazer um café\",\n        \"Descansar\")\n\nset.seed(42)\nacao &lt;- sample(acoes, 1)\nprint(acao)\n\n[1] \"Aprender a programar em R\"\n\n\nNo trecho de código a seguir, usamos a estrutura while para continuar selecionando aleatoriamente uma atividade do vetor acoes até que a atividade selecionada seja “Descansar”. O loop começa verificando se a variável acao é diferente de “Descansar”. Se essa condição for verdadeira, uma nova atividade é selecionada aleatoriamente do vetor acoes usando a função sample() com size = 1, o que significa que estamos selecionando apenas um elemento aleatório do vetor. Em seguida, a atividade selecionada é impressa na tela usando a função print(). Esse processo se repete até que a atividade selecionada seja “Descansar”, momento em que o loop é encerrado.\n\nwhile(acao != \"Descansar\") {\n  acao &lt;- sample(acoes, 1)\n  print(acao)\n}\n\n[1] \"Aprender a programar em R\"\n[1] \"Aprender a programar em R\"\n[1] \"Aprender a programar em R\"\n[1] \"Aprender a programar em R\"\n[1] \"Descansar\"\n\n\n\n\n\n\n\n\nClique e veja um exemplo extra\n\n\n\n\n\nVamos considerar um exemplo onde queremos simular a evolução de uma população ao longo do tempo, onde não sabemos exatamente quantos períodos serão necessários para que a população atinja um determinado limite. Neste caso, usaremos um loop while para continuar simulando o crescimento populacional até que a população alcance um certo valor limite.\n\nset.seed(42)  # Define uma semente para a replicabilidade dos resultados\n\n# População inicial\npopulacao &lt;- 1000\n\n# Taxa de crescimento anual da população (em decimal)\ntaxa_crescimento &lt;- 0.02\n\n# População limite desejada\nlimite_populacional &lt;- 2000\n\n# Inicializando o contador de anos\nanos &lt;- 0\n\n# Simulando o crescimento populacional até atingir o limite\nwhile (populacao &lt; limite_populacional) {\n  # Calculando o número de novos indivíduos neste ano\n  novos_individuos &lt;- populacao * taxa_crescimento\n  \n  # Incrementando a população com os novos indivíduos\n  populacao &lt;- populacao + novos_individuos\n  \n  # Incrementando o contador de anos\n  anos &lt;- anos + 1\n}\n\n# Imprimindo o número de anos necessários para atingir o limite populacional\nprint(paste(\"Foram necessários\", anos, \"anos para atingir uma população de\", populacao))\n\n[1] \"Foram necessários 36 anos para atingir uma população de 2039.8873437157\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nÉ possível calcular diretamente o número de anos necessários para atingir a população limite desejada. Com um pouco de álgebra você chege na seguinte fórmula para calcular o número de anos: \\[\\text{anos} = \\frac{\\log\\left(\\frac{\\text{limite\\_populacional}}{\\text{populacao\\_inicial}}\\right)}{\\log(1 + \\text{taxa\\_crescimento})}.\\]"
  },
  {
    "objectID": "02-fluxos.html#teste2",
    "href": "02-fluxos.html#teste2",
    "title": "2  Fluxos de execução",
    "section": "2.3 teste2",
    "text": "2.3 teste2"
  },
  {
    "objectID": "02-fluxos.html#while",
    "href": "02-fluxos.html#while",
    "title": "2  Fluxos de execução",
    "section": "2.3 while",
    "text": "2.3 while\nA estrutura while é usada para repetir um bloco de código enquanto uma condição especificada for verdadeira. Aqui está a estrutura geral de um loop while:\n\nwhile (condição) {\n  # Código a ser repetido enquanto a condição for verdadeira\n}\n\nA condição é uma expressão lógica que é avaliada antes de cada execução do bloco de código dentro do loop. Se a condição for verdadeira, o bloco de código é executado; se a condição for falsa, o loop é interrompido e o controle é passado para a próxima linha de código após o loop.\nNo exemplo abaixo, vamos definir um vetor chamado acoes, que contém uma lista de atividades possíveis que uma pessoa pode realizar durante o dia. Dentre as ações possíveis, uma será escolhida aleatoriamente.\n\nacoes &lt;- c( \"Aprender a programar em R\",\n        \"Aprender a programar em R\",\n        \"Fazer um café\",\n        \"Descansar\")\n\nset.seed(42)\nacao &lt;- sample(acoes, 1)\nprint(acao)\n\n[1] \"Aprender a programar em R\"\n\n\nNo trecho de código a seguir, usamos a estrutura while para continuar selecionando aleatoriamente uma atividade do vetor acoes até que a atividade selecionada seja “Descansar”. O loop começa verificando se a variável acao é diferente de “Descansar”. Se essa condição for verdadeira, uma nova atividade é selecionada aleatoriamente do vetor acoes usando a função sample() com size = 1, o que significa que estamos selecionando apenas um elemento aleatório do vetor. Em seguida, a atividade selecionada é impressa na tela usando a função print(). Esse processo se repete até que a atividade selecionada seja “Descansar”, momento em que o loop é encerrado.\n\nwhile(acao != \"Descansar\") {\n  acao &lt;- sample(acoes, 1)\n  print(acao)\n}\n\n[1] \"Aprender a programar em R\"\n[1] \"Aprender a programar em R\"\n[1] \"Aprender a programar em R\"\n[1] \"Aprender a programar em R\"\n[1] \"Descansar\"\n\n\n\n\n\n\n\n\nClique e veja um exemplo extra\n\n\n\n\n\nVamos considerar um exemplo onde queremos simular a evolução de uma população ao longo do tempo, onde não sabemos exatamente quantos períodos serão necessários para que a população atinja um determinado limite. Neste caso, usaremos um loop while para continuar simulando o crescimento populacional até que a população alcance um certo valor limite.\n\nset.seed(42)  # Define uma semente para a replicabilidade dos resultados\n\n# População inicial\npopulacao &lt;- 1000\n\n# Taxa de crescimento anual da população (em decimal)\ntaxa_crescimento &lt;- 0.02\n\n# População limite desejada\nlimite_populacional &lt;- 2000\n\n# Inicializando o contador de anos\nanos &lt;- 0\n\n# Simulando o crescimento populacional até atingir o limite\nwhile (populacao &lt; limite_populacional) {\n  # Calculando o número de novos indivíduos neste ano\n  novos_individuos &lt;- populacao * taxa_crescimento\n  \n  # Incrementando a população com os novos indivíduos\n  populacao &lt;- populacao + novos_individuos\n  \n  # Incrementando o contador de anos\n  anos &lt;- anos + 1\n}\n\n# Imprimindo o número de anos necessários para atingir o limite populacional\nprint(paste(\"Foram necessários\", anos, \"anos para atingir uma população de\", populacao))\n\n[1] \"Foram necessários 36 anos para atingir uma população de 2039.8873437157\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nÉ possível calcular diretamente o número de necessários para atingir a população limite desejada. Com um pouco de álgebra você chege na seguinte fórmula para calcular o número de anos: \\[\\text{anos} = \\frac{\\log\\left(\\frac{\\text{limite\\_populacional}}{\\text{populacao\\_inicial}}\\right)}{\\log(1 + \\text{taxa\\_crescimento})}.\\]"
  },
  {
    "objectID": "02-fluxos.html#exercícios",
    "href": "02-fluxos.html#exercícios",
    "title": "2  Fluxos de execução",
    "section": "2.3 Exercícios",
    "text": "2.3 Exercícios\n1. Neste exercício, vamos simular o lançamento de uma moeda e armazenar os resultados como um fator contendo os níveis “cara” e “coroa”. Para isso, siga os passos abaixo:\na) Utilize o comando abaixo para gerar amostras aleatórias seguindo a distribuição binomial para simular o lançamento de 100 moedas:\n\nset.seed(42)\nlancamentos &lt;- rbinom(100, 1, 0.5)\n\nb) Considere que 0 represente “cara” e 1 represente “coroa”. Crie uma variável para armazenar os lançamentos como um fator contendo os níveis “cara” e “coroa”.\nc) Conte quantas vezes cada um dos resultados ocorreu neste experimento.\nd) Utilize um loop para percorrer o vetor de traz para frente e descubra qual foi o último lançamento que resultado em uma “cara”.\n2. Trabalhando com dados de pacotes.\na) Instale o pacote nycflights13 utilizando o comando abaixo:\n\ninstall.packages(\"nycflights13\")\n\nb) Carregue no seu ambiente o pacote instalado:\n\nlibrary(nycflights13)\n\nc) Utilizando os comandos abaixo, verifique o conteúdo dos dataframes flights e airports:\n\n?flights\n?airports\n\nd) Filtre os voos que aconteceram em 25/01/2013 e armazene-os na variável natal;\ne) Quantos voos partiram de Nova Iorque em 25/12/2013?\nf) Obtenha um sumário da coluna dep_delay. Há dados faltantes? Se sim, remova-os.\ng) Obtenha o nome do aeroporto de destino do voo com maior atraso de partida em 25/12/2013. Dica: mescle os dados de flights e airports."
  }
]