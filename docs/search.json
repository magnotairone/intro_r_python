[
  {
    "objectID": "01-fundamentos_r.html#rstudio",
    "href": "01-fundamentos_r.html#rstudio",
    "title": "1  Fundamentos de R",
    "section": "1.1 RStudio",
    "text": "1.1 RStudio\nPara instalação, faça o download do R em http://www.r-project.org. Em seguida, instale a IDE (Integrated Development Environment) R Studio.\nAo abrir o RStudio, clique no menu File/ New File/ R Script (ou Ctrl+Shift+N). Você deve ver uma estrutura como a mostrada na figura abaixo.\n\n\n\nInterface do Rstudio\n\n\nNote que são quatro paineis:\n\nPainel de Scripts (superior esquerdo): este painel é onde você pode escrever, editar e executar scripts R. Ele fornece recursos como destaque de sintaxe, autocompletar e verificação de código para ajudar na escrita de código.\nPainel de Console (inferior esquerdo):o console é onde o código R é executado e os resultados são exibidos. Você pode inserir comandos diretamente aqui e ver imediatamente os resultados. Ele também mantém um histórico de comandos executados, o que pode ser útil para referência futura.\nAmbiente/Workspace (superior direito): este painel exibe informações sobre os objetos (como variáveis, funções, etc.) atualmente carregados na memória do R. Ele mostra detalhes como o nome do objeto, tipo de objeto e seu valor atual. Isso é útil para monitorar e gerenciar objetos durante uma sessão de trabalho.\nArquivos/Plots/Pacotes/Ajuda (inferior direito): um painel com diversas funcionalidades.\n\nArquivos: Esta guia permite navegar e gerenciar os arquivos do seu projeto. Você pode criar, renomear, excluir e organizar arquivos e pastas diretamente dentro do RStudio.\nGráficos (Plots): Aqui são exibidos os gráficos gerados pelo R. Quando você cria um gráfico usando funções de visualização em R, o resultado é exibido nesta guia. Isso facilita a análise visual dos seus dados e a inspeção dos gráficos durante o processo de criação.\nPacotes: Nesta guia, você pode visualizar e gerenciar os pacotes instalados no seu ambiente R. Ela exibe uma lista de todos os pacotes instalados, juntamente com sua versão e status (carregado ou não). Além disso, você pode instalar novos pacotes, atualizar pacotes existentes e carregar ou descarregar pacotes conforme necessário para o seu trabalho.\nAjuda (Help): Esta guia fornece acesso rápido à documentação e às informações de ajuda sobre funções, pacotes e outros recursos do R. Você pode pesquisar por tópicos específicos e acessar a documentação oficial diretamente no RStudio. Isso é útil para obter informações sobre a sintaxe de uma função, exemplos de uso e detalhes sobre os parâmetros disponíveis."
  },
  {
    "objectID": "01-fundamentos_r.html#sec-tipodedados",
    "href": "01-fundamentos_r.html#sec-tipodedados",
    "title": "1  Fundamentos de R",
    "section": "1.2 Tipos de dados",
    "text": "1.2 Tipos de dados\nSempre que estiver aprendendo uma nova linguagem, procure primeiro saber quais são os tipos de dados básicos que podem ser representandos nessa linguagem.\nEm R, são quatro os tipos básicos de dados disponíveis: numéricos, lógicos, caracteres e fatores.\n\n1.2.1 O tipo de dado numérico\nOs dados numéricos (numeric) são usados para expressar valores quantitativos, como preços, taxas e quantidades, sendo representados por números inteiros ou decimais.\n\n# Número inteiro representando quantidade de acoes em uma carteira\nqtd_acoes &lt;- 100\n\n# Número de ponto flutuante representando a taxa de inflação\ntaxa_inflacao &lt;- 3.5\n\n# Verificando a classe de taxa_inflacao\nclass(taxa_inflacao)\n\n[1] \"numeric\"\n\n\nA função class() é usada para determinar a classe de uma variável. Em outras palavras, ela fornece informações sobre o tipo de dado que uma variável representa. Nesse caso acima, a variável taxa_inflacao é da classe numeric.\n\n\n1.2.2 O tipo de dado lógico\nOs dados lógicos (logical) são empregados para representar estados ou condições, como verdadeiro ou falso, sendo úteis em operações de lógica e comparação.\n\n# Verificando se a taxa de juros está aumentando\ntaxa_juros_aumentando &lt;- TRUE\n\n# Verificando se o preço das ações está caindo\nqueda_preco_acoes &lt;- FALSE\n\n# Verificando a classe de queda_preco_acoes\nclass(queda_preco_acoes)\n\n[1] \"logical\"\n\n\n\n\n1.2.3 O tipo de dado caractere\nJá os dados do tipo caractere (character) são utilizados para representar texto, como nomes de países, empresas ou categorias, sendo essenciais em análises descritivas e comunicação de resultados.\n\n# Nome de um país\npais &lt;- \"Brasil\"\n\n# Nome de uma empresa multinacional\nempresa &lt;- \"Petróleo Brasileiro S.A.\"\n\n# Verificando a classe de pais\nclass(pais)\n\n[1] \"character\"\n\n\n\n\n1.2.4 O tipo de dado fator\nOs fatores (factor) são empregados para representar variáveis categóricas, como classificações, categorias ou grupos, uma forma eficiente de lidar com dados discretos e qualitativos.\n\n# Classificação do risco de crédito de uma empresa\nrisco_credito &lt;- factor(c(\"Baixo\", \"Médio\", \"Alto\", \"Baixo\", \"Alto\"))\n\n# Verificando a classe de risco_credito\nclass(risco_credito)\n\n[1] \"factor\"\n\n\nA função levels() retorna os níveis (ou categorias) de um fator. Isso é útil para entender quais são as categorias representadas pelo fator e para realizar operações de manipulação de dados com base nessas categorias.\n\n# Exibindo os níveis de risco de crédito\nlevels(risco_credito)\n\n[1] \"Alto\"  \"Baixo\" \"Médio\""
  },
  {
    "objectID": "01-fundamentos_r.html#fundamentos-da-linguagem",
    "href": "01-fundamentos_r.html#fundamentos-da-linguagem",
    "title": "1  Fundamentos de R",
    "section": "1.3 Fundamentos da linguagem",
    "text": "1.3 Fundamentos da linguagem\nO ambiente R refere-se ao espaço de trabalho onde todas as variáveis, funções e objetos criados durante uma sessão R são armazenados e manipulados. O ambiente inclui tanto os objetos que você criou quanto os que são carregados automaticamente por meio de pacotes ou outros mecanismos de importação de dados (mais sobre pacotes na Section 2.4).\nPor exemplo, ao usar a função ls() (que lista os nomes dos objetos no ambiente atual), podemos ver todos os objetos atualmente presentes no ambiente R.\n\n\nls()\n\nSe você executou corretamente todos os comandos da Seção Section 1.2, deve obter como resultado no console o seguinte:\n[1] \"empresa\"               \"pais\"                  \"qtd_acoes\"\n[4] \"queda_preco_acoes\"     \"taxa_inflacao\"         \"taxa_juros_aumentando\"\nusando R como calculadora numeros especiais"
  },
  {
    "objectID": "01-fundamentos_r.html#variáveis",
    "href": "01-fundamentos_r.html#variáveis",
    "title": "1  Fundamentos de R",
    "section": "1.4 Variáveis",
    "text": "1.4 Variáveis\nNa Section 1.2 algumas variáveis foram criadas. Por exemplo a variável empresa que armazena uma cadeia de caracteres. Você viu, anteriormente a maneira de listar todas as variáveis definidas no seu ambiente. Mas, afinal, o que são variáveis?\nNo R, variáveis são elementos fundamentais usados para armazenar e manipular dados. Elas são como recipientes que guardam valores, objetos ou expressões. Quando você atribui um valor a uma variável, está basicamente dando um nome a esse valor para poder acessá-lo e manipulá-lo posteriormente.\nPor exemplo, ao escrever preco_acao &lt;- 10, você está criando uma variável chamada preco_acao e atribuindo a ela o valor 10. Agora, sempre que você usar preco_acao em seu código, estará se referindo a esse valor.\nUma prática comum escolher nomes descritivos para variáveis que ajudem a entender seu propósito ou conteúdo. Por exemplo, em um contexto econômico, você pode usar preco_acao para representar o preço de uma ação ou taxa_inflacao para representar a taxa de inflação.\nPara atribuir um valor a uma variável, use o operador &lt;-. O operador = também pode ser usado para atribuir valores a variáveis. Ambos os operadores têm o mesmo efeito prático na atribuição de valores a variáveis em R. A escolha entre eles geralmente se resume à preferência pessoal e ao estilo de codificação, embora alguns guias de estilo de código sugiram o uso do &lt;-."
  },
  {
    "objectID": "01-fundamentos_r.html#verificando-o-tipo-de-uma-variável",
    "href": "01-fundamentos_r.html#verificando-o-tipo-de-uma-variável",
    "title": "1  Fundamentos de R",
    "section": "1.5 Verificando o tipo de uma variável",
    "text": "1.5 Verificando o tipo de uma variável\nVamos usar as funções da família is.* para vericar os tipos de algumas das variáveis que estão no nosso ambiente de trabalho.\n\nPara a variável empresa:\n\n\nis.character(empresa)\n\nIsso retornará TRUE se a variável empresa for do tipo caractere (character).\n\nPara a variável pais:\n\n\nis.character(pais)\n\nAssim como para a variável empresa, isso retornará TRUE se a variável pais for do tipo caractere.\n\nPara a variável qtd_acoes:\n\n\nis.numeric(qtd_acoes)\n\nIsso retornará TRUE se a variável qtd_acoes for do tipo numérico (numeric).\n\nPara a variável queda_preco_acoes:\n\n\nis.logical(queda_preco_acoes)\n\nIsso retornará TRUE se a variável queda_preco_acoes for do tipo lógico (logical).\n\nPara a variável taxa_inflacao:\n\n\nis.numeric(taxa_inflacao)\n\nAssim como para a variável qtd_acoes, isso retornará TRUE se a variável taxa_inflacao for do tipo numérico.\n\nPara a variável taxa_juros_aumentando:\n\n\nis.logical(taxa_juros_aumentando)\n\nIsso retornará TRUE se a variável taxa_juros_aumentando for do tipo lógico.\nEsses exemplos ilustram como você pode usar as funções is.* para verificar o tipo de variáveis, ajudando a garantir que você esteja manipulando os dados corretamente em suas análises.\nOutra família de funções importantes é a das funções as.*. Elas são usadas para fazer a coerção (converter) de um objeto de um tipo para outro. Elas permitem que você altere o tipo de dado de uma variável, o que pode ser útil em várias situações, como quando você precisa realizar operações específicas que exigem um determinado tipo de dado ou quando deseja garantir a consistência dos tipos de dados em seu código.\nAlgumas das funções as.* mais comuns incluem:\n\nas.character(): Converte um objeto para o tipo caractere (character).\n\n\nnumero &lt;- 123\nnumero_caractere &lt;- as.character(numero)\n\n\nas.numeric(): Converte um objeto para o tipo numérico (numeric).\n\n\ntexto &lt;- \"3.14\"\nnumero &lt;- as.numeric(texto)\n\n\nas.logical():\n\n\nnumero &lt;- 0\nlogico &lt;- as.logical(numero)\n\nEssas funções são úteis para garantir que os tipos de dados estejam corretos em seu código e para garantir que você possa realizar as operações desejadas em seus objetos. No entanto, é importante observar que nem todas as conversões podem ser bem-sucedidas, especialmente quando há perda de informações (por exemplo, ao converter de caractere para numérico). Portanto, é sempre uma boa prática verificar se a conversão foi feita corretamente e se os dados resultantes são os esperados.\nVeja um exemplo de conversão de caractere para numérico com texto não numérico:\n\ntexto &lt;- \"abc\"\nnumero &lt;- as.numeric(texto)\n\nWarning: NAs introduzidos por coerção\n\n\nNeste exemplo, a tentativa de converter o texto “abc” para um número resultará em um valor NA (Not Available), indicando que a conversão falhou. Veja que a saída do console indica uma mensagem de warning."
  },
  {
    "objectID": "01-fundamentos_r.html#estruturas-de-dados",
    "href": "01-fundamentos_r.html#estruturas-de-dados",
    "title": "1  Fundamentos de R",
    "section": "1.6 Estruturas de dados",
    "text": "1.6 Estruturas de dados\nEm toda análises de dados, é comum lidar com conjuntos de dados que possuem diferentes estruturas e formatos. Vamos explorar quatro estruturas de dados fundamentais em R: vetor, matriz, lista e DataFrame.\n\n1.6.1 Vetores\nUm vetor em R é uma estrutura de dados unidimensional que armazena uma sequência ordenada de elementos do mesmo tipo. A função c nos ajuda a criar vetores.\n\n# Vetor de preços de ações\nprecos_acoes &lt;- c(100, 110, 105, 120, 115)\n\nEm alguns casos, é de interesse definir sequências de números usando os operadores : e a função seq().\n\n# Vetor de números de 1 a 10\nsequencia &lt;- 1:10\nsequencia\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\n# Vetor de números de 1 a 10 com incremento de 2\nsequencia_incremento &lt;- seq(from = 1, to = 10, by = 2)\nsequencia_incremento\n\n[1] 1 3 5 7 9\n\n\nPara verificar o tamanho de um vetor, você pode usar a função length().\n\n# Verificando o tamanho do vetor de preços de ações\nlength(precos_acoes)\n\n[1] 5\n\nlength(1:10)\n\n[1] 10\n\n\nPara acessar elementos em um vetor em R, você pode usar índices numéricos ou lógicos dentro dos colchetes [ ].\nVocê pode acessar elementos usando índices numéricos dentro dos colchetes [ ]. Por exemplo, vetor[i] acessa o elemento na posição i do vetor.\n\n# Vetor de preços de ações\nprecos_acoes &lt;- c(100, 110, 105, 120, 115)\n\n# Acessando o segundo elemento do vetor\nsegundo_elemento &lt;- precos_acoes[2]\n\n# Acessando uma série de elementos do vetor\nvarios_elementos &lt;- precos_acoes[3:5]\n\nVocê também pode acessar elementos usando índices lógicos dentro dos colchetes [ ]. Por exemplo, vetor[indices_logicos] retorna os elementos do vetor onde os índices lógicos são TRUE.\n\n# Acessando preços de ações maiores que 110\nprecos_maior_que_110 &lt;- precos_acoes[precos_acoes &gt; 110]\n\n\n\n1.6.2 Matrizes\nUma matriz em R é uma estrutura de dados bidimensional que consiste em linhas e colunas de elementos do mesmo tipo. É útil para representar conjuntos de dados tabulares, como dados de séries temporais ou matrizes de covariância.\n\n# Matriz de retornos de ativos\nretornos_ativos &lt;- matrix(c(0.05, 0.03, 0.02, 0.04, 0.06, 0.03), \n                          nrow = 2, byrow = TRUE)\nrownames(retornos_ativos) &lt;- c(\"Ação 1\", \"Ação 2\")\ncolnames(retornos_ativos) &lt;- c(\"Ano 1\", \"Ano 2\", \"Ano 3\")\n\nO código acima cria uma matriz chamada retornos_ativos que armazena os retornos de dois ativos ao longo de três anos.\nA função matrix() é usada para criar a matriz. O vetor c(0.05, 0.03, 0.02, 0.04, 0.06, 0.03) contém os valores dos retornos dos ativos, fornecidos em ordem de preenchimento de coluna (de cima para baixo). Os parâmetros nrow = 2 e byrow = TRUE indicam que a matriz deve ter 2 linhas (para representar os dois ativos) e que os valores devem ser preenchidos por linha (ou seja, primeiro os retornos para o ano 1, depois para o ano 2 e assim por diante). As funções rownames() e colnames() são usadas para atribuir nomes às linhas e colunas da matriz, respectivamente. No caso das linhas, são atribuídos os nomes “Ação 1” e “Ação 2”, representando os dois ativos. Para as colunas, são atribuídos os nomes “Ano 1”, “Ano 2” e “Ano 3”, representando os anos em que os retornos foram registrados.\nA função class() retorna a classe do objeto, que neste caso será “matrix”, indicando que retornos_ativos é uma matriz em R.\nA função dim() retorna as dimensões da matriz, ou seja, o número de linhas e colunas.\n\n# Verificando as dimensões da matriz\ndim(retornos_ativos)\n\n[1] 2 3\n\n\nNeste caso, o resultado será [2, 3], indicando que a matriz possui 2 linhas e 3 colunas.\nAs funções nrow() e ncol() retornam o número de linhas e colunas da matriz, respectivamente.\n\nc(nrow(retornos_ativos), ncol(retornos_ativos))\n\n[1] 2 3\n\n\nA função length() retorna o número total de elementos em um objeto. Para uma matriz, isso retornará o número total de elementos, ou seja, o produto do número de linhas pelo número de colunas.\n\nlength(retornos_ativos)\n\n[1] 6\n\n\nPara acessar linhas, colunas e elementos em uma matriz em R, você pode usar índices numéricos ou nomes (se definidos). Aqui está como fazer:\n\nAcessando Linhas e Colunas: Você pode acessar linhas e colunas usando índices numéricos dentro dos colchetes [ ]. Por exemplo, matriz[i, ] acessa a linha i e matriz[, j] acessa a coluna j. Para acessar uma célula específica, você usa matriz[i, j], onde i é o número da linha e j é o número da coluna.\n\n\n# Acessando a primeira linha da matriz\nprimeira_linha &lt;- retornos_ativos[1, ]\n\n# Acessando a segunda coluna da matriz\nsegunda_coluna &lt;- retornos_ativos[, 2]\n\n# Acessando o elemento na segunda linha e terceira coluna da matriz\nelemento &lt;- retornos_ativos[2, 3]\n\n# Acessando as três primeiras linhas da matriz\nprimeiras_linhas &lt;- retornos_ativos[1:2, ]\n\n# Acessando mais de uma coluna da matriz\nalgumas_colunas &lt;- retornos_ativos[, c(1,3)]\n\n\nAcessando Linhas e Colunas por Nomes: Se você definiu nomes para as linhas e/ou colunas da matriz, você pode acessá-las usando esses nomes.\n\n\n# Acessando a linha chamada \"Ação 1\"\nacao1 &lt;- retornos_ativos[\"Ação 1\", ]\n\n# Acessando a coluna chamada \"Ano 2\"\nano2 &lt;- retornos_ativos[, \"Ano 2\"]\n\n# Acessando o elemento na linha \"Ação 2\" e coluna \"Ano 3\"\nelemento2 &lt;- retornos_ativos[\"Ação 2\", \"Ano 3\"]\n\nEm R, diferente de outras linguagens de programação, os índices de linhas e colunas em matrizes (e também em vetores, listas, etc.) começam em 1 e não em 0. Isso significa que o primeiro elemento de uma matriz está no índice 1, o segundo no índice 2, e assim por diante\n\n\n1.6.3 Listas\nEm R, uma lista é uma estrutura de dados flexível que pode conter elementos de diferentes tipos, como vetores, matrizes, outras listas e até mesmo funções. As listas são úteis quando você precisa armazenar e manipular conjuntos de dados heterogêneos ou estruturas complexas.\nPodemos criar uma lista que armazena informações sobre um país, como seu nome, PIB, taxa de inflação e uma série temporal de valores de câmbio.\n\n# Criando uma lista com informações sobre um país\npais_info &lt;- list(\n  nome = \"Brasil\",\n  pib = 1609,\n  inflacao = 0.05,\n  cambio = c(4.86, 5.13, 5.20, 5.07, 4.97)\n)\n\nNeste exemplo, pais_info é uma lista que contém quatro elementos:\n\nnome: o nome do país (tipo caractere).\npib: o Produto Interno Bruto do país (tipo numérico).\ninflacao: a taxa de inflação do país (tipo numérico).\ncambio: uma série temporal de valores de câmbio do país (tipo vetor numérico).\n\nEsta lista exemplifica como podemos armazenar diferentes tipos de dados em uma lista em R. Ela pode ser usada para representar informações econômicas de um país de forma organizada e acessível.\nPara acessar elementos individuais em uma lista pelo nome, usamos o operador de dólar $.\n\n# Acessando o nome do país\npais_info$nome\n\n[1] \"Brasil\"\n\n# Acessando o PIB do país\npais_info$pib\n\n[1] 1609\n\n\nTambém podemos acessar elementos individuais em uma lista por índice usando colchetes [ ].\n\n# Acessando o primeiro elemento da lista (nome do país)\nprimeiro_elemento &lt;- pais_info[[1]]\n\n# Acessando o terceiro elemento da lista (taxa de inflação)\nterceiro_elemento &lt;- pais_info[[3]]\n\nVocê deve ter notado o uso de colchetes duplos para acessar os elementos da lista. Em R, os colchetes simples ([]) e duplos ([[]]) têm diferentes propósitos quando usados para acessar elementos em uma lista.\nImagine que uma lista em R seja como um trem, e cada elemento dessa lista é um vagão do trem. Agora, dentro de cada vagão, você pode armazenar diferentes tipos de carga, como caixas, sacos ou até mesmo outros vagões.\nPor exemplo, em um vagão você pode ter um vetor, em outro uma matriz e em outro apenas um número. Cada elemento da lista pode ser diferente do outro em tipo e conteúdo, assim como cada vagão de um trem pode conter coisas diferentes.\nQuando você quer acessar um vagão específico do trem, você usa colchetes simples [ ], e quando quer acessar os elementos dentro desse vagão, usa colchetes duplos [[ ]]. É como abrir a porta de um vagão para ver o que tem dentro e, em seguida, olhar dentro das caixas que estão dentro desse vagão para ver o que tem lá.\nVamos usar a analogia dos trens e vagões com a lista pais_info, que contém informações sobre o Brasil:\nAcessando um vagão específico\nPara acessar informações específicas sobre o Brasil, como o nome do país ou o valor do PIB, podemos usar os colchetes simples [ ]. Por exemplo: - pais_info[\"nome\"]: obtemos o vagão que contém o nome do país, e encontramos “Brasil”. - pais_info[2] : obtemos o segundo vagão, neste caso é o que contem o PIB do país, e encontramos o valor 1609.\nAcessando elementos dentro de um vagão\nAgora, se quisermos acessar elementos específicos dentro de um vagão, usamos colchetes duplos [[ ]]. Por exemplo:\n\npais_info[[\"cambio\"]]: abrimos o vagão que contém informações sobre o câmbio do país e acessamos o seu conteúdo, que é um vetor com diferentes valores de câmbio ao longo do tempo.\n\nAgora, se quisermos acessar um valor específico desse vetor, podemos usar os colchetes simples [ ] novamente:\n\npais_info[[\"cambio\"]][3]: isso abre o vagão que contém o vetor de câmbio e encontra o terceiro valor, que é 5.20.\n\nAo usar a função class() podemos notar a diferença entre os objetos obtidos ao usar colchetes simples e duplos.\n\nclass(pais_info[\"nome\"])\n\n[1] \"list\"\n\nclass(pais_info[[\"nome\"]])\n\n[1] \"character\"\n\n\n\n\n\n\n\n\nResumindo\n\n\n\nEm resumo, os colchetes simples são usados para acessar subconjuntos de elementos em uma lista, preservando sua estrutura, enquanto os colchetes duplos são usados para acessar valores individuais de uma lista, sem preservar a estrutura original.\n\n\n\n\n1.6.4 DataFrames\nOs dataframes são estruturas de dados tabulares em R que representam conjuntos de dados retangulares onde as colunas podem ser de tipos diferentes, como numérico, caractere, lógico ou fator.\nPara criar um dataframe, usamos a função data.frame(), fornecendo vetores de dados para cada coluna.\n\n# Criando um dataframe com dados econômicos\ndados_economicos &lt;- data.frame(\n  país = c(\"Brasil\", \"EUA\", \"China\", \"Índia\", \"Japão\"),\n  continente = factor(c(\"América\", \"América\", \"Ásia\", \"Ásia\", \"Ásia\")),\n  população = c(213, 328, 1441, 1380, 126),\n  pib_per_capita = c(10294, 65741, 10380, 2353, 41581),\n  inflação = c(0.02, 0.01, 0.04, 0.06, 0.005)\n)\n\nPodemos acessar elementos individuais, linhas ou colunas de um dataframe usando índices numéricos ou nomes de colunas.\n\n# Acessando a primeira linha do dataframe\n(primeira_linha &lt;- dados_economicos[1, ])\n\n    país continente população pib_per_capita inflação\n1 Brasil    América       213          10294     0.02\n\n# Acessando a coluna \"país\" do dataframe\n(paises &lt;- dados_economicos$país)\n\n[1] \"Brasil\" \"EUA\"    \"China\"  \"Índia\"  \"Japão\" \n\n# Acessando o elemento na segunda linha e terceira coluna do dataframe\n(elemento &lt;- dados_economicos[2, 3])\n\n[1] 328\n\n\nPodemos combinar dataframes com base em colunas comuns usando a função merge().\n\n# Criando outro dataframe para junção\ndados_demograficos &lt;- data.frame(\n  país = c(\"China\", \"Índia\", \"Japão\", \"Brasil\", \"EUA\"),\n  expectativa_vida = c(76, 69, 84, 75, 79)\n)\n\n# Realizando uma junção (merge) com base na coluna \"país\"\n(dados_com_demografia &lt;- merge(dados_economicos, dados_demograficos, by = \"país\"))\n\n    país continente população pib_per_capita inflação expectativa_vida\n1 Brasil    América       213          10294    0.020               75\n2  China       Ásia      1441          10380    0.040               76\n3    EUA    América       328          65741    0.010               79\n4  Índia       Ásia      1380           2353    0.060               69\n5  Japão       Ásia       126          41581    0.005               84\n\n\nPodemos combinar novas linhas de dados ao dataframe existente.\n\n# Criando outro dataframe para combinação de linhas\nmais_dados &lt;- data.frame(\n  país = c(\"África do Sul\", \"Alemanha\"),\n  continente = c(\"África\", \"Europa\"),\n  população = c(60, 83),\n  pib_per_capita = c(6151, 52947),\n  inflação = c(0.025, NA),\n  expectativa_vida = c(58, 81)\n)\n\n# Combinando os dataframes por linhas\n(todos_dados &lt;- rbind(dados_com_demografia, mais_dados))\n\n           país continente população pib_per_capita inflação expectativa_vida\n1        Brasil    América       213          10294    0.020               75\n2         China       Ásia      1441          10380    0.040               76\n3           EUA    América       328          65741    0.010               79\n4         Índia       Ásia      1380           2353    0.060               69\n5         Japão       Ásia       126          41581    0.005               84\n6 África do Sul     África        60           6151    0.025               58\n7      Alemanha     Europa        83          52947       NA               81\n\n\n\n\n\n\n\n\nDados faltantes\n\n\n\nVocê deve ter observado no dataframe mais_dados que o valor da inflação para a Alemanha está como NA. Um dado NA, abreviação de “Not Available” (não disponível), é uma marcação que indica a ausência de um valor em um conjunto de dados. No exemplo acima, a presença do dado NAna coluna de inflação para a Alemanha significa que não há um valor disponível para a inflação desse país na tabela fornecida.\nUm dado pode ser marcado como NA em diversas situações, incluindo\n\nDados ausentes: Quando não há informação disponível para um determinado campo em um conjunto de dados. Por exemplo, falta de dados sobre o índice de desemprego em determinadas regiões devido à falta de disponibilidade ou relatórios incompletos.\nErros de medição ou coleta: Em algumas situações, erros podem ocorrer durante o processo de medição ou coleta de dados, levando a valores inexatos ou ausentes. Por exemplo, ao registrar o PIB de um país, um erro humano pode levar a valores inexatos ou até mesmo ausentes em determinados trimestres devido a falhas no processo de coleta de dados.\nValores inaplicáveis: Algumas variáveis podem não ser aplicáveis a todos os casos. Por exemplo, ao analisar os gastos do governo em educação, pode não haver dados disponíveis para alguns países devido a diferenças nas políticas de relatório ou à falta de investimento em educação em determinados períodos.\nValores não registrados: Em algumas bases de dados, certos valores podem não ser registrados de propósito, seja por questões de privacidade ou por não serem relevantes para o contexto da análise. Por exemplo, ao coletar dados sobre o patrimônio líquido dos indivíduos em uma pesquisa de renda, alguns participantes podem optar por não divulgar suas informações financeiras por motivos de privacidade. Nesses casos, os valores correspondentes seriam marcados como NA."
  },
  {
    "objectID": "01-fundamentos_r.html#exercícios",
    "href": "01-fundamentos_r.html#exercícios",
    "title": "1  Fundamentos de R",
    "section": "1.7 Exercícios",
    "text": "1.7 Exercícios\n\nConsidere os seguinte setores econômico. “Financeiro”, “Tecnologia da Informação”, “Bens Industriais” e “Saúde”. Gere aleatoriamente uma amostra de tamanho 1.000, com estes setores, com igual probabilidade de cada um ser escolhido. Mostre os primeiros valores da variável resultante e conte quantas empresas pertencem a cada setor econômico."
  },
  {
    "objectID": "02-fluxos.html#estruturas-condicionais",
    "href": "02-fluxos.html#estruturas-condicionais",
    "title": "2  Fluxos de execução",
    "section": "2.1 Estruturas condicionais",
    "text": "2.1 Estruturas condicionais\nO fluxo de código em R pode ser controlado por meio de estruturas condicionais, como o if, else if e else. Essas estruturas permitem que você execute diferentes blocos de código com base em condições específicas.\n\n2.1.1 if e else\nO if é uma estrutura de controle de fluxo que executa um bloco de código se uma condição especificada for verdadeira. Se a condição for falsa, o bloco de código dentro do if não será executado. Por outro lado, o else é usado para executar um bloco de código quando a condição do if for falsa.\nA sintaxe básica do if e else em R é a seguinte:\n\nif (condição) {\n  # Bloco de código a ser executado se a condição for verdadeira\n} else {\n  # Bloco de código a ser executado se a condição for falsa\n}\n\nAqui está um exemplo prático de como usar o if e else para verificar se um número inteiro escolhido aleatóriamente entre -10 e 10 é positivo ou negativo:\n\n# Definindo a semente para garantir reprodutibilidade\nset.seed(42)\n\n# Gerando um número aleatório entre -10 e 10\nnumero &lt;- sample(-10:10, 1)\n\nif (numero &gt; 0) {\n  print(\"O número é positivo.\")\n} else {\n  print(\"O número é negativo ou zero.\")\n}\n\n[1] \"O número é positivo.\"\n\n\nNeste exemplo, sample(-10:10, 1) gera um número aleatório entre -10 e 10, e o valor é atribuído à variável numero. Além disso, set.seed(123) define a semente como 123. Isso garante que, ao gerar o número aleatório com sample(), o mesmo número seja escolhido sempre que o código for executado. Em seguida, verificamos se o número é positivo ou não e imprimimos a mensagem correspondente.\n\n\n2.1.2 else if\nAlém do if e else, também podemos usar o else if para adicionar mais condições à estrutura condicional. O else if permite verificar múltiplas condições em sequência. Se a condição do if for falsa, ele verifica a próxima condição do else if. Se todas as condições do if e else if forem falsas, o bloco de código dentro do else é executado.\nAqui está a sintaxe do else if:\n\nif (condição1) {\n  # Bloco de código a ser executado se a condição1 for verdadeira\n} else if (condição2) {\n  # Bloco de código a ser executado se a condição2 for verdadeira\n} else {\n  # Bloco de código a ser executado se nenhuma das condições anteriores for verdadeira\n}\n\nVeja um exemplo prático de como usar o if, else if e else para avaliar o desempenho de uma empresa com base em sua receita anual:\n\n# Determina a classificação da empresa com base na receita anual\nreceita_anual &lt;- 1500000\n\nif (receita_anual &gt;= 2000000) {\n  print(\"Empresa de Grande Porte\")\n} else if (receita_anual &gt;= 1000000) {\n  print(\"Empresa de Médio Porte\")\n} else if (receita_anual &gt;= 500000) {\n  print(\"Empresa de Pequeno Porte\")\n} else {\n  print(\"Microempresa\")\n}\n\n[1] \"Empresa de Médio Porte\"\n\n\nNeste exemplo, a empresa é classificada com base em sua receita anual. Se a receita for igual ou superior a 2.000.000, a empresa será classificada como “Empresa de Grande Porte”. Se estiver entre 1.000.000 e 1.999.999, será classificada como “Empresa de Médio Porte”. Se estiver entre 500.000 e 999.999, será classificada como “Empresa de Pequeno Porte”. Caso contrário, será considerada uma “Microempresa”."
  },
  {
    "objectID": "02-fluxos.html#estruturas-de-repetição",
    "href": "02-fluxos.html#estruturas-de-repetição",
    "title": "2  Fluxos de execução",
    "section": "2.2 Estruturas de repetição",
    "text": "2.2 Estruturas de repetição\nAs estruturas de repetição, também conhecidas como loops, são utilizadas para executar um bloco de código repetidamente enquanto uma condição específica for verdadeira ou para percorrer uma sequência de elementos. Isso é útil quando você precisa executar uma tarefa várias vezes ou quando deseja iterar sobre uma coleção de dados.\n\n2.2.1 for\nUma das estruturas de repetição mais comuns é o loop for. O loop for é usado para iterar sobre uma sequência de valores, como uma sequência numérica de números inteiros ou os elementos de um vetor.\nExistem duas maneiras de se usar o for loop.\n\nUsando for para iterar sobre índices:\n\n\n# Exemplo de loop for para iterar sobre índices\nfor (i in 1:5) {\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n\n\nNeste exemplo, o loop for itera sobre os valores de 1 a 5. Na primeira iteração, i é igual a 1; na segunda iteração, i é igual a 2; e assim por diante, até que i seja igual a 5.\n\nUsando for para iterar sobre elementos:\n\n\n# Exemplo de loop for para iterar sobre elementos de um vetor\nclientes &lt;- c(\"João\", \"Maria\", \"José\", \"Ana\")\nfor (nome in clientes) {\n  print(nome)\n}\n\n[1] \"João\"\n[1] \"Maria\"\n[1] \"José\"\n[1] \"Ana\"\n\n\nNeste exemplo acima, o loop for itera sobre os elementos do vetor clientes. Na primeira iteração, nome é igual a “João”; na segunda iteração, nome é igual a “Maria”; e assim por diante, até que todos os elementos do vetor sejam percorridos.\nEm ambos os exemplos, o bloco de código dentro do loop for é executado repetidamente para cada valor de i (no primeiro exemplo) ou nome (no segundo exemplo) até que a sequência seja completamente percorrida.\nNo exemplo abaixo, vamos simular dados econômicos para 10 países fictícios e calcular o PIB per capita de cada país.\n\nset.seed(42)\npib_paises &lt;- runif(10, min = 25000000, max = 40000000)\npopulacao_paises &lt;- runif(10, min = 1000000, max = 15000000)\n\npib_per_capita &lt;- numeric(length = 10)\n\n# Loop for para calcular o PIB per capita para cada pais\nfor (i in 1:10) {\n  # Calculando o PIB per capita\n  pib_per_capita[i] &lt;- pib_paises[i] / populacao_paises[i]\n}\nprint(round(pib_per_capita, 3))\n\n [1]  5.227  3.529  2.080  8.185  4.634  2.315  2.453 10.216  4.556  4.022\n\n\n\n\n\n\n\n\nClique e veja um exemplo extra\n\n\n\n\n\nImagine que temos uma série temporal representando o preço de fechamento diário de uma ação ao longo de um período de 30 dias. Queremos calcular a média móvel de 5 dias desse preço, ou seja, para cada dia, queremos calcular a média dos preços de fechamento dos cinco dias anteriores, incluindo o dia atual.\nPrimeiro, vamos simular os dados do preço de fechamento diário da ação:\n\nset.seed(42)\npreco_acao &lt;- runif(30, min = 9, max = 15)\n\nAgora, vamos calcular a média móvel de 5 dias usando um loop for:\n\nmedia_movel &lt;- numeric(length = 26)  # Vetor para armazenar a média móvel\n\nfor (i in 5:30) {\n  media_movel[i - 4] &lt;- mean(preco_acao[(i - 4):i])\n}\n\nNeste loop for, começamos a partir do quinto dia, pois precisamos de pelo menos cinco dias para calcular a média móvel de 5 dias. Para cada dia a partir do quinto dia até o trigésimo dia, calculamos a média dos preços de fechamento dos cinco dias anteriores, incluindo o dia atual, e armazenamos esse valor no vetor media_movel.\nAgora, podemos imprimir a média móvel calculada:\n\nprint(media_movel)\n\n [1] 13.33226 12.85740 12.61682 12.43505 12.22691 12.30289 12.22926 12.20829\n [9] 13.16830 12.68642 12.39510 12.97382 13.28476 12.30414 12.56762 12.68527\n[17] 12.64209 11.63467 12.68036 13.24636 12.67289 12.20510 12.50690 12.40711\n[25] 11.80747 12.71175\n\n\nEste exemplo demonstra como usar um loop for em conjunto com vetores para calcular a média móvel de uma série temporal. O gráfico abaixo mostra a média móvel ao longo dos dias.\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nVocê vai aprender a construir gráficos como este no Capítulo 4.\n\n\n\n\n\n\n\n2.2.2 while\nA estrutura while é usada para repetir um bloco de código enquanto uma condição especificada for verdadeira. Aqui está a estrutura geral de um loop while:\n\nwhile (condição) {\n  # Código a ser repetido enquanto a condição for verdadeira\n}\n\nA condição é uma expressão lógica que é avaliada antes de cada execução do bloco de código dentro do loop. Se a condição for verdadeira, o bloco de código é executado; se a condição for falsa, o loop é interrompido e o controle é passado para a próxima linha de código após o loop.\nNo exemplo abaixo, vamos definir um vetor chamado acoes, que contém uma lista de atividades possíveis que uma pessoa pode realizar durante o dia. Dentre as ações possíveis, uma será escolhida aleatoriamente.\n\nacoes &lt;- c( \"Aprender a programar em R\",\n        \"Aprender a programar em Python\",\n        \"Fazer um café\",\n        \"Descansar\")\n\nset.seed(42)\nacao &lt;- sample(acoes, 1)\nprint(acao)\n\n[1] \"Aprender a programar em R\"\n\n\nNo trecho de código a seguir, usamos a estrutura while para continuar selecionando aleatoriamente uma atividade do vetor acoes até que a atividade selecionada seja “Descansar”. O loop começa verificando se a variável acao é diferente de “Descansar”. Se essa condição for verdadeira, uma nova atividade é selecionada aleatoriamente do vetor acoes usando a função sample() com size = 1, o que significa que estamos selecionando apenas um elemento aleatório do vetor. Em seguida, a atividade selecionada é impressa na tela usando a função print(). Esse processo se repete até que a atividade selecionada seja “Descansar”, momento em que o loop é encerrado.\n\nset.seed(420)\nwhile(acao != \"Descansar\") {\n  acao &lt;- sample(acoes, 1)\n  print(acao)\n}\n\n[1] \"Aprender a programar em R\"\n[1] \"Aprender a programar em R\"\n[1] \"Aprender a programar em Python\"\n[1] \"Aprender a programar em Python\"\n[1] \"Descansar\"\n\n\n\n\n\n\n\n\nClique e veja um exemplo extra\n\n\n\n\n\nVamos considerar um exemplo onde queremos simular a evolução de uma população ao longo do tempo, onde não sabemos exatamente quantos períodos serão necessários para que a população atinja um determinado limite. Neste caso, usaremos um loop while para continuar simulando o crescimento populacional até que a população alcance um certo valor limite.\n\nset.seed(42)  # Define uma semente para a replicabilidade dos resultados\n\n# População inicial\npopulacao &lt;- 1000\n\n# Taxa de crescimento anual da população (em decimal)\ntaxa_crescimento &lt;- 0.02\n\n# População limite desejada\nlimite_populacional &lt;- 2000\n\n# Inicializando o contador de anos\nanos &lt;- 0\n\n# Simulando o crescimento populacional até atingir o limite\nwhile (populacao &lt; limite_populacional) {\n  # Calculando o número de novos indivíduos neste ano\n  novos_individuos &lt;- populacao * taxa_crescimento\n  \n  # Incrementando a população com os novos indivíduos\n  populacao &lt;- populacao + novos_individuos\n  \n  # Incrementando o contador de anos\n  anos &lt;- anos + 1\n}\n\n# Imprimindo o número de anos necessários para atingir o limite populacional\nprint(paste(\"Foram necessários\", anos, \"anos para atingir uma população de\", populacao))\n\n[1] \"Foram necessários 36 anos para atingir uma população de 2039.8873437157\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nÉ possível calcular diretamente o número de anos necessários para atingir a população limite desejada. Com um pouco de álgebra você chege na seguinte fórmula para calcular o número de anos: \\[\\text{anos} = \\frac{\\log\\left(\\frac{\\text{limite\\_populacional}}{\\text{populacao\\_inicial}}\\right)}{\\log(1 + \\text{taxa\\_crescimento})}.\\]"
  },
  {
    "objectID": "02-fluxos.html#teste2",
    "href": "02-fluxos.html#teste2",
    "title": "2  Fluxos de execução",
    "section": "2.3 teste2",
    "text": "2.3 teste2"
  },
  {
    "objectID": "02-fluxos.html#while",
    "href": "02-fluxos.html#while",
    "title": "2  Fluxos de execução",
    "section": "2.3 while",
    "text": "2.3 while\nA estrutura while é usada para repetir um bloco de código enquanto uma condição especificada for verdadeira. Aqui está a estrutura geral de um loop while:\n\nwhile (condição) {\n  # Código a ser repetido enquanto a condição for verdadeira\n}\n\nA condição é uma expressão lógica que é avaliada antes de cada execução do bloco de código dentro do loop. Se a condição for verdadeira, o bloco de código é executado; se a condição for falsa, o loop é interrompido e o controle é passado para a próxima linha de código após o loop.\nNo exemplo abaixo, vamos definir um vetor chamado acoes, que contém uma lista de atividades possíveis que uma pessoa pode realizar durante o dia. Dentre as ações possíveis, uma será escolhida aleatoriamente.\n\nacoes &lt;- c( \"Aprender a programar em R\",\n        \"Aprender a programar em R\",\n        \"Fazer um café\",\n        \"Descansar\")\n\nset.seed(42)\nacao &lt;- sample(acoes, 1)\nprint(acao)\n\n[1] \"Aprender a programar em R\"\n\n\nNo trecho de código a seguir, usamos a estrutura while para continuar selecionando aleatoriamente uma atividade do vetor acoes até que a atividade selecionada seja “Descansar”. O loop começa verificando se a variável acao é diferente de “Descansar”. Se essa condição for verdadeira, uma nova atividade é selecionada aleatoriamente do vetor acoes usando a função sample() com size = 1, o que significa que estamos selecionando apenas um elemento aleatório do vetor. Em seguida, a atividade selecionada é impressa na tela usando a função print(). Esse processo se repete até que a atividade selecionada seja “Descansar”, momento em que o loop é encerrado.\n\nwhile(acao != \"Descansar\") {\n  acao &lt;- sample(acoes, 1)\n  print(acao)\n}\n\n[1] \"Aprender a programar em R\"\n[1] \"Aprender a programar em R\"\n[1] \"Aprender a programar em R\"\n[1] \"Aprender a programar em R\"\n[1] \"Descansar\"\n\n\n\n\n\n\n\n\nClique e veja um exemplo extra\n\n\n\n\n\nVamos considerar um exemplo onde queremos simular a evolução de uma população ao longo do tempo, onde não sabemos exatamente quantos períodos serão necessários para que a população atinja um determinado limite. Neste caso, usaremos um loop while para continuar simulando o crescimento populacional até que a população alcance um certo valor limite.\n\nset.seed(42)  # Define uma semente para a replicabilidade dos resultados\n\n# População inicial\npopulacao &lt;- 1000\n\n# Taxa de crescimento anual da população (em decimal)\ntaxa_crescimento &lt;- 0.02\n\n# População limite desejada\nlimite_populacional &lt;- 2000\n\n# Inicializando o contador de anos\nanos &lt;- 0\n\n# Simulando o crescimento populacional até atingir o limite\nwhile (populacao &lt; limite_populacional) {\n  # Calculando o número de novos indivíduos neste ano\n  novos_individuos &lt;- populacao * taxa_crescimento\n  \n  # Incrementando a população com os novos indivíduos\n  populacao &lt;- populacao + novos_individuos\n  \n  # Incrementando o contador de anos\n  anos &lt;- anos + 1\n}\n\n# Imprimindo o número de anos necessários para atingir o limite populacional\nprint(paste(\"Foram necessários\", anos, \"anos para atingir uma população de\", populacao))\n\n[1] \"Foram necessários 36 anos para atingir uma população de 2039.8873437157\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nÉ possível calcular diretamente o número de necessários para atingir a população limite desejada. Com um pouco de álgebra você chege na seguinte fórmula para calcular o número de anos: \\[\\text{anos} = \\frac{\\log\\left(\\frac{\\text{limite\\_populacional}}{\\text{populacao\\_inicial}}\\right)}{\\log(1 + \\text{taxa\\_crescimento})}.\\]"
  },
  {
    "objectID": "02-fluxos.html#exercícios",
    "href": "02-fluxos.html#exercícios",
    "title": "2  Fluxos de execução",
    "section": "2.5 Exercícios",
    "text": "2.5 Exercícios\n1. Neste exercício, vamos simular o lançamento de uma moeda e armazenar os resultados como um fator contendo os níveis “cara” e “coroa”. Para isso, siga os passos abaixo:\na) Utilize o comando abaixo para gerar amostras aleatórias seguindo a distribuição binomial para simular o lançamento de 100 moedas:\n\nset.seed(42)\nlancamentos &lt;- rbinom(100, 1, 0.5)\n\nb) Considere que 0 represente “cara” e 1 represente “coroa”. Crie uma variável para armazenar os lançamentos como um fator contendo os níveis “cara” e “coroa”.\nc) Conte quantas vezes cada um dos resultados ocorreu neste experimento.\nd) Utilize um loop para percorrer o vetor de traz para frente e descubra qual foi o último lançamento que resultado em uma “cara”.\n2. Trabalhando com dados de pacotes.\na) Instale o pacote nycflights13 utilizando o comando abaixo:\n\ninstall.packages(\"nycflights13\")\n\nb) Carregue no seu ambiente o pacote instalado:\n\nlibrary(nycflights13)\n\nc) Utilizando os comandos abaixo, verifique o conteúdo dos dataframes flights e airports:\n\n?flights\n?airports\n\nd) Filtre os voos que aconteceram em 25/01/2013 e armazene-os na variável natal;\ne) Quantos voos partiram de Nova Iorque em 25/12/2013?\nf) Obtenha um sumário da coluna dep_delay. Há dados faltantes? Se sim, remova-os.\ng) Obtenha o nome do aeroporto de destino do voo com maior atraso de partida em 25/12/2013. Dica: mescle os dados de flights e airports."
  },
  {
    "objectID": "03-dados.html#importar-arquivos-externos",
    "href": "03-dados.html#importar-arquivos-externos",
    "title": "3  Manipulação de dados",
    "section": "3.1 Importar arquivos externos",
    "text": "3.1 Importar arquivos externos\nDois dos formatos mais comuns para armazenamento de dados não tão grandes são csv e xlsx.\nAo carregar dados de arquivos csv em R, duas opções comumente utilizadas são as funções read.csv() e read_csv(). Ambas são eficazes para importar dados tabulares, mas apresentam diferenças significativas. A função read.csv() é uma opção padrão no R base, sendo simples de usar e amplamente conhecida. Por outro lado, read_csv() faz parte do pacote readr, oferecendo desempenho otimizado e detecção automática de tipos de dados. Enquanto read.csv() tende a ser mais lenta, especialmente com grandes conjuntos de dados, read_csv() é mais rápida e precisa, sendo capaz de manter os nomes das colunas como símbolos e converter adequadamente os dados, inclusive lidando com strings vazias.\n\n# Usando read.csv()\ndados_read_csv &lt;- read.csv(\"dados.csv\")\n\n# Usando read_csv() do pacote readr\nlibrary(readr)\ndados_readr &lt;- read_csv(\"dados.csv\")\n\nPara importar dados de um arquivo Excel (formato xlsx) em R, podemos usar a biblioteca readxl. Primeiro, é necessário instalá-la usando o comando install.packages(\"readxl\"). Em seguida, podemos usar a função read_excel() para ler os dados. Por exemplo:\n\nlibrary(readxl)\ndados &lt;- read_excel(\"arquivo.xlsx\")\n\n\n\n\n\n\n\nDefinindo o seu diretório de trabalho\n\n\n\nÉ uma boa prática definir um diretório de trabalho em seus scripts R porque isso ajuda a manter a organização e facilita o acesso aos arquivos de dados e resultados. Ao definir um diretório de trabalho, você garante que todos os arquivos referenciados em seus scripts serão encontrados facilmente, sem a necessidade de especificar caminhos absolutos longos.\nPara definir o diretório de trabalho no R, você pode usar a função setwd(). Por exemplo, se você deseja definir o diretório como “C:/MeuDiretorio”, você pode fazer o seguinte:\n\nsetwd(\"C:/MeuDiretorio\")\n\nVocê pode definir o diretório usando a interface do RStudio. Basta selecionar no menu “Session” a opção “Set Working Directory” e em seguida “Choose Directory”. Isso abrirá uma caixa de diálogo onde você pode navegar até o diretório desejado e selecioná-lo. Depois de selecionar o diretório, ele se tornará o diretório de trabalho atual."
  },
  {
    "objectID": "03-dados.html#o-pacote-tidyverse",
    "href": "03-dados.html#o-pacote-tidyverse",
    "title": "3  Manipulação de dados",
    "section": "3.2 O pacote tidyverse",
    "text": "3.2 O pacote tidyverse\nO pacote tidyverse é uma coleção de pacotes do R projetados para trabalhar de forma integrada e intuitiva na análise de dados. Ele inclui uma variedade de pacotes poderosos e populares, como ggplot2, dplyr, tidyr, tibble, readr, purrr, forcats e stringr. Cada pacote no tidyverse foi projetado para lidar com uma etapa específica do fluxo de trabalho de análise de dados, desde a importação e limpeza até a visualização e modelagem. Todos os pacotes no tidyverse compartilham uma filosofia de design subjacente, gramática e estruturas de dados, veja mais na página do pacote."
  },
  {
    "objectID": "04-visualizacao.html",
    "href": "04-visualizacao.html",
    "title": "4  Visualização de dados",
    "section": "",
    "text": "5 Exercícios\nVamos utilizar os dados da Billboard que foram apresentados na ?sec-ex-dados.\na) O gráfico abaixo mostra o histórico de cada musica no ranking ao longo das semanas. Qual o código para obter o gráfico abaixo?\nb)\nc) O gráfico abaixo mostra o histórico de duas músicas: “Higher” e “With Arms Wide Open”."
  },
  {
    "objectID": "02-fluxos.html#funções",
    "href": "02-fluxos.html#funções",
    "title": "2  Fluxos de execução",
    "section": "2.3 Funções",
    "text": "2.3 Funções\nUma função em R é um bloco de código que realiza uma tarefa específica e pode ser reutilizado várias vezes. A sintaxe para definir uma função em R segue o padrão:\n\nnome_da_funcao &lt;- function(parametros) {\n  # Corpo da função\n  # Código que realiza a tarefa desejada\n  # Pode incluir operações matemáticas, manipulação de dados, etc.\n  return(resultado)  # Retorna o resultado desejado\n}\n\nOs parâmetros são variáveis que uma função recebe como entrada para executar suas operações. Eles são especificados entre parênteses na definição da função. Dentro do corpo da função, os parâmetros podem ser utilizados para realizar cálculos ou operações.\nO exemplo abaixo define uma função para realizar uma regressão linear simples. A função regressao_linear recebe dois parâmetros: x e y, que representam os dados de entrada para a regressão linear. Dentro da função, um modelo de regressão linear é criado usando a função lm() do R com os dados y em função de x. A documentação da função lm() pode ser acessada ao executar o comando ?lm. O modelo resultante é retornado como resultado da função.\n\n# Função para realizar regressão linear simples\nregressao_linear &lt;- function(x, y) {\n  modelo &lt;- lm(y ~ x)  # Criando o modelo de regressão linear\n  return(modelo)  # Retornando o modelo\n}\n\n# Dados de exemplo: salário (y) em função dos anos de educação (x)\nanos_educacao &lt;- c(10, 12, 14, 16, 18)\nsalario &lt;- c(2500, 3300, 3550, 3700, 4500)\n\n# Chamando a função de regressão linear\nmodelo_regressao &lt;- regressao_linear(anos_educacao, salario)\n\nVeja o sumário com o resultado do modelo treinado.\n\n# Exibindo os resultados da regressão\nsummary(modelo_regressao)\n\n\nCall:\nlm(formula = y ~ x)\n\nResiduals:\n   1    2    3    4    5 \n-130  230   40 -250  110 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)   \n(Intercept)   430.00     498.20   0.863  0.45156   \nx             220.00      34.88   6.307  0.00805 **\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 220.6 on 3 degrees of freedom\nMultiple R-squared:  0.9299,    Adjusted R-squared:  0.9065 \nF-statistic: 39.78 on 1 and 3 DF,  p-value: 0.008054\n\n\nA figura abaixo mostra um gráfico de dispersão que representa a relação entre anos de educação e salário. A reta azul mostra o modelo de regressão linear treinado com os dados.\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nVocê vai aprender a construir gráficos como este no Capítulo 4."
  },
  {
    "objectID": "02-fluxos.html#sec-pacotes",
    "href": "02-fluxos.html#sec-pacotes",
    "title": "2  Fluxos de execução",
    "section": "2.4 Pacotes",
    "text": "2.4 Pacotes\nOs pacotes no R são conjuntos de funções, conjuntos de dados e documentação que ampliam as capacidades básicas da linguagem R. Eles são essenciais para expandir a funcionalidade do R, permitindo que os usuários realizem uma ampla variedade de tarefas.\nOs pacotes do R estão disponíveis no CRAN (Comprehensive R Archive Network), um repositório centralizado que abriga uma vasta coleção de pacotes, manuais, documentações e outros recursos relacionados ao R. O CRAN é essencialmente o principal hub para distribuição de pacotes R e serve como uma fonte confiável e abrangente de ferramentas para análise de dados, estatísticas e muito mais. Para acessar os pacotes do CRAN, você pode usar a função install.packages(). Por exemplo:\n\ninstall.packages(\"nome_do_pacote\")\n\nDepois de instalar um pacote, você precisa carregá-lo em sua sessão R usando a função library():\n\nlibrary(nome_do_pacote)\n\nIsso tornará as funções e conjuntos de dados do pacote disponíveis para uso em sua sessão atual."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introdução à R e Python",
    "section": "",
    "text": "Introdução\nEste livro consiste em notas de aula do minicurso de Introdução às Linguagens de Programação R e Python.\nSe você está interessado nos fundamentos da linguagem R, você pode encontrar esses tópicos na primeira parte do livro. Por outro lado, se deseja explorar os fundamentos de Python, a segunda parte é onde você encontrará essas informações.\nEste é um livro em constante evolução, projetado para crescer e se adaptar. Se você tiver alguma sugestão ou feedback sobre o conteúdo apresentado, sinta-se à vontade para enviar um e-mail para magnotairone[at]gmail.com.\nMeus sinceros agradecimentos a Luiza pela revisão do conteúdo deste livro."
  },
  {
    "objectID": "04-visualizacao.html#gramática-dos-gráficos",
    "href": "04-visualizacao.html#gramática-dos-gráficos",
    "title": "4  Visualização de dados",
    "section": "4.1 Gramática dos Gráficos",
    "text": "4.1 Gramática dos Gráficos\nEle é baseado na gramática dos gráficos (grammar of graphics - GG), veja Wilkinson (2012). A gramática dos gráficos é um conjunto de princípios e conceitos que descrevem a estrutura e as regras para criar gráficos de forma consistente e eficaz. A GG é um framework para visualização de dados que desmembra cada componente de um gráfico em elementos individuais, criando camadas distintas. Usando o sistema GG, podemos construir gráficos passo a passo para obter resultados flexíveis e personalizáveis. Cada aspecto do gráfico, como pontos, linhas, cores e escalas, é tratado como uma peça separada, permitindo um controle detalhado sobre a aparência e o conteúdo do gráfico final.\n\n\n\nFigura de Wilkinson (2012)."
  },
  {
    "objectID": "04-visualizacao.html#o-pacote-ggplot",
    "href": "04-visualizacao.html#o-pacote-ggplot",
    "title": "4  Visualização de dados",
    "section": "4.2 O pacote ggplot",
    "text": "4.2 O pacote ggplot\nO pacote mais conhecido de visualização de dados em R é o ggplot2, que é baseado na gramática dos gráficos. O ggplot2 permite criar uma ampla variedade de gráficos, incluindo gráficos de dispersão, linhas, barras, histogramas, entre outros, de forma simples e flexível. Com o ggplot2, você pode personalizar praticamente todos os aspectos do gráfico, desde a forma e a cor dos pontos até a escala dos eixos e a aparência do plano de fundo.\nPara exemplificar o uso do ggplot, vamos considerar os dados gapminder, Rosling (2012).\n\n4.2.1 Dados\nA função ggplot() inicializa um gráfico ggplot2 e define os dados que serão usados.\n\nlibrary(tidyverse)\nlibrary(gapminder)\n\ngapminder_2007 &lt;- gapminder %&gt;% \n  filter(year == 2007)\n\nggplot(data = gapminder_2007)\n\n\n\n\n\n\n\n\n\n\nO gráfico gerado também não está errado!\n\n\n\nEsse código cria um gráfico utilizando os dados do gapminder apenas para o ano de 2007. Apenas isso. Não há instruções extras sobre o que exibir em cada eixo (estética do gráfico).\n\n\n\n\n4.2.2 Estética\nO mapeamento estético (aes) no ggplot2 é uma função que permite vincular variáveis de um conjunto de dados às propriedades visuais de um gráfico, como cor, forma, tamanho e posição. Por meio do mapeamento estético, podemos controlar como os dados são representados visualmente no gráfico.\nPor exemplo, ao criar um gráfico de dispersão, podemos mapear a variável x (horizontal) e a variável y (vertical) do conjunto de dados às coordenadas do gráfico.\n\nggplot(data = gapminder_2007, \n       mapping = aes(x = gdpPercap, y = lifeExp))\n\n\n\n\n\n\n\n\n\n\nO gráfico gerado também não está errado!\n\n\n\nEsse código define um gráfico de dispersão utilizando os dados do gapminder apenas para o ano de 2007. O eixo x representa o PIB per capita (gdpPercap) e o eixo y representa a expectativa de vida (lifeExp). Apenas isso. Não há instruções extra no techo de código sobre o fomato (geometria) que deve ser usado para exibir os dados.\n\n\n\n\n4.2.3 Geometria\nA geometria refere-se aos elementos visuais que compõem um gráfico, como pontos, linhas, barras e áreas. Cada tipo de gráfico tem sua própria geometria correspondente, e é especificada pela função geom_*, seguida pelo tipo de geometria desejado.\nPor exemplo, para criar um gráfico de dispersão, usamos a geometria geom_point(), enquanto para criar um gráfico de barras, usamos a geometria geom_bar().\n\nggplot(data = gapminder_2007, \n       mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point()\n\n\n\n\nCada geometria tem seus próprios parâmetros específicos que podem ser ajustados para personalizar a aparência do gráfico, como cor, tamanho, preenchimento e transparência.\n\n\n\n\n\n\nAdicionando uma estética de cores no gráfico\n\n\n\nVeja que para colorir cada ponto do gráfico de dispersão de acordo com o continente, basta adicionar no mapeamento estético color = continent.\n\nggplot(data = gapminder_2007, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point()\n\n\n\n\n\n\n\n4.2.3.1 Outras geometrias\nAbaixo, mostramos outras possíveis geometrias. Algumas alterações foram feitas na forma como as funções do ggplot são usadas. Propositalmente não foi adicionado texto descritivoos pois essas alterações devem ser fáceis de interpretar.\ngeom_line():\n\n# Filtrar dados para o Brasil\ndados_pais &lt;- gapminder %&gt;%\n  filter(country == \"Brazil\")\n\n# Criar gráfico de linha\nggplot(data = gapminder %&gt;%\n         filter(country == \"Brazil\"), \n       aes(x = year, y = lifeExp)) +\n  geom_line()\n\n\n\n\ngeom_bar():\n\n# Criar gráfico de barras\nggplot(data = gapminder_2007, aes(x = continent, y = gdpPercap)) +\n  geom_bar(stat = \"summary\", fun = \"mean\")\n\n\n\n\ngeom_boxplot():\n\nggplot(data = gapminder_2007, aes(x = continent, y = lifeExp)) +\n  geom_boxplot()\n\n\n\n\ngeom_text():\n\ngapminder_2007 %&gt;% \n  group_by(continent) %&gt;% \n  summarise(mean_lifeExp = mean(lifeExp),\n            mean_gdpPercap = mean(gdpPercap)) %&gt;% \n  ggplot(aes(x = mean_gdpPercap, y = mean_lifeExp, label = continent)) +\n  geom_point() +\n  geom_text(vjust = -0.5, hjust = 0.5)\n\n\n\n\nNote que estamos combinando duas geometrias em um único gráfico (ponto e texto). Os rótulos de texto são adicionados aos pontos usando a geometria geom_text(), com os parâmetros vjust e hjust definindo a posição vertical e horizontal do texto, respectivamente:\n\no parâmetro vjust ajusta o alinhamento vertical do texto em relação ao ponto. Um valor negativo (-0.5, por exemplo) move o texto acima do ponto, enquanto um valor positivo move o texto abaixo do ponto.\no parâmetro hjust ajusta o alinhamento horizontal do texto em relação ao ponto. Um valor de 0.5 centraliza o texto horizontalmente em relação ao ponto.\n\n\n\n\n4.2.4 Facetas\nAs facetas (facet) referem-se à capacidade de dividir um gráfico em múltiplas visualizações com base em uma ou mais variáveis categóricas. Isso permite comparar as relações entre variáveis em diferentes segmentos dos dados.\nAs facetas são adicionadas usando a função facet_wrap() para criar uma matriz de painéis com base em uma variável categórica ou facet_grid() para criar uma grade de painéis com base em duas variáveis categóricas.\nPor exemplo, podemos usar facetas para criar um gráfico de dispersão separado para dois anos distintos, permitindo comparar as relações entre o PIB per capta e a expectativa de vida nesses dois anos.\n\ngapminder_anos &lt;- gapminder %&gt;% \n  filter(year == 1952 | year == 2007)\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  facet_wrap(~year)\n\n\n\n\n\n\n4.2.5 Coordenadas\nAs coordenadas em ggplot2 determinam como os dados são mapeados em um espaço gráfico. Isso inclui a escala dos eixos x e y, bem como qualquer transformação ou ajuste aplicado aos dados. As coordenadas afetam a aparência geral do gráfico, incluindo sua orientação, proporção e escala.\nPara definir limites nos eixos x e y, podemos usar a função coord_cartesian() para controlar quais intervalos de valores são exibidos no gráfico. Isso é útil quando queremos focar em uma parte específica dos dados ou evitar que outliers influenciem a escala dos eixos.\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  facet_wrap(~year) +\n  coord_cartesian(ylim = c(40, 83))\n\n\n\n\nÉ possível aplicar a escala logarítmica aos eixos também. Isso é útil quando os dados têm uma ampla variação de valores e estamos interessados em destacar diferenças em uma ampla gama de valores, como em dados de renda ou PIB. Para fazer isso, basta utilizar a função scale_*_log10():\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  facet_wrap(~year) +\n  scale_x_log10()\n\n\n\n\n\n\n4.2.6 Temas\nOs temas controlam os aspectos visuais dos gráficos, como títulos, legendas, eixos e cores de fundo. Os temas pré-definidos, como theme_bw(), theme_minimal(), theme_classic() etc., oferecem estilos visuais consistentes que podem ser aplicados aos gráficos para obter uma aparência específica.\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  facet_wrap(~year) +\n  scale_x_log10() +\n  theme_bw()\n\n\n\n\n\n\n\n\n\n\nTente também\n\n\n\nApague a última linha do exemplo acima, digite theme_, aperte a tecla tab e experimente os diferentes temas pré-definidos no ggplot.\n\n\nAlém disso, podemos definir praticamente todos os aspectos do gráfico. Por exemplo, para trocar a posição da legenda para baixo, podemos usar a função theme(legend.position = \"bottom\"). Para alterar o tamanho da fonte, podemos usar a função theme(text = element_text(size = 12)). Essas definições podem ser combinadas em uma única chamada da função theme(), veja abaixo.\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  facet_wrap(~year) +\n  scale_x_log10() +\n  theme_bw() +\n  theme(legend.position = \"bottom\", \n        text = element_text(size = 12))\n\n\n\n\n\n\n4.2.7 Personalização e Estilização de Gráficos\nA função labs() é responsável por personalizar rótulos e títulos em gráficos. No exemplo abaixo, renomeamos os eixos x e y e atribuimos um nome mais descritivo para a legenda de cores, que neste caso representa o continente.\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point() +\n  facet_wrap(~year) +\n  scale_x_log10() +\n  labs(x = \"PIB per capita (log)\", \n       y = \"Expectativa de vida\", \n       color = \"Continente\", \n       title = \"Relação entre PIB per capita e Expectativa de Vida\") +\n  theme_bw() +\n  theme(legend.position = \"bottom\")\n\n\n\n\nO parâmetro alpha controla a opacidade dos elementos geométricos, variando de 0 a 1. Por exemplo, geom_point(alpha = 0.5) torna os pontos semi-transparentes, o que pode ser útil para visualizar sobreposições de dados em um gráfico de dispersão.\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point(alpha = 0.5) +\n  facet_wrap(~year) +\n  scale_x_log10() +\n  labs(x = \"PIB per capita (log)\", \n       y = \"Expectativa de vida\", \n       color = \"Continente\", \n       title = \"Relação entre PIB per capita e Expectativa de Vida\")\n\n\n\n\nPara escolher cores específicas para os níveis de uma variável categórica, podemos utilizar a função scale_color_manual() para atribuir manualmente cores a cada nível da variável.\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point(alpha = 0.5) +\n  facet_wrap(~year) +\n  scale_x_log10() +\n  scale_color_manual(values = c(\"blue\", \"green\", \"orange\", \"purple\", \"red\"))+\n  labs(x = \"PIB per capita (log)\", \n       y = \"Expectativa de vida\", \n       color = \"Continente\", \n       title = \"Relação entre PIB per capita e Expectativa de Vida\")\n\n\n\n\n\n\n\n\n\n\nOutras paletas de cores\n\n\n\nVocê pode usar paletas de cores do pacote RColorBrewer usando a função scale_color_brewer().\n\nggplot(data = gapminder_anos, \n       mapping = aes(x = gdpPercap, y = lifeExp, color = continent)) +\n  geom_point(alpha = 0.5) +\n  facet_wrap(~year) +\n  scale_x_log10() +\n  scale_color_brewer(palette = \"Set1\")+\n  labs(x = \"PIB per capita (log)\", \n       y = \"Expectativa de vida\", \n       color = \"Continente\", \n       title = \"Relação entre PIB per capita e Expectativa de Vida\")\n\n\n\n\nA vantagem de usar as paletas de cores do RColorBrewer é que elas foram cuidadosamente projetadas para serem perceptualmente distintas e adequadas para representar diferentes grupos ou categorias em gráficos. Isso significa que as cores em uma paleta são mais facilmente distinguíveis umas das outras, mesmo quando impressas em preto e branco ou quando vistas por pessoas com deficiências visuais. Veja todas paletas disponíves aqui"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "McKinney, Wes. 2022. Python for Data Analysis. \" O’Reilly\nMedia, Inc.\".\n\n\nRosling, Hans. 2012. “Data - Gapminder.org.” http://www.gapminder.org/data/.\n\n\nWilkinson, Leland. 2012. The Grammar of Graphics. Springer."
  },
  {
    "objectID": "04-visualizacao.html#o-pacote-ggthemes",
    "href": "04-visualizacao.html#o-pacote-ggthemes",
    "title": "4  Visualização de dados",
    "section": "4.3 O pacote ggthemes",
    "text": "4.3 O pacote ggthemes\ndocumentação aqui.\n\n\n\n\nRosling, Hans. 2012. “Data - Gapminder.org.” http://www.gapminder.org/data/.\n\n\nWilkinson, Leland. 2012. The Grammar of Graphics. Springer."
  },
  {
    "objectID": "04-visualizacao.html#extra",
    "href": "04-visualizacao.html#extra",
    "title": "4  Visualização de dados",
    "section": "4.3 Extra",
    "text": "4.3 Extra\n\n4.3.1 O pacote patchwork\nO pacote patchwork é usada para combinar múltiplos gráficos ggplot2 em uma única visualização. Ele permite criar layouts flexíveis e complexos, adicionando, organizando e ajustando gráficos individualmente.\n\n# Instalar o pacote patchwork (apenas se ainda não estiver instalado)\ninstall.packages(\"patchwork\")\n\nDepois de carregar o pacote, você pode usar o operador + para combinar gráficos ggplot2 em uma única visualização.\nAqui está um exemplo simples criando dois gráficos separados e, em seguida, são combinados usando o patchwork:\n\nlibrary(patchwork)\n\nplot1 &lt;- ggplot(data = gapminder_2007, \n       mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) +\n  labs(x = \"PIB per capita (log)\", \n       y = \"Expectativa de vida em 2007\", \n       title = \"Relação entre PIB per capita e Expectativa de Vida\") +\n  theme_classic()\n\nplot2 &lt;- ggplot(data = gapminder_2007, \n       mapping = aes(lifeExp)) +\n  geom_histogram() +\n  labs(title = \"Histograma da expectativa de vida\",\n       x = \"Expectativa de Vida em 2007\", \n       y = \"Frequência\") +\n  theme_classic()\n\nplot1 + plot2\n\n\n\n\n\n\n4.3.2 O pacote ggthemes\nO pacote ggthemes é uma extensão do ggplot2 que fornece uma variedade de temas pré-definidos para personalizar a aparência dos gráficos. Veja a documentação aqui.\n\n# Instalar o pacote ggthemes (apenas se ainda não estiver instalado)\ninstall.packages(\"ggthemes\")\n\nDepois de carregar o pacote, você pode aplicar qualquer um dos temas disponíveis aos seus gráficos ggplot2 usando a função theme_*(). No exemplo abaixo, são criadas três versões do mesmo gráfico com temas diferentes. Os operadores + e / foram usados para definir como os gráficos serão exibidos.\n\n# Carregar o pacote ggthemes\nlibrary(ggthemes)\n\nWarning: package 'ggthemes' was built under R version 4.2.3\n\nplot0 &lt;- ggplot(data = gapminder_2007, \n       mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) +\n  labs(x = \"PIB per capita (log)\", \n       y = \"Expectativa de vida em 2007\")\n\nplot1 &lt;- plot0 + theme_economist()\nplot2 &lt;- plot0 + theme_excel()\nplot3 &lt;- plot0 + theme_stata()\n\nplot1 +  (plot2 / plot3)\n\n\n\n\n\n\n\n\nRosling, Hans. 2012. “Data - Gapminder.org.” http://www.gapminder.org/data/.\n\n\nWilkinson, Leland. 2012. The Grammar of Graphics. Springer."
  },
  {
    "objectID": "04-visualizacao.html#pacotes-extras",
    "href": "04-visualizacao.html#pacotes-extras",
    "title": "4  Visualização de dados",
    "section": "4.3 Pacotes extras",
    "text": "4.3 Pacotes extras\nExistem alguns pacotes extras que funcionam como extensões do ggplot2. Apresentamos alguns nessa seção.\n\n4.3.1 O pacote patchwork\nO pacote patchwork é usada para combinar múltiplos gráficos ggplot2 em uma única visualização. Ele permite criar layouts flexíveis e complexos, adicionando, organizando e ajustando gráficos individualmente.\n\n# Instalar o pacote patchwork (apenas se ainda não estiver instalado)\ninstall.packages(\"patchwork\")\n\nDepois de carregar o pacote, você pode usar o operador + para combinar gráficos ggplot2 em uma única visualização.\nAqui está um exemplo simples criando dois gráficos separados e, em seguida, são combinados usando o patchwork:\n\nlibrary(patchwork)\n\nplot1 &lt;- ggplot(data = gapminder_2007, \n       mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) +\n  labs(x = \"PIB per capita (log)\", \n       y = \"Expectativa de vida em 2007\", \n       title = \"Relação entre PIB per capita e Expectativa de Vida\") +\n  theme_classic()\n\nplot2 &lt;- ggplot(data = gapminder_2007, \n       mapping = aes(lifeExp)) +\n  geom_histogram() +\n  labs(title = \"Histograma da expectativa de vida\",\n       x = \"Expectativa de Vida em 2007\", \n       y = \"Frequência\") +\n  theme_classic()\n\nplot1 + plot2\n\n\n\n\n\n\n4.3.2 O pacote ggthemes\nO pacote ggthemes é uma extensão do ggplot2 que fornece uma variedade de temas pré-definidos para personalizar a aparência dos gráficos. Veja a documentação aqui.\n\n# Instalar o pacote ggthemes (apenas se ainda não estiver instalado)\ninstall.packages(\"ggthemes\")\n\nDepois de carregar o pacote, você pode aplicar qualquer um dos temas disponíveis aos seus gráficos ggplot2 usando a função theme_*(). No exemplo abaixo, são criadas três versões do mesmo gráfico com temas diferentes. Os operadores + e / foram usados para definir como os gráficos serão exibidos.\n\n# Carregar o pacote ggthemes\nlibrary(ggthemes)\n\nWarning: package 'ggthemes' was built under R version 4.2.3\n\nplot0 &lt;- ggplot(data = gapminder_2007, \n       mapping = aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(alpha = 0.5) +\n  labs(x = \"PIB per capita (log)\", \n       y = \"Expectativa de vida em 2007\")\n\nplot1 &lt;- plot0 + theme_economist()\nplot2 &lt;- plot0 + theme_excel()\nplot3 &lt;- plot0 + theme_stata()\n\nplot1 +  (plot2 / plot3)\n\n\n\n\n\n\n4.3.3 O pacote plotly\nO pacote plotly oferece recursos para criar gráficos interativos. Para adicionar interação ao gráfico fornecido, podemos usar a função ggplotly() para converter um gráfico criado com ggplot2 em um gráfico interativo. Utilize o comando install.packages(\"plotly\") caso não tenha o pacote instalado.\n\nlibrary(plotly)\n\ngrafico &lt;- ggplot(data = gapminder_anos, \n                  mapping = aes(x = gdpPercap, y = lifeExp, \n                                color = continent, text = country)) +\n  geom_point(alpha = 0.5) +\n  facet_wrap(~year) +\n  scale_x_log10() +\n  labs(x = \"PIB per capita (log)\", \n       y = \"Expectativa de vida\", \n       color = \"Continente\", \n       title = \"Relação entre PIB per capita e Expectativa de Vida\")\n\nggplotly(grafico)"
  },
  {
    "objectID": "03-dados.html#exercícios",
    "href": "03-dados.html#exercícios",
    "title": "3  Manipulação de dados",
    "section": "3.3 Exercícios",
    "text": "3.3 Exercícios\n1. Vamos trabalhar com o conjunto de dados billboard. Neste conjunto de dados, cada observação é uma música. As três primeiras colunas (artista, faixa e data de entrada) são variáveis que descrevem a música. Em seguida, temos 76 colunas (wk1-wk76) que descrevem o ranking da música em cada semana. Aqui, os nomes das colunas são uma variável (a semana) e os valores das células são outra (o ranking).\n\nlibrary(tidyverse)\nbillboard\n\n# A tibble: 317 × 79\n   artist     track date.entered   wk1   wk2   wk3   wk4   wk5   wk6   wk7   wk8\n   &lt;chr&gt;      &lt;chr&gt; &lt;date&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 2 Pac      Baby… 2000-02-26      87    82    72    77    87    94    99    NA\n 2 2Ge+her    The … 2000-09-02      91    87    92    NA    NA    NA    NA    NA\n 3 3 Doors D… Kryp… 2000-04-08      81    70    68    67    66    57    54    53\n 4 3 Doors D… Loser 2000-10-21      76    76    72    69    67    65    55    59\n 5 504 Boyz   Wobb… 2000-04-15      57    34    25    17    17    31    36    49\n 6 98^0       Give… 2000-08-19      51    39    34    26    26    19     2     2\n 7 A*Teens    Danc… 2000-07-08      97    97    96    95   100    NA    NA    NA\n 8 Aaliyah    I Do… 2000-01-29      84    62    51    41    38    35    35    38\n 9 Aaliyah    Try … 2000-03-18      59    53    38    28    21    18    16    14\n10 Adams, Yo… Open… 2000-08-26      76    76    74    69    68    67    61    58\n# ℹ 307 more rows\n# ℹ 68 more variables: wk9 &lt;dbl&gt;, wk10 &lt;dbl&gt;, wk11 &lt;dbl&gt;, wk12 &lt;dbl&gt;,\n#   wk13 &lt;dbl&gt;, wk14 &lt;dbl&gt;, wk15 &lt;dbl&gt;, wk16 &lt;dbl&gt;, wk17 &lt;dbl&gt;, wk18 &lt;dbl&gt;,\n#   wk19 &lt;dbl&gt;, wk20 &lt;dbl&gt;, wk21 &lt;dbl&gt;, wk22 &lt;dbl&gt;, wk23 &lt;dbl&gt;, wk24 &lt;dbl&gt;,\n#   wk25 &lt;dbl&gt;, wk26 &lt;dbl&gt;, wk27 &lt;dbl&gt;, wk28 &lt;dbl&gt;, wk29 &lt;dbl&gt;, wk30 &lt;dbl&gt;,\n#   wk31 &lt;dbl&gt;, wk32 &lt;dbl&gt;, wk33 &lt;dbl&gt;, wk34 &lt;dbl&gt;, wk35 &lt;dbl&gt;, wk36 &lt;dbl&gt;,\n#   wk37 &lt;dbl&gt;, wk38 &lt;dbl&gt;, wk39 &lt;dbl&gt;, wk40 &lt;dbl&gt;, wk41 &lt;dbl&gt;, wk42 &lt;dbl&gt;, …\n\n\na) Aplique uma tranformação na base de dados para deixá-la no formato abaixo.\n\n\n# A tibble: 24,092 × 5\n   artist track                   date.entered week   rank\n   &lt;chr&gt;  &lt;chr&gt;                   &lt;date&gt;       &lt;chr&gt; &lt;dbl&gt;\n 1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk1      87\n 2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk2      82\n 3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk3      72\n 4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk4      77\n 5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk5      87\n 6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk6      94\n 7 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk7      99\n 8 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk8      NA\n 9 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk9      NA\n10 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk10     NA\n# ℹ 24,082 more rows\n\n\nb) Observe o resultado do item a). O que acontece se uma música estiver no top 100 por menos de 76 semanas? Pegue a música “Baby Don’t Cry” de 2 Pac, por exemplo. A saída acima sugere que ela esteve no top 100 por apenas 7 semanas, e todas as semanas restantes são preenchidas com valores ausentes (NA). Esses NAs na verdade não representam observações desconhecidas; eles foram forçados a existir pela estrutura do conjunto de dados. Altere o código usado em a) para remover esses NAs. Responda: Quantas linhas sobraram? (Dica: veja a documentação da função pivot_longer.)\nc) Você deve ter percebido que no resultado do item a), o tipo da coluna week é caractere. Faça a transformação adequada para obter uma coluna com valores numéricos.\nd) Qual música ficou por mais semanas no top 100 da Billboard em 2000? Por quantas semanas essa música apareceu no ranking? E qual música ficou por menos tempo no ranking.\ne) Qual música ficou exatamente 10 semanas no top 100 da Billboard em 2000? Caso exista mais de uma música nessa condição, considere a que primeiro entrou no ranking.\n\n\n\n\nRosling, Hans. 2012. “Data - Gapminder.org.” http://www.gapminder.org/data/."
  },
  {
    "objectID": "03-dados.html#sec-ex-dados",
    "href": "03-dados.html#sec-ex-dados",
    "title": "3  Manipulação de dados",
    "section": "3.7 Exercícios",
    "text": "3.7 Exercícios\nVamos trabalhar com o conjunto de dados billboard. Neste conjunto de dados, cada observação é uma música. As três primeiras colunas (artista, faixa e data de entrada) são variáveis que descrevem a música. Em seguida, temos 76 colunas (wk1-wk76) que descrevem o ranking da música em cada semana. Aqui, os nomes das colunas são uma variável (a semana) e os valores das células são outra (o ranking).\n\nlibrary(tidyverse)\nbillboard\n\n# A tibble: 317 × 79\n   artist     track date.entered   wk1   wk2   wk3   wk4   wk5   wk6   wk7   wk8\n   &lt;chr&gt;      &lt;chr&gt; &lt;date&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 2 Pac      Baby… 2000-02-26      87    82    72    77    87    94    99    NA\n 2 2Ge+her    The … 2000-09-02      91    87    92    NA    NA    NA    NA    NA\n 3 3 Doors D… Kryp… 2000-04-08      81    70    68    67    66    57    54    53\n 4 3 Doors D… Loser 2000-10-21      76    76    72    69    67    65    55    59\n 5 504 Boyz   Wobb… 2000-04-15      57    34    25    17    17    31    36    49\n 6 98^0       Give… 2000-08-19      51    39    34    26    26    19     2     2\n 7 A*Teens    Danc… 2000-07-08      97    97    96    95   100    NA    NA    NA\n 8 Aaliyah    I Do… 2000-01-29      84    62    51    41    38    35    35    38\n 9 Aaliyah    Try … 2000-03-18      59    53    38    28    21    18    16    14\n10 Adams, Yo… Open… 2000-08-26      76    76    74    69    68    67    61    58\n# ℹ 307 more rows\n# ℹ 68 more variables: wk9 &lt;dbl&gt;, wk10 &lt;dbl&gt;, wk11 &lt;dbl&gt;, wk12 &lt;dbl&gt;,\n#   wk13 &lt;dbl&gt;, wk14 &lt;dbl&gt;, wk15 &lt;dbl&gt;, wk16 &lt;dbl&gt;, wk17 &lt;dbl&gt;, wk18 &lt;dbl&gt;,\n#   wk19 &lt;dbl&gt;, wk20 &lt;dbl&gt;, wk21 &lt;dbl&gt;, wk22 &lt;dbl&gt;, wk23 &lt;dbl&gt;, wk24 &lt;dbl&gt;,\n#   wk25 &lt;dbl&gt;, wk26 &lt;dbl&gt;, wk27 &lt;dbl&gt;, wk28 &lt;dbl&gt;, wk29 &lt;dbl&gt;, wk30 &lt;dbl&gt;,\n#   wk31 &lt;dbl&gt;, wk32 &lt;dbl&gt;, wk33 &lt;dbl&gt;, wk34 &lt;dbl&gt;, wk35 &lt;dbl&gt;, wk36 &lt;dbl&gt;,\n#   wk37 &lt;dbl&gt;, wk38 &lt;dbl&gt;, wk39 &lt;dbl&gt;, wk40 &lt;dbl&gt;, wk41 &lt;dbl&gt;, wk42 &lt;dbl&gt;, …\n\n\na) Aplique uma tranformação na base de dados para deixá-la no formato abaixo.\n\n\n# A tibble: 24,092 × 5\n   artist track                   date.entered week   rank\n   &lt;chr&gt;  &lt;chr&gt;                   &lt;date&gt;       &lt;chr&gt; &lt;dbl&gt;\n 1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk1      87\n 2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk2      82\n 3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk3      72\n 4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk4      77\n 5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk5      87\n 6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk6      94\n 7 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk7      99\n 8 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk8      NA\n 9 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk9      NA\n10 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk10     NA\n# ℹ 24,082 more rows\n\n\nb) Observe o resultado do item a). O que acontece se uma música estiver no top 100 por menos de 76 semanas? Pegue a música “Baby Don’t Cry” de 2 Pac, por exemplo. A saída acima sugere que ela esteve no top 100 por apenas 7 semanas, e todas as semanas restantes são preenchidas com valores ausentes (NA). Esses NAs na verdade não representam observações desconhecidas; eles foram forçados a existir pela estrutura do conjunto de dados. Altere o código usado em a) para remover esses NAs. Responda: Quantas linhas sobraram? (Dica: veja a documentação da função pivot_longer.)\nc) Você deve ter percebido que no resultado do item a), o tipo da coluna week é caractere. Faça a transformação adequada para obter uma coluna com valores numéricos.\nd) Qual música ficou por mais semanas no top 100 da Billboard em 2000? Por quantas semanas essa música apareceu no ranking? E qual música ficou por menos tempo no ranking.\ne) Qual música ficou exatamente 10 semanas no top 100 da Billboard em 2000? Caso exista mais de uma música nessa condição, considere a que primeiro entrou no ranking.\n\n\n\n\nRosling, Hans. 2012. “Data - Gapminder.org.” http://www.gapminder.org/data/."
  },
  {
    "objectID": "04-visualizacao.html#dicas-extras",
    "href": "04-visualizacao.html#dicas-extras",
    "title": "4  Visualização de dados",
    "section": "4.4 Dicas extras",
    "text": "4.4 Dicas extras\nQuando você estiver explorando diferentes tipos de gráficos para visualizar seus dados, o site Data to Viz pode ser uma ferramenta valiosa. Ele fornece uma galeria completa de tipos de gráficos e oferece orientações sobre quando e como usar cada um deles. Além disso, o site oferece exemplos específicos de como criar esses gráficos usando diferentes bibliotecas, como ggplot2 em R e matplotlib em Python."
  },
  {
    "objectID": "04-visualizacao.html#exercícios",
    "href": "04-visualizacao.html#exercícios",
    "title": "4  Visualização de dados",
    "section": "4.5 Exercícios",
    "text": "4.5 Exercícios\n1. Vamos utilizar os dados da Billboard que foram apresentados na Section 3.3. Sua tarefa é reproduzir os gráficos abaixo utilizando técnicas de processamento de dados com dplyr e visualização de dados com ggplot.\na) O gráfico abaixo mostra o histórico de cada musica no ranking ao longo das semanas.\n\n\n\n\n\nb) O gráfico abaixo é uma pequena alteração do apresentado no item a), no eixo x é apresentada a data que a música entrou no ranking.\n\n\n\n\n\nc) O gráfico abaixo mostra o histórico de duas músicas no ranking: “Higher” e “With Arms Wide Open”.\n\n\n\n\n\n2. Utilize os dados gerados na Section 2.2.1 que representam o preço de fechamento de uma ação e reproduza o gráfico abaixo, mostrando a evolução da média móvel ao longo do tempo.\n\n\n\n\n\n3. (Desafio) Reproduza o gráfico de dispersão abaixo que foi apresentado na Section 2.3.\n\n\n\n\n\n4. Reproduza a figura apresentada na Section 3.2.9.\n\n\n\n\nRosling, Hans. 2012. “Data - Gapminder.org.” http://www.gapminder.org/data/.\n\n\nWilkinson, Leland. 2012. The Grammar of Graphics. Springer."
  },
  {
    "objectID": "05-fundamentos_python.html#tipos-de-dados-fundamentais-integer-float-string-boolean",
    "href": "05-fundamentos_python.html#tipos-de-dados-fundamentais-integer-float-string-boolean",
    "title": "5  Fundamentos de Python",
    "section": "5.1 Tipos de dados fundamentais: integer, float, string, boolean",
    "text": "5.1 Tipos de dados fundamentais: integer, float, string, boolean"
  },
  {
    "objectID": "05-fundamentos_python.html#objetos-básicos",
    "href": "05-fundamentos_python.html#objetos-básicos",
    "title": "5  Fundamentos de Python",
    "section": "5.3 Objetos básicos",
    "text": "5.3 Objetos básicos\nEm Python, há três estruturas de dados básicas: listas, tuplas e dicionários. As listas são coleções ordenadas e mutáveis de elementos, permitindo a inclusão de itens de diferentes tipos e a modificação dos valores contidos nelas. As tuplas são semelhantes às listas, porém são imutáveis, ou seja, não podem ser alteradas após a sua criação. Já os dicionários são coleções não ordenadas de pares chave-valor, onde cada valor é associado a uma chave única, proporcionando acesso eficiente aos dados por meio das chaves.\n\n5.3.1 Listas\nEm Python, uma lista é uma estrutura de dados que permite armazenar uma coleção ordenada de elementos. Para criar uma lista, utilizamos colchetes [], e os elementos são separados por vírgulas. Podemos instanciar uma lista vazia simplesmente utilizando [] ou a função list(). Por exemplo:\n\nlista_vazia = [] # Lista vazia\nlista_vazia = list() # alternativa\n\n# lista co\npib_paises = [1800, 2500, 3200, 5600, 6700]\n\nNo exemplo acima, também temos a lista pib_paises que armazena o Produto Interno Bruto (PIB) de diferentes países. Para acessar elementos de uma lista em Python, podemos utilizar o índice do elemento desejado dentro de colchetes []. O índice começa do zero para o primeiro elemento, um para o segundo, e assim por diante. Por exemplo:\n\nprint(pib_paises[1])\n\n2500\n\n\nTambém podemos acessar os elementos a partir do final da lista utilizando índices negativos, onde -1 representa o último elemento, -2 o penúltimo, e assim por diante:\n\n# Acessando o último elemento\nultimo_elemento = pib_paises[-1]\nprint(ultimo_elemento)\n\n# Acessando o penúltimo elemento\npenultimo_elemento = pib_paises[-2]\nprint(penultimo_elemento)\n\n6700\n5600\n\n\nPodemos usar o método append() se desejamos adicionar um elemento ao final da lista, ou o método insert() se queremos adicionar um elemento em uma posição específica. Veja os exemplos de como usar ambos os métodos:\n\n# Adicionando elementos ao final da lista usando append()\npib_paises.append(2000)  # Adiciona o valor 2000 ao final da lista\n\n# Adicionando um elemento em uma posição específica usando insert()\npib_paises.insert(1, 1500)  # Adiciona o valor 1500 na posição 1 da lista\n\nPara verificar o tamanho de uma lista em Python, podemos usar a função len().\n\ntamanho_lista = len(pib_paises)\nprint(\"Tamanho da lista:\", tamanho_lista) \n\nTamanho da lista: 7\n\n\nPara ordenar uma lista, podemos usar o método sort() para ordenação in-place (ou seja, a lista é modificada) ou a função sorted() para retornar uma nova lista ordenada sem modificar a original. Aqui estão exemplos de como fazer isso:\n\n# Usando a função sorted() para retornar uma nova lista ordenada\nlista_ordenada = sorted(pib_paises)\nprint(\"Nova lista ordenada:\", lista_ordenada)\n\n# Ordenando a lista usando o método sort()\npib_paises.sort()\nprint(\"Lista ordenada:\", pib_paises)\n\nNova lista ordenada: [1500, 1800, 2000, 2500, 3200, 5600, 6700]\nLista ordenada: [1500, 1800, 2000, 2500, 3200, 5600, 6700]\n\n\nO método .pop() é usado para remover e retornar o último elemento de uma lista. Também podemos especificar um índice para remover e retornar um elemento em uma posição específica da lista. Aqui está como usar o método .pop():\n\n# Removendo e retornando o último PIB da lista\nultimo_pib = pib_paises.pop()\nprint(\"Último PIB removido:\", ultimo_pib) \nprint(\"Lista atualizada:\", pib_paises)\n\n# Removendo e retornando o PIB de um país específico da lista\npib_removido = pib_paises.pop(1) \nprint(\"PIB removido:\", pib_removido) \nprint(\"Lista atualizada:\", pib_paises)\n\nÚltimo PIB removido: 6700\nLista atualizada: [1500, 1800, 2000, 2500, 3200, 5600]\nPIB removido: 1800\nLista atualizada: [1500, 2000, 2500, 3200, 5600]\n\n\n\n\n5.3.2 Tuplas\nAs tuplas são estruturas de dados semelhantes às listas, mas com uma diferença fundamental: elas são imutáveis, ou seja, uma vez criadas, não podem ser modificadas. Elas são representadas por parênteses () em vez de colchetes [].\n\nx = (1, 2, 3) # tupla (lista imutável)\nprint(x)\n\n# x[0] = 5 # gera erro!\n\n(1, 2, 3)\n\n\nPodemos usar tuplas para representar informações que não devem ser alteradas, como por exemplo, as taxas de câmbio entre moedas. Veja:\n\ntaxas_cambio = ((\"USD\", \"EUR\", 0.82), (\"USD\", \"JPY\", 105.42), (\"EUR\", \"JPY\", 128.64))\n\nNeste exemplo, temos uma tupla de tuplas que representam as taxas de câmbio entre o dólar (USD), o euro (EUR) e o iene japonês (JPY) para uma data fixa fictícia. Cada tupla interna contém três elementos: a moeda de origem, a moeda de destino e a taxa de câmbio. Como essas informações não devem ser alteradas, uma tupla é uma escolha apropriada.\n\n\n\n\n\n\nTip\n\n\n\nPara acessar os elementos de uma tupla, você pode usar a mesma sintaxe que usa para acessar os elementos de uma lista, ou seja, usando colchetes [] e o índice do elemento desejado. Lembre-se de que os índices em Python começam em 0!\n\n\n\n\n5.3.3 Dicionários\nDicionários em Python são estruturas de dados que permitem armazenar pares de chave-valor. Cada valor é associado a uma chave específica, permitindo o acesso rápido aos dados por meio das chaves, em vez de índices numéricos, como em listas e tuplas. Essa estrutura é útil quando você precisa associar informações de maneira semelhante a um banco de dados, onde você pode buscar informações com base em uma chave específica.\nNo exemplo abaixo, temos cotações de ações de algumas empresas brasileiras listadas na bolsa de valores.\n\ncotacoes_acoes_brasileiras = {\n    \"PETR4\": 36.75,\n    \"VALE3\": 62.40,\n    \"ITUB4\": 34.15,\n    \"BBDC4\": 13.82\n}\n\nCada chave é o código de negociação da ação na bolsa, e o valor associado é o preço da ação em uma data fixada. Por exemplo, cotacoes_acoes_brasileiras[\"PETR4\"] retornaria o preço da ação da Petrobras.\nAlternativamente, você pode criar um dicionário usando a função dict:\n\ncotacoes_acoes_brasileiras = dict(PETR4=36.12, VALE3=62.40, ITUB4=34.15, BBDC4=13.82)\n\nVocê pode adicionar novos pares chave-valor a um dicionário ou atualizar os valores existentes. Por exemplo:\n\ncotacoes_acoes_brasileiras[\"ABEV3\"] = 12.80\ncotacoes_acoes_brasileiras[\"PETR4\"] = 36.75\n\nVocê pode remover pares chave-valor de um dicionário usando o comando método pop(). Por exemplo:\n\nvalor_removido = cotacoes_acoes_brasileiras.pop(\"BBDC4\")\n\nOutros métodos úteis para trabalhar com dicionários são keys(), values() e items() que retornam listas com as chaves, valores e itens do dicionário, respectivamente.\n\ncotacoes_acoes_brasileiras.keys() # retorna uma lista contendo todas as chaves\n\ndict_keys(['PETR4', 'VALE3', 'ITUB4', 'ABEV3'])\n\n\n\ncotacoes_acoes_brasileiras.values() # retorna uma lista contendo todos os valores\n\ndict_values([36.75, 62.4, 34.15, 12.8])\n\n\n\ncotacoes_acoes_brasileiras.items() # retorna uma lista de tuplas\n\ndict_items([('PETR4', 36.75), ('VALE3', 62.4), ('ITUB4', 34.15), ('ABEV3', 12.8)])"
  },
  {
    "objectID": "05-fundamentos_python.html#condicionais",
    "href": "05-fundamentos_python.html#condicionais",
    "title": "5  Fundamentos de Python",
    "section": "5.5 Condicionais",
    "text": "5.5 Condicionais\nO if e o else são estruturas de controle de fluxo em Python, usadas para tomar decisões com base em condições.\nO bloco de código dentro do if é executado se a condição for avaliada como verdadeira (True). Por exemplo:\n\nidade = 18\nif idade &gt;= 18:\n    print(\"Você é maior de idade.\")\n\nVocê é maior de idade.\n\n\nO bloco de código dentro do else é executado se a condição do if for avaliada como falsa (False). Por exemplo:\n\nidade = 16\nif idade &gt;= 18:\n    print(\"Você é maior de idade.\")\nelse:\n    print(\"Você é menor de idade.\")\n\nVocê é menor de idade.\n\n\n\n\n\n\n\n\nIndentação\n\n\n\nEm Python, a indentação é fundamental para definir blocos de código. No exemplo acima, observe que o código dentro do if e do else está indentado com quatro espaços. Isso indica que essas linhas pertencem ao bloco de código condicional. Se não houver indentação correta, o Python gerará um erro de sintaxe."
  },
  {
    "objectID": "05-fundamentos_python.html#estruturas-repetitivas",
    "href": "05-fundamentos_python.html#estruturas-repetitivas",
    "title": "5  Fundamentos de Python",
    "section": "5.6 Estruturas repetitivas",
    "text": "5.6 Estruturas repetitivas\nAs estruturas de repetição são utilizadas para executar um bloco de código repetidamente com base em uma condição específica. Existem duas principais estruturas de repetição em Python: for e while.\n\n5.6.1 for\nO loop for é utilizado para iterar sobre uma sequência (como uma lista, tupla, dicionário, etc.) e executar um bloco de código para cada item da sequência. Por exemplo:\n\nfor x in range(0, 20, 3): # lembre da notação dos slices\n    print(x)\n\n0\n3\n6\n9\n12\n15\n18\n\n\n\nfor pais in nomes_paises:\n    print(\"País:\", pais)\n\nPaís: Indonésia\nPaís: Índia\nPaís: Brasil\nPaís: África do Sul\nPaís: Alemanha\n\n\nNo exemplo abaixo, temos uma lista de empresas e uma lista de lucros. Usando a função zip(), iteramos sobre essas duas listas em paralelo, imprimindo o nome da empresa e seu lucro correspondente. A função zip() combina elementos de duas ou mais sequências (como listas, tuplas, etc.) em pares ordenados.\n\nempresas = [\"Empresa A\", \"Empresa B\", \"Empresa C\"]\nlucros = [100000, 150000, 80000]\n\nfor empresa, lucro in zip(empresas, lucros):\n    print(\"O lucro da empresa \", empresa, \"foi R$\", lucro)\n\nO lucro da empresa  Empresa A foi R$ 100000\nO lucro da empresa  Empresa B foi R$ 150000\nO lucro da empresa  Empresa C foi R$ 80000\n\n\n\n\n5.6.2 while\nO while é uma estrutura de controle de fluxo que executa um bloco de código repetidamente enquanto uma condição especificada for verdadeira.\n\nanos = 1\ninvestimento = 1000\ntaxa_de_retorno = 0.05\n\nwhile anos &lt;= 10:\n    investimento *= (1 + taxa_de_retorno)\n    print(\"Após\", anos, \"anos, o investimento vale R$\", round(investimento, 2))\n    anos += 1\n\nApós 1 anos, o investimento vale R$ 1050.0\nApós 2 anos, o investimento vale R$ 1102.5\nApós 3 anos, o investimento vale R$ 1157.62\nApós 4 anos, o investimento vale R$ 1215.51\nApós 5 anos, o investimento vale R$ 1276.28\nApós 6 anos, o investimento vale R$ 1340.1\nApós 7 anos, o investimento vale R$ 1407.1\nApós 8 anos, o investimento vale R$ 1477.46\nApós 9 anos, o investimento vale R$ 1551.33\nApós 10 anos, o investimento vale R$ 1628.89\n\n\nNeste exemplo, o loop calcula o valor do investimento ao longo de 10 anos, considerando um retorno anual de 5%. A cada iteração, o valor do investimento é atualizado multiplicando-se pelo fator de crescimento (1 + taxa_de_retorno)."
  },
  {
    "objectID": "05-fundamentos_python.html#comprehensions",
    "href": "05-fundamentos_python.html#comprehensions",
    "title": "5  Fundamentos de Python",
    "section": "5.7 Comprehensions",
    "text": "5.7 Comprehensions\nAs compreensões (ou comprehensions) são uma maneira concisa e poderosa de criar coleções em Python, como listas, dicionários e conjuntos, a partir de iteráveis existentes, como listas, dicionários, conjuntos ou sequências. Elas permitem criar essas coleções de forma mais eficiente e legível em comparação com a abordagem tradicional de usar loops. As compreensões podem incluir expressões condicionais para filtrar elementos ou expressões para transformar os elementos durante a criação da coleção.\nPor exemplo, você pode criar uma lista de quadrados dos números de 1 a 10 usando uma compreensão de lista:\n\nquadrados = [x ** 2 for x in range(1, 11)]\nquadrados\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\n\nIsso é equivalente a:\n\nquadrados = []\nfor x in range(1, 11):\n    quadrados.append(x ** 2)\n\nAs compreensões podem ser aplicadas a listas, dicionários e conjuntos, e você pode adicionar cláusulas condicionais para filtrar elementos com base em uma condição específica.\nAbaixo, as variáveis linhas e colunas são definidas como intervalos de números de 1 a 3 e de 1 a 2, respectivamente. Em seguida, é utilizada uma compreensão de lista para gerar todos os pares possíveis, combinando cada valor de linha com cada valor de coluna. Por fim, um loop for é usado para iterar sobre a lista de pares e imprimir cada par na saída. O resultado será a impressão de todos os pares ordenados possíveis, combinando os valores de linha e coluna especificados.\n\nlinhas = range(1, 4)\ncolunas = range(1, 3)\n\npares = [(r, c) for r in linhas for c in colunas]\n\nfor x in pares:\n    print(x)\n\n(1, 1)\n(1, 2)\n(2, 1)\n(2, 2)\n(3, 1)\n(3, 2)\n\n\nNeste exemplo abaixo, a palavra “inconstitucionalissimamente” é analisada para contar quantas vezes cada letra aparece. Em seguida, é feito um loop sobre o dicionário resultante para imprimir a contagem de ocorrências de cada letra.\n\npalavra = \"inconstitucionalissimamente\"\n\nfrequencia_letras = {letra: palavra.count(letra) for letra in palavra}\n\nfor letra, ocorrencias in frequencia_letras.items():\n    print(\"A letra\", letra, \"ocorre\", ocorrencias, \"vezes\" if ocorrencias &gt; 1 else \"vez\")\n\nA letra i ocorre 5 vezes\nA letra n ocorre 4 vezes\nA letra c ocorre 2 vezes\nA letra o ocorre 2 vezes\nA letra s ocorre 3 vezes\nA letra t ocorre 3 vezes\nA letra u ocorre 1 vez\nA letra a ocorre 2 vezes\nA letra l ocorre 1 vez\nA letra m ocorre 2 vezes\nA letra e ocorre 2 vezes"
  },
  {
    "objectID": "05-fundamentos_python.html#funções",
    "href": "05-fundamentos_python.html#funções",
    "title": "5  Fundamentos de Python",
    "section": "5.8 Funções",
    "text": "5.8 Funções\nAs funções são blocos de código reutilizáveis que realizam uma tarefa específica.\nElas aceitam entradas, chamadas de argumentos, e podem retornar resultados.\nEm Python, a sintaxe básica de uma função é a seguinte:\n\ndef nome_da_funcao(argumento1, argumento2, ...):\n    # Corpo da função\n    # Faça alguma coisa com os argumentos\n    resultado = argumento1 + argumento2\n    return resultado\n\nPor exemplo, vamos criar uma função em Python chamada calcular_juros que calcula o montante final de um investimento com base no valor inicial, na taxa de juros e no número de anos:\n\ndef calcular_juros(valor_inicial, taxa_juros, anos):\n    montante_final = valor_inicial * (1 + taxa_juros) ** anos\n    return montante_final\n\nAgora, definimos valores e chamamos a função:\n\ninvestimento_inicial = 1000  # Valor inicial do investimento\ntaxa_juros_anual = 0.05      # Taxa de juros anual (5%)\nanos = 5                     # Número de anos\nresultado = calcular_juros(investimento_inicial, taxa_juros_anual, anos)\nprint(\"O montante final após\", anos, \"anos será de: R$\", round(resultado, 2))\n\nO montante final após 5 anos será de: R$ 1276.28\n\n\n\n5.8.1 Função lambda\nUma função lambda em Python é uma função anônima, o que significa que é uma função sem nome. Ela é definida usando a palavra-chave lambda e pode ter qualquer número de argumentos, mas apenas uma expressão. A sintaxe básica é a seguinte:\n\nlambda argumento1, argumento2, ...: expressao\n\nVeja um exemplo de uma função lambda que calcula o quadrado de um número:\n\nquadrado = lambda x: x ** 2\n\nNeste exemplo, lambda x: x ** 2 cria uma função que aceita um argumento x e retorna x ao quadrado. Você pode então usar essa função da mesma forma que qualquer outra função. Por exemplo:\n\nresultado = quadrado(5)\nprint(resultado)\n\n25\n\n\nAs funções lambda são frequentemente usadas em situações em que você precisa de uma função temporária e simples, como em operações de mapeamento, filtragem e ordenação de dados."
  },
  {
    "objectID": "05-fundamentos_python.html#classes-e-objetos",
    "href": "05-fundamentos_python.html#classes-e-objetos",
    "title": "5  Fundamentos de Python",
    "section": "5.9 Classes e objetos",
    "text": "5.9 Classes e objetos\nUma classe é uma estrutura que define o comportamento e as propriedades de um tipo de objeto. Podemos pensar em uma classe como uma representação de um conceito abstrato, como uma transação financeira ou um tipo específico de investimento.\nPor exemplo, podemos criar uma classe chamada Transacao para representar uma transação financeira, com propriedades como o valor da transação, a data e o tipo de transação.\nUm objeto, por outro lado, é uma instância específica de uma classe. Ele representa uma entidade concreta com suas próprias características e comportamentos. Continuando com o exemplo da classe Transacao, podemos criar objetos individuais para representar transações específicas, como a compra de ações de uma empresa em uma determinada data.\n\nclass Transacao:\n    def __init__(self, valor, data, tipo):\n        self.valor = valor\n        self.data = data\n        self.tipo = tipo\n    \n    def print_info(self):\n      print(f\"Tipo da transação: {self.tipo}, Valor: R${self.valor}, Data:{self.data}\")\n\nNeste exemplo, a classe Transacao possui um método especial __init__ que é chamado quando um novo objeto é criado. Esse método inicializa as propriedades do objeto com os valores fornecidos como argumentos. Além disso, a classe possui um método chamado print_info, que imprime as informações da transação, incluindo o tipo, o valor e a data. Esse método também recebe self como parâmetro para acessar os atributos da instância atual da classe. Ao chamar print_info() em um objeto Transacao, ele exibirá as informações formatadas da transação.\nA seguir, criamos dois objetos da classe Transacao, transacao1 e transacao2, e acessamos suas propriedades para obter informações sobre as transações.\n\n# Criando objetos da classe Transacao\ntransacao1 = Transacao(valor=1000, data=\"2024-03-11\", tipo=\"Compra de ações\")\ntransacao2 = Transacao(valor=500, data=\"2024-03-12\", tipo=\"Venda de ações\")\n\n# Acessando as propriedades dos objetos\nprint(\"Valor da transação 1:\", transacao1.valor)\nprint(\"Data da transação 2:\", transacao2.data)\n\n# Acessando métodos dos objetos\ntransacao1.print_info()\ntransacao2.print_info()\n\nValor da transação 1: 1000\nData da transação 2: 2024-03-12\nTipo da transação: Compra de ações, Valor: R$1000, Data:2024-03-11\nTipo da transação: Venda de ações, Valor: R$500, Data:2024-03-12\n\n\n\n\n\n\nMcKinney, Wes. 2022. Python for Data Analysis. \" O’Reilly Media, Inc.\"."
  },
  {
    "objectID": "05-fundamentos_python.html#numpy",
    "href": "05-fundamentos_python.html#numpy",
    "title": "5  Fundamentos de Python",
    "section": "5.10 Numpy",
    "text": "5.10 Numpy"
  },
  {
    "objectID": "05-fundamentos_python.html#pandas",
    "href": "05-fundamentos_python.html#pandas",
    "title": "5  Fundamentos de Python",
    "section": "5.11 Pandas",
    "text": "5.11 Pandas"
  },
  {
    "objectID": "06-visualizacao_python.html",
    "href": "06-visualizacao_python.html",
    "title": "6  Processamento e visualização de dados",
    "section": "",
    "text": "7 Exercícios"
  },
  {
    "objectID": "02-fluxos.html#sec-fluxos-funcoes",
    "href": "02-fluxos.html#sec-fluxos-funcoes",
    "title": "2  Fluxos de execução",
    "section": "2.3 Funções",
    "text": "2.3 Funções\nUma função em R é um bloco de código que realiza uma tarefa específica e pode ser reutilizado várias vezes. A sintaxe para definir uma função em R segue o padrão:\n\nnome_da_funcao &lt;- function(parametros) {\n  # Corpo da função\n  # Código que realiza a tarefa desejada\n  # Pode incluir operações matemáticas, manipulação de dados, etc.\n  return(resultado)  # Retorna o resultado desejado\n}\n\nOs parâmetros são variáveis que uma função recebe como entrada para executar suas operações. Eles são especificados entre parênteses na definição da função. Dentro do corpo da função, os parâmetros podem ser utilizados para realizar cálculos ou operações.\nO exemplo abaixo define uma função para realizar uma regressão linear simples. A função regressao_linear recebe dois parâmetros: x e y, que representam os dados de entrada para a regressão linear. Dentro da função, um modelo de regressão linear é criado usando a função lm() do R com os dados y em função de x. A documentação da função lm() pode ser acessada ao executar o comando ?lm. O modelo resultante é retornado como resultado da função.\n\n# Função para realizar regressão linear simples\nregressao_linear &lt;- function(x, y) {\n  modelo &lt;- lm(y ~ x)  # Criando o modelo de regressão linear\n  return(modelo)  # Retornando o modelo\n}\n\n# Dados de exemplo: salário (y) em função dos anos de educação (x)\nanos_educacao &lt;- c(10, 12, 14, 16, 18)\nsalario &lt;- c(2500, 3300, 3550, 3700, 4500)\n\n# Chamando a função de regressão linear\nmodelo_regressao &lt;- regressao_linear(anos_educacao, salario)\n\nVeja o sumário com o resultado do modelo treinado.\n\n# Exibindo os resultados da regressão\nsummary(modelo_regressao)\n\n\nCall:\nlm(formula = y ~ x)\n\nResiduals:\n   1    2    3    4    5 \n-130  230   40 -250  110 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)   \n(Intercept)   430.00     498.20   0.863  0.45156   \nx             220.00      34.88   6.307  0.00805 **\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 220.6 on 3 degrees of freedom\nMultiple R-squared:  0.9299,    Adjusted R-squared:  0.9065 \nF-statistic: 39.78 on 1 and 3 DF,  p-value: 0.008054\n\n\nA figura abaixo mostra um gráfico de dispersão que representa a relação entre anos de educação e salário. A reta azul mostra o modelo de regressão linear treinado com os dados.\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nVocê vai aprender a construir gráficos como este no Capítulo 4."
  },
  {
    "objectID": "05-fundamentos_python.html",
    "href": "05-fundamentos_python.html",
    "title": "5  Fundamentos de Python",
    "section": "",
    "text": "6 O tipo de dado lógico\nO tipo de dados lógico, também conhecido como booleano (bool), é usado para representar valores de verdadeiro ou falso. No Python, os valores booleanos são True e False, que representam verdadeiro e falso, respectivamente.\n1 == 2\n\nFalse\n5 % 2 == 0\n\nFalse\ntaxa_juros_aumentando = True\nprint(taxa_juros_aumentando)\ntype(taxa_juros_aumentando)\n\nTrue\n\n\nbool\nNa primeira linha do exemplo acima, há uma verificação de igualdade entre 1 e 2, que retorna False porque 1 não é igual a 2. Em seguida, temos 5 % 2 == 0, que também retorna False porque o resto da divisão de 5 por 2 não é igual a zero. Por fim, temos a variável taxa_juros_aumentando atribuída a True, indicando que a taxa de juros está aumentando. Ao imprimir e verificar o tipo dessa variável, obtemos True como resultado e o tipo bool, indicando que é um valor lógico."
  },
  {
    "objectID": "05-fundamentos_python.html#instalação",
    "href": "05-fundamentos_python.html#instalação",
    "title": "5  Fundamentos de Python",
    "section": "5.1 Instalação",
    "text": "5.1 Instalação\nSiga os passos abaixo para realizar a instalação do Anaconda e do JupyterLab:\n\nBaixe e instale o Anaconda a partir do site oficial. Siga as instruções de instalação para o seu sistema operacional específico.\nApós instalar o Anaconda, abra o Anaconda Navigator e crie um novo ambiente virtual. Navegue até a seção “Environments” e clique em “Create” para adicionar um novo ambiente. Dê um nome ao ambiente e escolha a versão do Python que deseja usar.\nApós criar o ambiente virtual, ative-o clicando no ambiente virtual recém-criado na lista de ambientes e selecionando “Open Terminal”. No terminal, digite o comando conda activate nome_do_seu_ambiente (substitua nome_do_seu_ambiente pelo nome do ambiente que você criou).\nCom o ambiente virtual ativado, instale o JupyterLab digitando conda install jupyterlab no terminal.\nDepois de instalar o JupyterLab, execute-o digitando jupyter lab no terminal ou através da interface do Anaconda. Isso abrirá o JupyterLab no seu navegador padrão.\nNo JupyterLab, você pode criar um novo notebook Python clicando no ícone “+” na barra lateral esquerda e selecionando “Python 3” sob o cabeçalho “Notebook”."
  },
  {
    "objectID": "05-fundamentos_python.html#tipos-de-dados-fundamentais",
    "href": "05-fundamentos_python.html#tipos-de-dados-fundamentais",
    "title": "5  Fundamentos de Python",
    "section": "5.2 Tipos de dados fundamentais",
    "text": "5.2 Tipos de dados fundamentais\nEm Python, os tipos de dados fundamentais incluem integer, float, string e boolean. Integers são números inteiros, como 1, 2, -3, etc. Floats são números decimais, como 3.14, -0.5, etc. Strings são sequências de caracteres, como “hello”, “world”, “python”, etc. Booleans são valores lógicos que representam verdadeiro (True) ou falso (False).\nEsses tipos de dados são os blocos básicos para representar diferentes tipos de informações em Python, e são amplamente utilizados em programação para realizar operações e manipulações de dados.\n\n5.2.1 O tipo de dado inteiro\nUm tipo de dados inteiro (integer) em Python representa números inteiros, ou seja, números sem casas decimais. Por exemplo, 5, -10 e 0 são todos exemplos de números inteiros. No Python, os inteiros são representados pela classe int. Nos exemplos abaixo realizamos operações básicas com números inteiros.\n\n2 + 2  \n\n4\n\n\nNa primeira linha, calculamos a soma de 2 com 2.\n\nquantidade = 200\nprint(quantidade)\ntype(quantidade)\n\n200\n\n\nint\n\n\nAcima, atribuímos o valor 2 à variável quantidade e a imprimimos usando print(quantidade). Por fim, verificamos o tipo de dado da variável quantidade com type(quantidade), que retorna &lt;class 'int'&gt;, indicando que é um número inteiro.\n\n\n5.2.2 O tipo de dado ponto flutuante\nUm tipo de dado ponto flutuante (float) em Python representa números decimais, ou seja, números que podem ter uma parte fracionária. Por exemplo, 3.14, -0.001, e 2.71828 são todos floats. Em Python, os floats são representados pela classe float.\n\n1.75 + 2**3 \ntaxa_juros = 1.25\n\nprint(taxa_juros)\ntype(taxa_juros)\n\n1.25\n\n\nfloat\n\n\nNa primeira linha do exemplo acima, calculamos a soma de 1.75 com 2 elevado à terceira potência. Em seguida, atribuímos o valor 1.25 à variável taxa_juros e a imprimimos usando print(taxa_juros). Por fim, verificamos o tipo de dado da variável taxa_juros com type(taxa_juros), que retorna &lt;class 'float'&gt;, indicando que é um número do tipo ponto flutuante.\n\n\n5.2.3 O tipo de dado cadeia de caracteres\n\npais = \"Brasil\" \n\nprint(pais)\ntype(pais)\n\nBrasil\n\n\nstr\n\n\nNo código acima, criamos uma variável chamada pais e atribuímos a ela o valor “Brasil”, que é uma string. Em seguida, imprimimos o valor da variável pais usando print(pais), o que exibe “Brasil” na tela. Por fim, verificamos o tipo de dado da variável pais com type(pais), que retorna &lt;class 'str'&gt;, indicando que é uma string.\n\n\n5.2.4 O tipo de dado lógico\nO tipo de dados lógico, também conhecido como booleano (bool), é usado para representar valores de verdadeiro ou falso. No Python, os valores booleanos são True e False, que representam verdadeiro e falso, respectivamente.\n\n1 == 2\n\nFalse\n\n\n\n5 % 2 == 0\n\nFalse\n\n\n\ntaxa_juros_aumentando = True\nprint(taxa_juros_aumentando)\ntype(taxa_juros_aumentando)\n\nTrue\n\n\nbool\n\n\nNa primeira linha do exemplo acima, há uma verificação de igualdade entre 1 e 2, que retorna False porque 1 não é igual a 2. Em seguida, temos 5 % 2 == 0, que também retorna False porque o resto da divisão de 5 por 2 não é igual a zero. Por fim, temos a variável taxa_juros_aumentando atribuída a True, indicando que a taxa de juros está aumentando. Ao imprimir e verificar o tipo dessa variável, obtemos True como resultado e o tipo bool, indicando que é um valor lógico.\n\n\n5.2.5 Coerção de tipos\nA coerção de dados em Python refere-se à conversão forçada de um tipo de dado para outro.\n\nstr_num = \"1.41\"\ntype(str_num)\n\nstr\n\n\n\nfloat(str_num)\n\n1.41\n\n\nVeja que a variável str_num é uma string que representa o número 1.41. Inicialmente, seu tipo é verificado usando a função type, que retorna &lt;class 'str'&gt;, indicando que é uma string. Em seguida, usamos a função float() para converter explicitamente str_num em um float. Após a conversão, o valor de str_num é “1.41” e seu tipo é alterado para &lt;class 'float'&gt;.\nA seguir, outros exemplos de cooerção.\nCoerção para inteiro:\n\nnum_float = 3.14\nnum_int = int(num_float)\nprint(num_int)\n\n3\n\n\nCoerção para lógico:\n\nvalor_inteiro = 0\nvalor_logico = bool(valor_inteiro)\nprint(valor_logico)\n\nFalse\n\n\nCoerção para string (str):\n\nnum_float = 3.14\nnum_str = str(num_float)\nprint(num_str) \n\n3.14\n\n\n\nNo código acima,\n\n# strings funcionam como listas/vetores\nschool=\"Insper\"\nprint(school)\nschool[0]\nschool[3]\nschool[2:5] # slice: o último índice não é incluído (start:stop:step)\nschool[3:]\nschool[1:5:2]\nprint(school[-2])\nprint(school[-2:])\nprint(school[-1::-1]) # reverse\n\nInsper\ne\ner\nrepsnI"
  },
  {
    "objectID": "05-fundamentos_python.html#coerção-de-tipos",
    "href": "05-fundamentos_python.html#coerção-de-tipos",
    "title": "5  Fundamentos de Python",
    "section": "6.1 Coerção de tipos",
    "text": "6.1 Coerção de tipos\nA coerção de dados em Python refere-se à conversão forçada de um tipo de dado para outro.\n\nstr_num = \"1.41\"\ntype(str_num)\n\nstr\n\n\n\nfloat(str_num)\n\n1.41\n\n\nVeja que a variável str_num é uma string que representa o número 1.41. Inicialmente, seu tipo é verificado usando a função type, que retorna &lt;class 'str'&gt;, indicando que é uma string. Em seguida, usamos a função float() para converter explicitamente str_num em um float. Após a conversão, o valor de str_num é “1.41” e seu tipo é alterado para &lt;class 'float'&gt;.\nA seguir, outros exemplos de cooerção.\nCoerção para inteiro:\n\nnum_float = 3.14\nnum_int = int(num_float)\nprint(num_int)\n\n3\n\n\nCoerção para lógico:\n\nvalor_inteiro = 0\nvalor_logico = bool(valor_inteiro)\nprint(valor_logico)\n\nFalse\n\n\nCoerção para string (str):\n\nnum_float = 3.14\nnum_str = str(num_float)\nprint(num_str) \n\n3.14\n\n\nOutras coerções possíveis:\n\n# 1.25 + str_num # erro!\n1.25 + float(str_num)\nint(True)\n\n1\n\n\nNo código acima,\n\n# strings funcionam como listas/vetores\nschool=\"Insper\"\nprint(school)\nschool[0]\nschool[3]\nschool[2:5] # slice: o último índice não é incluído (start:stop:step)\nschool[3:]\nschool[1:5:2]\nprint(school[-2])\nprint(school[-2:])\nprint(school[-1::-1]) # reverse\n\nInsper\ne\ner\nrepsnI"
  },
  {
    "objectID": "05-fundamentos_python.html#fatias-slices",
    "href": "05-fundamentos_python.html#fatias-slices",
    "title": "5  Fundamentos de Python",
    "section": "5.4 Fatias (slices)",
    "text": "5.4 Fatias (slices)\nO conceito de fatias, também conhecido como “slicing” em inglês, refere-se à técnica de extrair partes específicas de uma sequência, como uma lista, tupla ou string, usando índices. Ao utilizar fatias, você pode selecionar um intervalo de elementos dentro da sequência.\nA sintaxe básica para fatias é sequencia[inicio:fim:passo], onde:\n\ninicio: o índice inicial do intervalo a ser incluído na fatia (incluído).\nfim: o índice final do intervalo a ser incluído na fatia (excluído).\npasso: o tamanho do passo entre os elementos selecionados (opcional).\n\nConsidere a lista abaixo.\n\nnomes_paises = [\"Indonésia\", \"Índia\", \"Brasil\", \"África do Sul\", \"Alemanha\"]\n\nPara acessar os três primeiros países, podemos fazer:\n\nnomes_paises[:3]\n\n['Indonésia', 'Índia', 'Brasil']\n\n\nIsso retorna os elementos da lista do índice 0 (inclusivo) ao índice 3 (exclusivo).\nSe quisermos acessar os países do segundo ao quarto:\n\nnomes_paises[1:4]\n\n['Índia', 'Brasil', 'África do Sul']\n\n\nPodemos até mesmo fazer fatias reversas, onde o índice inicial é maior que o índice final, indicando que queremos percorrer a lista de trás para frente. Por exemplo, para acessar os últimos três países:\n\nnomes_paises[-3:]\n\n['Brasil', 'África do Sul', 'Alemanha']\n\n\nSuponha que queremos acessar todos os países, mas pulando de dois em dois:\n\nnomes_paises[::2]\n\n['Indonésia', 'Brasil', 'Alemanha']\n\n\nNeste exemplo, o ::2 indica que queremos começar do início da lista e ir até o final, pulando de dois em dois elementos."
  },
  {
    "objectID": "06-visualizacao_python.html#instalação-de-bibliotecas",
    "href": "06-visualizacao_python.html#instalação-de-bibliotecas",
    "title": "6  Processamento e visualização de dados",
    "section": "6.1 Instalação de bibliotecas",
    "text": "6.1 Instalação de bibliotecas\nA instalação de bibliotecas em Python é essencial para expandir a funcionalidade da linguagem. Existem várias maneiras de instalar bibliotecas, mas a mais comum é usando um gerenciador de pacotes. O pip é o gerenciador de pacotes padrão para Python e geralmente acompanha a instalação do Python.\nPara instalar uma biblioteca com pip, abra o terminal ou prompt de comando e digite o seguinte comando:\n\npip install nome_da_biblioteca\n\nSubstitua nome_da_biblioteca pelo nome da biblioteca que você deseja instalar."
  },
  {
    "objectID": "06-visualizacao_python.html#processamento-de-dados-numéricos",
    "href": "06-visualizacao_python.html#processamento-de-dados-numéricos",
    "title": "6  Processamento e visualização de dados",
    "section": "6.2 Processamento de dados numéricos",
    "text": "6.2 Processamento de dados numéricos\nO NumPy (Numerical Python) é uma biblioteca essencial para computação numérica em Python. Ele fornece estruturas de dados eficientes para trabalhar com arrays multidimensionais e funções matemáticas poderosas para manipulação de dados.\nPara instalar o NumPy, você pode usar o pip, que é o gerenciador de pacotes padrão do Python:\n\npip install numpy\n\nO principal objeto em NumPy é o array multidimensional. Você pode criar arrays NumPy usando a função numpy.array() e realizar operações matemáticas básicas com eles:\n\nimport numpy as np\n\n# Criando um array NumPy\narr = np.array([1, 2, 3, 4, 5])\n\n# Operações matemáticas básicas\nprint(\"Soma:\", np.sum(arr))\nprint(\"Média:\", np.mean(arr))\n\nSoma: 15\nMédia: 3.0\n\n\nAlém das operações básicas, o NumPy oferece funções universais (ufuncs) para aplicar operações em todos os elementos de um array de uma vez:\n\n# Funções universais (ufuncs)\narr = np.array([1, 2, 3, 4, 5])\nprint(\"Quadrado de cada elemento:\", np.square(arr))\nprint(\"Exponencial de cada elemento:\", np.exp(arr))\n\nQuadrado de cada elemento: [ 1  4  9 16 25]\nExponencial de cada elemento: [  2.71828183   7.3890561   20.08553692  54.59815003 148.4131591 ]\n\n\nA seguir, apresentamos três exemplos práticos de utilização das funções do NumPy.\nExemplo 1: Cálculo de Estatísticas Descritivas\nO NumPy pode ser usado para calcular estatísticas descritivas, como média, mediana, desvio padrão, mínimo e máximo de séries temporais de dados econômicos, como o preço das ações de uma empresa ao longo do tempo.\n\nimport numpy as np\n\n# Preço das ações de uma empresa ao longo do tempo (em dólares)\nprecos = np.array([100, 102, 105, 110, 108, 115, 120])\n\n# Calculando estatísticas descritivas\nprint(\"Média:\", np.mean(precos))\nprint(\"Desvio padrão:\", np.std(precos))\nprint(\"Máximo:\", np.max(precos))\nprint(\"Mínimo:\", np.min(precos))\n\nMédia: 108.57142857142857\nDesvio padrão: 6.58693821908486\nMáximo: 120\nMínimo: 100\n\n\nExemplo 2: Análise de Séries Temporais O NumPy é útil para manipulação e análise de séries temporais. Por exemplo, você pode usar NumPy para calcular a taxa de retorno de um investimento ao longo do tempo ou para suavizar uma série temporal usando médias móveis.\n\nprecos = np.array([100, 102, 105, 110, 108, 115, 120])\n# Calcular a taxa de retorno de um investimento ao longo do tempo\nretornos = np.diff(precos) / precos[:-1] * 100\nprint(\"Taxa de retorno:\", retornos)\n\nTaxa de retorno: [ 2.          2.94117647  4.76190476 -1.81818182  6.48148148  4.34782609]\n\n\n\n\n\n\n\n\nTip\n\n\n\nA função np.diff em NumPy é usada para calcular a diferença entre elementos consecutivos ao longo de um determinado eixo de um array. Atenção: O tamanho do retorno da função np.diff será sempre menor que o tamanho do vetor original de entrada por um elemento. Por exemplo, se tivermos um vetor unidimensional com \\(n\\) elementos, a função np.diff retornará um vetor com \\(n−1\\) elementos, pois não há diferença para o último elemento.\n\n\n\nprecos = np.array([100, 102, 105, 110, 108, 115, 120])\n# Suavizar uma série temporal usando médias móveis\ntamanho_janela = 3\nmedia_movel = np.convolve(precos, np.ones(tamanho_janela) / tamanho_janela, mode='valid')\nprint(\"Médias móveis:\", media_movel)\n\nMédias móveis: [102.33333333 105.66666667 107.66666667 111.         114.33333333]\n\n\n\n\n\n\n\n\nTip\n\n\n\nA função np.convolve em NumPy é usada para realizar a convolução entre duas sequências, representadas por dois vetores unidimensionais. A convolução é uma operação matemática que combina duas funções para produzir uma terceira função que representa a quantidade de sobreposição entre elas conforme uma delas é deslocada ao longo do eixo.\nA sintaxe básica da função é np.convolve(a, b, mode='full'), onde a e b são os dois vetores unidimensionais a serem convolvidos e mode é um parâmetro opcional que define o modo de convolução. Os modos mais comuns são: - 'full': Retorna a saída completa da convolução. O comprimento do resultado será len(a) + len(b) - 1. - 'valid': Retorna apenas pontos onde as sequências se sobrepõem completamente. O comprimento do resultado será max(len(a), len(b)) - min(len(a), len(b)) + 1. - 'same': Retorna a saída do mesmo tamanho que o vetor de entrada mais longo. O comprimento do resultado será max(len(a), len(b)).\nNo exemplo anterior, a função np.convolve foi usada aqui para calcular a média móvel dos preços. Nesse caso, a primeira sequência é o vetor de preços e a segunda sequência é um vetor de 1s dividido pelo tamanho da janela de média móvel. Isso cria uma sequência que representa uma média ponderada dos valores.\n\n\nExemplo 3: Simulação Monte Carlo O NumPy pode ser usado para realizar simulações Monte Carlo, que são amplamente utilizadas na modelagem financeira e na avaliação de risco. Por exemplo, você pode simular o desempenho de uma carteira de investimentos ao longo do tempo sob diferentes cenários de mercado.\n\n# Simulação Monte Carlo do desempenho de uma carteira de investimentos\nnum_simulacoes = 1000\nnum_anos = 10\nretorno_medio = 0.08\nvolatilidade = 0.15\n\n# Gerar retornos aleatórios usando uma distribuição normal\nretornos = np.random.normal(retorno_medio, volatilidade, size=(num_simulacoes, num_anos))\n\n# Calcular o valor final da carteira para cada simulação\ninvestimento_inicial = 10000\nvalores_finais = investimento_inicial * np.cumprod(1 + retornos, axis=1)\n\n# Estatísticas descritivas dos valores finais da carteira\nprint(\"Valor final médio:\", np.mean(valores_finais[:,-1]))\nprint(\"Desvio padrão dos valores finais:\", np.std(valores_finais[:,-1]))\n\nValor final médio: 21165.949264537718\nDesvio padrão dos valores finais: 9888.947340076622\n\n\nMais referências sobre NumPy:\n\nDocumentação oficial do NumPy: https://numpy.org/doc/stable/ A documentação oficial do NumPy contém informações detalhadas sobre todas as funções e métodos disponíveis, além de tutoriais e exemplos.\nNumPy Quickstart Tutorial: https://numpy.org/doc/stable/user/quickstart.html Este tutorial rápido fornece uma introdução rápida ao NumPy e suas funcionalidades básicas."
  },
  {
    "objectID": "06-visualizacao_python.html#análise-e-processamento-de-dados",
    "href": "06-visualizacao_python.html#análise-e-processamento-de-dados",
    "title": "6  Processamento e visualização de dados",
    "section": "6.3 Análise e processamento de dados",
    "text": "6.3 Análise e processamento de dados\nPandas"
  },
  {
    "objectID": "06-visualizacao_python.html#visualização-de-dados",
    "href": "06-visualizacao_python.html#visualização-de-dados",
    "title": "6  Processamento e visualização de dados",
    "section": "6.4 Visualização de dados",
    "text": "6.4 Visualização de dados\n\n6.4.1 Matplotlib\n\n\n6.4.2 Plotnine"
  },
  {
    "objectID": "03-dados.html#o-operador-pipe",
    "href": "03-dados.html#o-operador-pipe",
    "title": "3  Manipulação de dados",
    "section": "3.3 O operador pipe %>%",
    "text": "3.3 O operador pipe %&gt;%\nO operador %\\&gt;%, conhecido como pipe, é uma ferramenta poderosa em R que facilita a encadeamento de operações em sequência. Ele permite escrever código de forma mais clara e concisa, especialmente ao trabalhar com pacotes do tidyverse. O pipe recebe o resultado de uma expressão à esquerda e o passa como primeiro argumento para a próxima expressão à direita.\n\n\n\n\n\n\nTip\n\n\n\nVocê não precisa digitar %\\&gt;% toda vez que precisar. Utilize o atalho Ctrl+Shitf+M.\n\n\nVamos supor que temos uma função f, uma função g e uma variável x. Queremos aplicar g a x e, em seguida, aplicar f ao resultado. Aqui está como poderíamos fazer isso de duas maneiras: usando a abordagem encadeada tradicional e usando o pipe %&gt;%.\n\nresultado &lt;- f(g(x))\n\nx %&gt;% \n  g() %&gt;%\n  f()\n\nAmbos os métodos produzirão o mesmo resultado. No entanto, a segunda abordagem usando o pipe %&gt;% é mais legível e fácil de entender, especialmente quando estamos encadeando múltiplas operações. Isso torna o código mais conciso e mais próximo de uma leitura natural da operação que está sendo realizada.\n\n\n\n\n\n\nTip\n\n\n\nUma boa prática ao usar o pipe %&gt;% é quebrar a linha após cada pipe para melhorar a legibilidade do código."
  },
  {
    "objectID": "03-dados.html#dados-no-formato-tidy",
    "href": "03-dados.html#dados-no-formato-tidy",
    "title": "3  Manipulação de dados",
    "section": "3.4 Dados no formato tidy",
    "text": "3.4 Dados no formato tidy\n\n“Tidy datasets are all alike, but every messy dataset is messy in its own way.” — Hadley Wickham.\n\nUm mesmo conjunto de dados pode ser representado de diversas maneiras. Veja o código abaixo que mostra o mesmo dado em três diferentes formatos.\n\ntable1\n\n# A tibble: 6 × 4\n  country      year  cases population\n  &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n\ntable2\n\n# A tibble: 12 × 4\n   country      year type            count\n   &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n 8 Brazil       2000 population  174504898\n 9 China        1999 cases          212258\n10 China        1999 population 1272915272\n11 China        2000 cases          213766\n12 China        2000 population 1280428583\n\ntable4a\n\n# A tibble: 3 × 3\n  country     `1999` `2000`\n  &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n\n\nTodas as representações acima são dos mesmos dados, mas não são igualmente fáceis de utilizar. A table1, por exemplo, será muito mais acessível para trabalhar dentro do tidyverse devido à sua organização no formato tidy. Existem três regras inter-relacionadas que caracterizam um conjunto de dados no formato tidy:\n\nCada variável é uma coluna; cada coluna representa uma variável.\nCada observação é uma linha; cada linha representa uma observação.\nCada valor é uma célula; cada célula contém um único valor.\n\nA figura abaixo representa graficamente este conceito.\n\n\n\nImagem do livro R4DS.\n\n\nA pivotação de dados é o processo de reorganizar um conjunto de dados para torná-lo compatível com o formato tidy. Isso envolve transformar os dados de um formato mais largo para um formato mais longo, ou vice-versa, para garantir que cada variável corresponda a uma coluna e cada observação a uma linha.\nNo exemplo abaixo, estamos transformando os dados de table2 para um formato mais largo, onde cada valor único da variável type se torna uma nova coluna. Note que cada unidade de informação (país, ano, casos e contagem) está quebrado em duas linhas. Então essa operação deixa a tabela de dados mais larga, garantindo que cada unidade de dado esteja representada em uma única linha.\n\ntable2 %&gt;% \n  pivot_wider(names_from=\"type\", values_from=\"count\")\n\n# A tibble: 6 × 4\n  country      year  cases population\n  &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n\n\nNo exemplo abaixo, estamos transformando os dados de table4a em um formato mais longo, onde as colunas representando anos específicos (1999 e 2000) são reunidas em uma única coluna chamada year, e os valores correspondentes são colocados em uma nova coluna chamada cases. Neste caso, a informação sobre os anos estavam armazenadas como nome de colunas, mas, pelo princípio de dados tidy, deveriam estar em colunas. Por isso, utilizamos a função pivot_longer.\n\ntable4a %&gt;% \n  pivot_longer(cols = c(`1999`, `2000`), names_to = \"year\", values_to = \"cases\")\n\n# A tibble: 6 × 3\n  country     year   cases\n  &lt;chr&gt;       &lt;chr&gt;  &lt;dbl&gt;\n1 Afghanistan 1999     745\n2 Afghanistan 2000    2666\n3 Brazil      1999   37737\n4 Brazil      2000   80488\n5 China       1999  212258\n6 China       2000  213766\n\n\nAs duas funções pivot_wider e pivot_longer são suficientes para fazer a transformação de bases de dados no formato tidy."
  },
  {
    "objectID": "03-dados.html#principais-verbos-do-pacote-dplyr",
    "href": "03-dados.html#principais-verbos-do-pacote-dplyr",
    "title": "3  Manipulação de dados",
    "section": "3.5 Principais verbos do pacote dplyr",
    "text": "3.5 Principais verbos do pacote dplyr\nO pacote dplyr é uma das ferramentas mais poderosas para manipulação de dados no ambiente R. Ele oferece um conjunto coeso de funções que simplificam tarefas comuns de manipulação, como filtragem, seleção, agrupamento, ordenação e resumo de dados. O dplyr utiliza uma sintaxe intuitiva e consistente, facilitando a escrita de código limpo e legível.\nA seguir, vamos estudar o funcionamento dos principais verbos do pacote. Para exemplificar, vamos utilizar a base de dados gapminder. Ela é uma coleção de informações socioeconômicas de diversos países ao longo do tempo, veja Rosling (2012). Ela inclui variáveis como expectativa de vida, PIB per capita, taxa de mortalidade infantil e tamanho da população para diferentes países e anos, cobrindo um período de várias décadas.\nPara carregar a base de dados gapminder, você precisa carregar o pacote gapminder. Com o pacote gapminder carregado, a base de dados gapminder estará disponível para uso em seu ambiente R:\n\nlibrary(gapminder)\n\nWarning: package 'gapminder' was built under R version 4.2.3\n\nhead(gapminder)\n\nA função glimpse() fornece uma visão geral rápida e concisa da estrutura de um conjunto de dados. Quando aplicada a um conjunto de dados, como o gapminder, ela exibe informações essenciais sobre as variáveis presentes, incluindo a quantidade de linhas, colunas e as primeiras linhas do conjunto de dados:\n\nglimpse(gapminder)\n\nRows: 1,704\nColumns: 6\n$ country   &lt;fct&gt; \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", \"Afghanistan\", …\n$ continent &lt;fct&gt; Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, …\n$ year      &lt;int&gt; 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, …\n$ lifeExp   &lt;dbl&gt; 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39.854, 40.8…\n$ pop       &lt;int&gt; 8425333, 9240934, 10267083, 11537966, 13079460, 14880372, 12…\n$ gdpPercap &lt;dbl&gt; 779.4453, 820.8530, 853.1007, 836.1971, 739.9811, 786.1134, …\n\n\n\n3.5.1 select\nO verbo select() é utilizado para selecionar colunas específicas de um conjunto de dados. Com o select(), é possível escolher as colunas desejadas com base em seus nomes, tipos de dados ou outros critérios.\nPor exemplo, considerando a base de dados gapminder, suponha que desejamos selecionar apenas as colunas referentes ao ano, ao país, à expectativa de vida e ao PIB per capita. Podemos fazer isso da seguinte maneira:\n\n# Selecionando as colunas pelo nome\ngapminder %&gt;%\n  select(year, country, lifeExp, gdpPercap)\n\n# Selecionando apenas as colunas numéricas\ngapminder %&gt;% \n  select(where(is.numeric))\n\n# Selecionando colunas que começam com \"co\"\ngapminder %&gt;% \n  select(starts_with(\"co\"))\n\nNote que nos exemplos acima, nenhuma das seleções foi salva em variável. Para salvar as seleções em uma variável, você pode atribuir o resultado de cada operação select() a uma variável separada. Por exemplo:\n\ngapminder_character &lt;- gapminder %&gt;% \n  select(where(is.character))\n\n\n\n3.5.2 arrange\nO verbo arrange() é usado para reorganizar as linhas de um conjunto de dados com base nos valores de uma ou mais colunas. Quando aplicado a um conjunto de dados, o arrange() classifica as linhas em ordem crescente ou decrescente com base nos valores das colunas especificadas.\nNo primeiro exemplo usando o verbo select(), podemos ordenar os dados por país em ordem alfabética, podemos fazer assim:\n\ngapminder %&gt;%\n  select(year, country, lifeExp, gdpPercap, pop) %&gt;%\n  arrange(country)\n\n# A tibble: 1,704 × 5\n    year country     lifeExp gdpPercap      pop\n   &lt;int&gt; &lt;fct&gt;         &lt;dbl&gt;     &lt;dbl&gt;    &lt;int&gt;\n 1  1952 Afghanistan    28.8      779.  8425333\n 2  1957 Afghanistan    30.3      821.  9240934\n 3  1962 Afghanistan    32.0      853. 10267083\n 4  1967 Afghanistan    34.0      836. 11537966\n 5  1972 Afghanistan    36.1      740. 13079460\n 6  1977 Afghanistan    38.4      786. 14880372\n 7  1982 Afghanistan    39.9      978. 12881816\n 8  1987 Afghanistan    40.8      852. 13867957\n 9  1992 Afghanistan    41.7      649. 16317921\n10  1997 Afghanistan    41.8      635. 22227415\n# ℹ 1,694 more rows\n\n\nNo exemplo abaixo, estamos organizando de acordo com o ano em ordem crescente e a expectativa de vida em ordem decrescente dentro de cada ano.\n\ngapminder %&gt;%\n  select(year, country, lifeExp, gdpPercap, pop) %&gt;%\n  arrange(year, desc(lifeExp))\n\n# A tibble: 1,704 × 5\n    year country        lifeExp gdpPercap      pop\n   &lt;int&gt; &lt;fct&gt;            &lt;dbl&gt;     &lt;dbl&gt;    &lt;int&gt;\n 1  1952 Norway            72.7    10095.  3327728\n 2  1952 Iceland           72.5     7268.   147962\n 3  1952 Netherlands       72.1     8942. 10381988\n 4  1952 Sweden            71.9     8528.  7124673\n 5  1952 Denmark           70.8     9692.  4334000\n 6  1952 Switzerland       69.6    14734.  4815000\n 7  1952 New Zealand       69.4    10557.  1994794\n 8  1952 United Kingdom    69.2     9980. 50430000\n 9  1952 Australia         69.1    10040.  8691212\n10  1952 Canada            68.8    11367. 14785584\n# ℹ 1,694 more rows\n\n\n\n\n\n\n\n\nTip\n\n\n\nAo utilizar o verbo select() com o prefixo -, você pode especificar as colunas que deseja excluir do conjunto de dados. No exemplo abaixo, vamos excluir a coluna continent da seleção no conjunto de dados.\n\ngapminder %&gt;% \n  select(-continent)\n\n# A tibble: 1,704 × 5\n   country      year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan  1952    28.8  8425333      779.\n 2 Afghanistan  1957    30.3  9240934      821.\n 3 Afghanistan  1962    32.0 10267083      853.\n 4 Afghanistan  1967    34.0 11537966      836.\n 5 Afghanistan  1972    36.1 13079460      740.\n 6 Afghanistan  1977    38.4 14880372      786.\n 7 Afghanistan  1982    39.9 12881816      978.\n 8 Afghanistan  1987    40.8 13867957      852.\n 9 Afghanistan  1992    41.7 16317921      649.\n10 Afghanistan  1997    41.8 22227415      635.\n# ℹ 1,694 more rows\n\n\n\n\n\n\n3.5.3 filter\nPara analisar dados específicos de interesse, muitas vezes é necessário filtrar o conjunto de dados para incluir apenas as observações relevantes. O verbo filter() é usado para fazer isso. Basta definir uma ou mais condições lógicas que as linhas da base de dados devem satisfazer para serem mostradas.\nNo exemplo abaixo, estamos filtrando os dados para incluir apenas as observações onde o país é “Brasil” ou “Argentina”.\n\ngapminder %&gt;%\n  select(year, country, lifeExp, gdpPercap, pop) %&gt;%\n  arrange(year, desc(lifeExp)) %&gt;% \n  filter(country == \"Brazil\" | country == \"Argentina\")\n\n# A tibble: 24 × 5\n    year country   lifeExp gdpPercap       pop\n   &lt;int&gt; &lt;fct&gt;       &lt;dbl&gt;     &lt;dbl&gt;     &lt;int&gt;\n 1  1952 Argentina    62.5     5911.  17876956\n 2  1952 Brazil       50.9     2109.  56602560\n 3  1957 Argentina    64.4     6857.  19610538\n 4  1957 Brazil       53.3     2487.  65551171\n 5  1962 Argentina    65.1     7133.  21283783\n 6  1962 Brazil       55.7     3337.  76039390\n 7  1967 Argentina    65.6     8053.  22934225\n 8  1967 Brazil       57.6     3430.  88049823\n 9  1972 Argentina    67.1     9443.  24779799\n10  1972 Brazil       59.5     4986. 100840058\n# ℹ 14 more rows\n\n\n\n\n3.5.4 mutate\nO verbo mutate() é usado para criar ou modificar colunas em um conjunto de dados existente. Ele permite adicionar novas variáveis calculadas com base em variáveis existentes ou modificar as variáveis existentes de acordo com alguma lógica específica.\nPor exemplo, podemos usar o mutate() para calcular uma nova variável que represente o PIB total de cada país multiplicando o PIB per capita pelo tamanho da população. Aqui está um exemplo de como fazer isso com o conjunto de dados gapminder:\n\ngapminder_total_gdp &lt;- gapminder %&gt;%\n  select(country, year, lifeExp, gdpPercap, pop) %&gt;%\n  mutate(total_gdp = gdpPercap * pop)\n\n\n\n3.5.5 summarise\nO verbo summarise() é usado para resumir os dados em uma única linha, geralmente calculando estatísticas resumidas como média, soma, mediana, etc. Ele permite calcular resumos estatísticos em um conjunto de dados, criando uma nova tabela contendo os resultados resumidos.\nAqui está um exemplo de como usar summarise() para calcular a média da expectativa de vida usando os dados do gapminder:\n\ngapminder %&gt;%\n  summarise(mean_lifeExp = mean(lifeExp, na.rm = TRUE))\n\n# A tibble: 1 × 1\n  mean_lifeExp\n         &lt;dbl&gt;\n1         59.5\n\n\n\n\n3.5.6 group by\nO verbo group_by() é usado para dividir os dados em grupos com base nos valores de uma ou mais variáveis. Ele não realiza cálculos por si só, mas altera o comportamento das funções de resumo, como summarise(), para operar em cada grupo separadamente.\nAqui está um exemplo de como usar group_by() com os dados do gapminder para calcular a média da expectativa de vida por continente:\n\ngapminder %&gt;%\n  group_by(continent) %&gt;%\n  summarise(mean_lifeExp = mean(lifeExp, na.rm = TRUE))\n\n# A tibble: 5 × 2\n  continent mean_lifeExp\n  &lt;fct&gt;            &lt;dbl&gt;\n1 Africa            48.9\n2 Americas          64.7\n3 Asia              60.1\n4 Europe            71.9\n5 Oceania           74.3\n\n\nO exemplo abaixo utiliza todos os principais verbos do dplyr para calcular a expectativa de vida média e o PIB (em milhares) médio por continente no ano de 2007.\n\ngapminder %&gt;%\n  select(country, continent, year, lifeExp, gdpPercap) %&gt;% \n  filter(year == 2007) %&gt;% # apenas os dados para o ano de 2007\n  mutate(gdp = gdpPercap / 1000) %&gt;% # representa o PIB per capita em milhares\n  group_by(continent) %&gt;% # agrupar os dados por continente\n  summarise(mean_lifeExp = mean(lifeExp, na.rm = TRUE), # média da expectativa de vida\n            mean_gdp = mean(gdp, na.rm = TRUE)) %&gt;% #média do PIB per capita em bilhões\n  arrange(desc(mean_lifeExp))\n\n# A tibble: 5 × 3\n  continent mean_lifeExp mean_gdp\n  &lt;fct&gt;            &lt;dbl&gt;    &lt;dbl&gt;\n1 Oceania           80.7    29.8 \n2 Europe            77.6    25.1 \n3 Americas          73.6    11.0 \n4 Asia              70.7    12.5 \n5 Africa            54.8     3.09\n\n\nO gráfico abaixo mostra a evolução da expectativa de vida média nos continentes ao longo dos anos.\n\n\n\n\n\n\n\n\n\n\n\nDesafio\n\n\n\nQual mudança foi feita no código do exemplo anterior para construir os dados usados na geração deste gráfico?"
  },
  {
    "objectID": "06-visualizacao_python.html#tudo-junto",
    "href": "06-visualizacao_python.html#tudo-junto",
    "title": "6  Processamento e visualização de dados",
    "section": "6.5 Tudo junto",
    "text": "6.5 Tudo junto\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Gerando dados aleatórios para simular valores de PIB\nnp.random.seed(42)\npib = np.random.normal(500, 100, 100)  # Simulando 100 valores de PIB\n\n# Calculando média, mediana e desvio padrão do PIB\nmedia_pib = np.mean(pib)\nmediana_pib = np.median(pib)\ndesvio_padrao_pib = np.std(pib)\n\nprint(\"Média do PIB:\", media_pib)\nprint(\"Mediana do PIB:\", mediana_pib)\nprint(\"Desvio padrão do PIB:\", desvio_padrao_pib)\n\n# Criando um DataFrame do pandas para visualização\ndf = pd.DataFrame({'PIB': pib})\n\n# Plotando um histograma dos valores do PIB\nplt.hist(pib, bins=10, color='skyblue', edgecolor='black')\nplt.title('Distribuição do PIB')\nplt.xlabel('PIB')\nplt.ylabel('Frequência')\nplt.show()\n\nMédia do PIB: 489.61534826059057\nMediana do PIB: 487.3043708220287\nDesvio padrão do PIB: 90.36161766446295"
  },
  {
    "objectID": "06-visualizacao_python.html#análise-de-dados-avançada",
    "href": "06-visualizacao_python.html#análise-de-dados-avançada",
    "title": "6  Processamento e visualização de dados",
    "section": "6.5 Análise de Dados Avançada",
    "text": "6.5 Análise de Dados Avançada\n\nCaso 1: Visualizando dados NumPy com Matplotlib\nO objetivo deste exemplo é demonstrar como usar NumPy e Matplotlib em conjunto para analisar dados econômicos simulados. Leia o código abaixo e tente entender o que está sendo feito.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# Gerando dados aleatórios para simular valores de PIB\nnp.random.seed(42)\npib = np.random.normal(500, 100, 100)  # Simulando 100 valores de PIB\n\n# Calculando média, mediana e desvio padrão do PIB\nmedia_pib = np.mean(pib)\nmediana_pib = np.median(pib)\ndesvio_padrao_pib = np.std(pib)\n\nprint(\"Média do PIB:\", media_pib)\nprint(\"Mediana do PIB:\", mediana_pib)\nprint(\"Desvio padrão do PIB:\", desvio_padrao_pib)\n\n# Plotando um histograma dos valores do PIB\nplt.hist(pib, bins=10, color='skyblue', edgecolor='black')\nplt.title('Distribuição do PIB')\nplt.xlabel('PIB')\nplt.ylabel('Frequência')\nplt.show()\n\nMédia do PIB: 489.61534826059057\nMediana do PIB: 487.3043708220287\nDesvio padrão do PIB: 90.36161766446295\n\n\n\n\n\nNo exemplo acima, começamos gerando dados aleatórios para simular valores de PIB usando a distribuição normal com uma média de 500 e um desvio padrão de 100. Em seguida, calculamos a média, a mediana e o desvio padrão desses valores usando funções NumPy. Para facilitar a visualização e análise dos dados, plotamos um histograma usando Matplotlib. Este histograma nos permite visualizar a distribuição dos valores do PIB e identificar tendências ou padrões nos dados.\n\n\nCaso 2: Gapminder\nO objetivo deste exemplo é demonstrar como usar Pandas, NumPy e Matplotlib em conjunto para realizar análises exploratórias de dados do Gapminder.\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Carregar os dados do Gapminder usando Pandas\ngapminder = pd.read_csv('caminho/do/arquivo/gapminder.csv')\n\n# Calcular a média da expectativa de vida usando NumPy\nmean_life_expectancy = np.mean(gapminder['lifeExp'])\n\n# Calcular a mediana do PIB per capita usando NumPy\nmedian_gdp_per_capita = np.median(gapminder['gdpPercap'])\n\n# Plotar um histograma da expectativa de vida usando Matplotlib\nplt.hist(gapminder['lifeExp'], bins=20, color='skyblue', edgecolor='black')\nplt.axvline(mean_life_expectancy, color='red', linestyle='dashed', linewidth=1)\nplt.text(mean_life_expectancy + 1, 50, f'Média: {mean_life_expectancy:.2f}', color='red')\nplt.xlabel('Expectativa de Vida')\nplt.ylabel('Frequência')\nplt.title('Distribuição da Expectativa de Vida')\nplt.show()\n\n# Plotar um gráfico de dispersão entre expectativa de vida e PIB per capita usando Matplotlib\nplt.scatter(gapminder['gdpPercap'], gapminder['lifeExp'], alpha=0.5)\nplt.axhline(mean_life_expectancy, color='red', linestyle='dashed', linewidth=1)\nplt.axvline(median_gdp_per_capita, color='green', linestyle='dashed', linewidth=1)\nplt.text(median_gdp_per_capita + 500, mean_life_expectancy + 1, f'Mediana: {median_gdp_per_capita:.2f}', color='green')\nplt.xlabel('PIB per Capita')\nplt.ylabel('Expectativa de Vida')\nplt.title('PIB per Capita vs Expectativa de Vida')\nplt.show()\n\nNo código acima, começamos carregando os dados do Gapminder usando a função pd.read_csv() do Pandas. Em seguida, calculamos a média da expectativa de vida e a mediana do PIB per capita usando funções NumPy np.mean() e np.median(), respectivamente. Para visualizar a distribuição da expectativa de vida, plotamos um histograma usando a função plt.hist() do Matplotlib."
  },
  {
    "objectID": "06-visualizacao_python.html#exercícios",
    "href": "06-visualizacao_python.html#exercícios",
    "title": "6  Processamento e visualização de dados",
    "section": "6.6 Exercícios",
    "text": "6.6 Exercícios"
  },
  {
    "objectID": "07-casos.html",
    "href": "07-casos.html",
    "title": "7  Estudo de casos práticos",
    "section": "",
    "text": "O objetivo deste capítulo é apresentar estudos de casos reais usando tanto R quanto Python.\n\n\n\n\n\n\nImportant\n\n\n\nPágina ainda em construção!"
  },
  {
    "objectID": "03-dados.html#funções-auxiliares",
    "href": "03-dados.html#funções-auxiliares",
    "title": "3  Manipulação de dados",
    "section": "3.6 Funções auxiliares",
    "text": "3.6 Funções auxiliares\nApresentando funções auxiliares do pacote dplyr que podem ser muito úteis em diversos contextos.\n\npull, distinct, unite, separate_wider_delim, e a familia de funções slice_*.\n\n\ngapminder %&gt;% \n  filter(year == 1952) %&gt;% \n  pull(continent)\n\n  [1] Asia     Europe   Africa   Africa   Americas Oceania  Europe   Asia    \n  [9] Asia     Europe   Africa   Americas Europe   Africa   Americas Europe  \n [17] Africa   Africa   Asia     Africa   Americas Africa   Africa   Americas\n [25] Asia     Americas Africa   Africa   Africa   Americas Africa   Europe  \n [33] Americas Europe   Europe   Africa   Americas Americas Africa   Americas\n [41] Africa   Africa   Africa   Europe   Europe   Africa   Africa   Europe  \n [49] Africa   Europe   Americas Africa   Africa   Americas Americas Asia    \n [57] Europe   Europe   Asia     Asia     Asia     Asia     Europe   Asia    \n [65] Europe   Americas Asia     Asia     Africa   Asia     Asia     Asia    \n [73] Asia     Africa   Africa   Africa   Africa   Africa   Asia     Africa  \n [81] Africa   Africa   Americas Asia     Europe   Africa   Africa   Asia    \n [89] Africa   Asia     Europe   Oceania  Americas Africa   Africa   Europe  \n [97] Asia     Asia     Americas Americas Americas Asia     Europe   Europe  \n[105] Americas Africa   Europe   Africa   Africa   Asia     Africa   Europe  \n[113] Africa   Asia     Europe   Europe   Africa   Africa   Europe   Asia    \n[121] Africa   Africa   Europe   Europe   Asia     Asia     Africa   Asia    \n[129] Africa   Americas Africa   Europe   Africa   Europe   Americas Americas\n[137] Americas Asia     Asia     Asia     Africa   Africa  \nLevels: Africa Americas Asia Europe Oceania\n\ngapminder %&gt;% \n  distinct(continent)\n\n# A tibble: 5 × 1\n  continent\n  &lt;fct&gt;    \n1 Asia     \n2 Europe   \n3 Africa   \n4 Americas \n5 Oceania  \n\ngapminder %&gt;% \n  slice(1:10)\n\n# A tibble: 10 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n\ngapminder %&gt;% \n  slice_head(n = 5)\n\n# A tibble: 5 × 6\n  country     continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Afghanistan Asia       1952    28.8  8425333      779.\n2 Afghanistan Asia       1957    30.3  9240934      821.\n3 Afghanistan Asia       1962    32.0 10267083      853.\n4 Afghanistan Asia       1967    34.0 11537966      836.\n5 Afghanistan Asia       1972    36.1 13079460      740.\n\ngapminder %&gt;% \n  slice_tail(n = 5)\n\n# A tibble: 5 × 6\n  country  continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;    &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Zimbabwe Africa     1987    62.4  9216418      706.\n2 Zimbabwe Africa     1992    60.4 10704340      693.\n3 Zimbabwe Africa     1997    46.8 11404948      792.\n4 Zimbabwe Africa     2002    40.0 11926563      672.\n5 Zimbabwe Africa     2007    43.5 12311143      470.\n\nset.seed(1)\ngapminder %&gt;% \n  slice_sample(n = 10)\n\n# A tibble: 10 × 6\n   country     continent  year lifeExp        pop gdpPercap\n   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;      &lt;int&gt;     &lt;dbl&gt;\n 1 Montenegro  Europe     1992    75.4     621621     7003.\n 2 Hungary     Europe     1982    69.4   10705535    12546.\n 3 Benin       Africa     1992    53.9    4981671     1191.\n 4 Malawi      Africa     1977    43.8    5637246      663.\n 5 Thailand    Asia       1992    67.3   56667095     4617.\n 6 El Salvador Americas   1962    52.3    2747687     3777.\n 7 China       Asia       2002    72.0 1280400000     3119.\n 8 Chad        Africa     1977    47.4    4388260     1134.\n 9 Peru        Americas   2002    69.9   26769436     5909.\n10 Senegal     Africa     2002    61.6   10870037     1520.\n\ngapminder %&gt;% \n  filter(year == 2007) %&gt;% \n  slice_max(lifeExp, n = 2)\n\n# A tibble: 2 × 6\n  country          continent  year lifeExp       pop gdpPercap\n  &lt;fct&gt;            &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n1 Japan            Asia       2007    82.6 127467972    31656.\n2 Hong Kong, China Asia       2007    82.2   6980412    39725.\n\ngapminder %&gt;% \n  filter(year == 2007) %&gt;% \n  slice_min(lifeExp, n = 2)\n\n# A tibble: 2 × 6\n  country    continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;      &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Swaziland  Africa     2007    39.6  1133066     4513.\n2 Mozambique Africa     2007    42.1 19951656      824.\n\ngapminder %&gt;% \n  filter(year == 2007 | year == 1952) %&gt;% \n  group_by(year) %&gt;% \n  slice_max(lifeExp, n = 2)\n\n# A tibble: 4 × 6\n# Groups:   year [2]\n  country          continent  year lifeExp       pop gdpPercap\n  &lt;fct&gt;            &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;     &lt;int&gt;     &lt;dbl&gt;\n1 Norway           Europe     1952    72.7   3327728    10095.\n2 Iceland          Europe     1952    72.5    147962     7268.\n3 Japan            Asia       2007    82.6 127467972    31656.\n4 Hong Kong, China Asia       2007    82.2   6980412    39725.\n\ngapminder_united &lt;- gapminder %&gt;% \n  unite(\"country_continent\", c(country, continent),\n        sep = \"_\",\n        remove = TRUE,\n        na.rm = FALSE)\n\ngapminder_united %&gt;%\n  separate_wider_delim(country_continent,\n                       delim = \"_\",\n                       names = c(\"country\", \"continent\"))\n\n# A tibble: 1,704 × 6\n   country     continent  year lifeExp      pop gdpPercap\n   &lt;chr&gt;       &lt;chr&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n 1 Afghanistan Asia       1952    28.8  8425333      779.\n 2 Afghanistan Asia       1957    30.3  9240934      821.\n 3 Afghanistan Asia       1962    32.0 10267083      853.\n 4 Afghanistan Asia       1967    34.0 11537966      836.\n 5 Afghanistan Asia       1972    36.1 13079460      740.\n 6 Afghanistan Asia       1977    38.4 14880372      786.\n 7 Afghanistan Asia       1982    39.9 12881816      978.\n 8 Afghanistan Asia       1987    40.8 13867957      852.\n 9 Afghanistan Asia       1992    41.7 16317921      649.\n10 Afghanistan Asia       1997    41.8 22227415      635.\n# ℹ 1,694 more rows"
  }
]